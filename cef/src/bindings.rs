#![allow(dead_code, non_camel_case_types, unused_variables)]
use crate::rc::{ConvertParam, ConvertReturnValue, Rc, RcImpl, RefGuard, WrapParamRef};
use cef_sys::*;
#[doc = r" Perform the conversion between CEF and Rust types in field initializers."]
fn init_array_field<T, U, const N: usize>(mut value: [U; N]) -> [T; N]
where
    T: Sized,
    U: Sized + Into<T>,
{
    std::array::from_fn(move |i| {
        let mut elem = unsafe { std::mem::zeroed() };
        std::mem::swap(&mut value[i], &mut elem);
        elem.into()
    })
}

// Type aliases
pub type CefStringUserfreeWide = *mut CefStringWide;
pub type CefStringUserfreeUtf8 = *mut CefStringUtf8;
pub type CefStringUserfreeUtf16 = *mut CefStringUtf16;
pub type Char = char16_t;
pub type CefStringUserfree = *mut CefStringUtf16;
pub type CefString = CefStringUtf16;
pub type AcceleratedPaintNativePixmapPlane = AcceleratedPaintNativePixmapPlaneInfo;
pub type Color = u32;

// Struct wrappers
#[doc = "See [_cef_string_wide_t] for more documentation."]
#[repr(transparent)]
pub struct CefStringWide(_cef_string_wide_t);
impl From<_cef_string_wide_t> for CefStringWide {
    fn from(value: _cef_string_wide_t) -> Self {
        Self(value)
    }
}
impl Into<*const _cef_string_wide_t> for &CefStringWide {
    fn into(self) -> *const _cef_string_wide_t {
        self.as_ref() as *const _cef_string_wide_t
    }
}
impl Into<*mut _cef_string_wide_t> for &mut CefStringWide {
    fn into(self) -> *mut _cef_string_wide_t {
        self.as_mut() as *mut _cef_string_wide_t
    }
}
impl Into<_cef_string_wide_t> for CefStringWide {
    fn into(self) -> _cef_string_wide_t {
        self.0
    }
}
impl AsRef<_cef_string_wide_t> for CefStringWide {
    fn as_ref(&self) -> &_cef_string_wide_t {
        &self.0
    }
}
impl AsMut<_cef_string_wide_t> for CefStringWide {
    fn as_mut(&mut self) -> &mut _cef_string_wide_t {
        &mut self.0
    }
}
impl Default for CefStringWide {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [_cef_string_utf8_t] for more documentation."]
#[repr(transparent)]
pub struct CefStringUtf8(_cef_string_utf8_t);
impl From<_cef_string_utf8_t> for CefStringUtf8 {
    fn from(value: _cef_string_utf8_t) -> Self {
        Self(value)
    }
}
impl Into<*const _cef_string_utf8_t> for &CefStringUtf8 {
    fn into(self) -> *const _cef_string_utf8_t {
        self.as_ref() as *const _cef_string_utf8_t
    }
}
impl Into<*mut _cef_string_utf8_t> for &mut CefStringUtf8 {
    fn into(self) -> *mut _cef_string_utf8_t {
        self.as_mut() as *mut _cef_string_utf8_t
    }
}
impl Into<_cef_string_utf8_t> for CefStringUtf8 {
    fn into(self) -> _cef_string_utf8_t {
        self.0
    }
}
impl AsRef<_cef_string_utf8_t> for CefStringUtf8 {
    fn as_ref(&self) -> &_cef_string_utf8_t {
        &self.0
    }
}
impl AsMut<_cef_string_utf8_t> for CefStringUtf8 {
    fn as_mut(&mut self) -> &mut _cef_string_utf8_t {
        &mut self.0
    }
}
impl Default for CefStringUtf8 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [_cef_string_utf16_t] for more documentation."]
#[repr(transparent)]
pub struct CefStringUtf16(_cef_string_utf16_t);
impl From<_cef_string_utf16_t> for CefStringUtf16 {
    fn from(value: _cef_string_utf16_t) -> Self {
        Self(value)
    }
}
impl Into<*const _cef_string_utf16_t> for &CefStringUtf16 {
    fn into(self) -> *const _cef_string_utf16_t {
        self.as_ref() as *const _cef_string_utf16_t
    }
}
impl Into<*mut _cef_string_utf16_t> for &mut CefStringUtf16 {
    fn into(self) -> *mut _cef_string_utf16_t {
        self.as_mut() as *mut _cef_string_utf16_t
    }
}
impl Into<_cef_string_utf16_t> for CefStringUtf16 {
    fn into(self) -> _cef_string_utf16_t {
        self.0
    }
}
impl AsRef<_cef_string_utf16_t> for CefStringUtf16 {
    fn as_ref(&self) -> &_cef_string_utf16_t {
        &self.0
    }
}
impl AsMut<_cef_string_utf16_t> for CefStringUtf16 {
    fn as_mut(&mut self) -> &mut _cef_string_utf16_t {
        &mut self.0
    }
}
impl Default for CefStringUtf16 {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [_cef_string_list_t] for more documentation."]
#[repr(transparent)]
pub struct CefStringList(_cef_string_list_t);
impl From<_cef_string_list_t> for CefStringList {
    fn from(value: _cef_string_list_t) -> Self {
        Self(value)
    }
}
impl Into<*const _cef_string_list_t> for &CefStringList {
    fn into(self) -> *const _cef_string_list_t {
        self.as_ref() as *const _cef_string_list_t
    }
}
impl Into<*mut _cef_string_list_t> for &mut CefStringList {
    fn into(self) -> *mut _cef_string_list_t {
        self.as_mut() as *mut _cef_string_list_t
    }
}
impl Into<_cef_string_list_t> for CefStringList {
    fn into(self) -> _cef_string_list_t {
        self.0
    }
}
impl AsRef<_cef_string_list_t> for CefStringList {
    fn as_ref(&self) -> &_cef_string_list_t {
        &self.0
    }
}
impl AsMut<_cef_string_list_t> for CefStringList {
    fn as_mut(&mut self) -> &mut _cef_string_list_t {
        &mut self.0
    }
}
impl Default for CefStringList {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [_cef_string_map_t] for more documentation."]
#[repr(transparent)]
pub struct CefStringMap(_cef_string_map_t);
impl From<_cef_string_map_t> for CefStringMap {
    fn from(value: _cef_string_map_t) -> Self {
        Self(value)
    }
}
impl Into<*const _cef_string_map_t> for &CefStringMap {
    fn into(self) -> *const _cef_string_map_t {
        self.as_ref() as *const _cef_string_map_t
    }
}
impl Into<*mut _cef_string_map_t> for &mut CefStringMap {
    fn into(self) -> *mut _cef_string_map_t {
        self.as_mut() as *mut _cef_string_map_t
    }
}
impl Into<_cef_string_map_t> for CefStringMap {
    fn into(self) -> _cef_string_map_t {
        self.0
    }
}
impl AsRef<_cef_string_map_t> for CefStringMap {
    fn as_ref(&self) -> &_cef_string_map_t {
        &self.0
    }
}
impl AsMut<_cef_string_map_t> for CefStringMap {
    fn as_mut(&mut self) -> &mut _cef_string_map_t {
        &mut self.0
    }
}
impl Default for CefStringMap {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [_cef_string_multimap_t] for more documentation."]
#[repr(transparent)]
pub struct CefStringMultimap(_cef_string_multimap_t);
impl From<_cef_string_multimap_t> for CefStringMultimap {
    fn from(value: _cef_string_multimap_t) -> Self {
        Self(value)
    }
}
impl Into<*const _cef_string_multimap_t> for &CefStringMultimap {
    fn into(self) -> *const _cef_string_multimap_t {
        self.as_ref() as *const _cef_string_multimap_t
    }
}
impl Into<*mut _cef_string_multimap_t> for &mut CefStringMultimap {
    fn into(self) -> *mut _cef_string_multimap_t {
        self.as_mut() as *mut _cef_string_multimap_t
    }
}
impl Into<_cef_string_multimap_t> for CefStringMultimap {
    fn into(self) -> _cef_string_multimap_t {
        self.0
    }
}
impl AsRef<_cef_string_multimap_t> for CefStringMultimap {
    fn as_ref(&self) -> &_cef_string_multimap_t {
        &self.0
    }
}
impl AsMut<_cef_string_multimap_t> for CefStringMultimap {
    fn as_mut(&mut self) -> &mut _cef_string_multimap_t {
        &mut self.0
    }
}
impl Default for CefStringMultimap {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [_cef_basetime_t] for more documentation."]
#[derive(Clone)]
pub struct Basetime {
    pub val: i64,
}
impl From<_cef_basetime_t> for Basetime {
    fn from(value: _cef_basetime_t) -> Self {
        Self {
            val: value.val.into(),
        }
    }
}
impl Into<_cef_basetime_t> for Basetime {
    fn into(self) -> _cef_basetime_t {
        _cef_basetime_t {
            val: self.val.into(),
        }
    }
}
impl Default for Basetime {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [_cef_time_t] for more documentation."]
#[derive(Clone)]
pub struct Time {
    pub year: ::std::os::raw::c_int,
    pub month: ::std::os::raw::c_int,
    pub day_of_week: ::std::os::raw::c_int,
    pub day_of_month: ::std::os::raw::c_int,
    pub hour: ::std::os::raw::c_int,
    pub minute: ::std::os::raw::c_int,
    pub second: ::std::os::raw::c_int,
    pub millisecond: ::std::os::raw::c_int,
}
impl From<_cef_time_t> for Time {
    fn from(value: _cef_time_t) -> Self {
        Self {
            year: value.year.into(),
            month: value.month.into(),
            day_of_week: value.day_of_week.into(),
            day_of_month: value.day_of_month.into(),
            hour: value.hour.into(),
            minute: value.minute.into(),
            second: value.second.into(),
            millisecond: value.millisecond.into(),
        }
    }
}
impl Into<_cef_time_t> for Time {
    fn into(self) -> _cef_time_t {
        _cef_time_t {
            year: self.year.into(),
            month: self.month.into(),
            day_of_week: self.day_of_week.into(),
            day_of_month: self.day_of_month.into(),
            hour: self.hour.into(),
            minute: self.minute.into(),
            second: self.second.into(),
            millisecond: self.millisecond.into(),
        }
    }
}
impl Default for Time {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [_cef_point_t] for more documentation."]
#[derive(Clone)]
pub struct Point {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
}
impl From<_cef_point_t> for Point {
    fn from(value: _cef_point_t) -> Self {
        Self {
            x: value.x.into(),
            y: value.y.into(),
        }
    }
}
impl Into<_cef_point_t> for Point {
    fn into(self) -> _cef_point_t {
        _cef_point_t {
            x: self.x.into(),
            y: self.y.into(),
        }
    }
}
impl Default for Point {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [_cef_rect_t] for more documentation."]
#[derive(Clone)]
pub struct Rect {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
}
impl From<_cef_rect_t> for Rect {
    fn from(value: _cef_rect_t) -> Self {
        Self {
            x: value.x.into(),
            y: value.y.into(),
            width: value.width.into(),
            height: value.height.into(),
        }
    }
}
impl Into<_cef_rect_t> for Rect {
    fn into(self) -> _cef_rect_t {
        _cef_rect_t {
            x: self.x.into(),
            y: self.y.into(),
            width: self.width.into(),
            height: self.height.into(),
        }
    }
}
impl Default for Rect {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [_cef_size_t] for more documentation."]
#[derive(Clone)]
pub struct Size {
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
}
impl From<_cef_size_t> for Size {
    fn from(value: _cef_size_t) -> Self {
        Self {
            width: value.width.into(),
            height: value.height.into(),
        }
    }
}
impl Into<_cef_size_t> for Size {
    fn into(self) -> _cef_size_t {
        _cef_size_t {
            width: self.width.into(),
            height: self.height.into(),
        }
    }
}
impl Default for Size {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [_cef_insets_t] for more documentation."]
#[derive(Clone)]
pub struct Insets {
    pub top: ::std::os::raw::c_int,
    pub left: ::std::os::raw::c_int,
    pub bottom: ::std::os::raw::c_int,
    pub right: ::std::os::raw::c_int,
}
impl From<_cef_insets_t> for Insets {
    fn from(value: _cef_insets_t) -> Self {
        Self {
            top: value.top.into(),
            left: value.left.into(),
            bottom: value.bottom.into(),
            right: value.right.into(),
        }
    }
}
impl Into<_cef_insets_t> for Insets {
    fn into(self) -> _cef_insets_t {
        _cef_insets_t {
            top: self.top.into(),
            left: self.left.into(),
            bottom: self.bottom.into(),
            right: self.right.into(),
        }
    }
}
impl Default for Insets {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [_cef_main_args_t] for more documentation."]
#[derive(Clone)]
pub struct MainArgs {
    pub argc: ::std::os::raw::c_int,
    pub argv: *mut *mut ::std::os::raw::c_char,
}
impl From<_cef_main_args_t> for MainArgs {
    fn from(value: _cef_main_args_t) -> Self {
        Self {
            argc: value.argc.into(),
            argv: value.argv.into(),
        }
    }
}
impl Into<_cef_main_args_t> for MainArgs {
    fn into(self) -> _cef_main_args_t {
        _cef_main_args_t {
            argc: self.argc.into(),
            argv: self.argv.into(),
        }
    }
}
impl Default for MainArgs {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [_cef_window_info_t] for more documentation."]
#[derive(Clone)]
pub struct WindowInfo {
    pub window_name: CefStringUtf16,
    pub bounds: Rect,
    pub parent_window: ::std::os::raw::c_ulong,
    pub windowless_rendering_enabled: ::std::os::raw::c_int,
    pub shared_texture_enabled: ::std::os::raw::c_int,
    pub external_begin_frame_enabled: ::std::os::raw::c_int,
    pub window: ::std::os::raw::c_ulong,
    pub runtime_style: RuntimeStyle,
}
impl From<_cef_window_info_t> for WindowInfo {
    fn from(value: _cef_window_info_t) -> Self {
        Self {
            window_name: value.window_name.into(),
            bounds: value.bounds.into(),
            parent_window: value.parent_window.into(),
            windowless_rendering_enabled: value.windowless_rendering_enabled.into(),
            shared_texture_enabled: value.shared_texture_enabled.into(),
            external_begin_frame_enabled: value.external_begin_frame_enabled.into(),
            window: value.window.into(),
            runtime_style: value.runtime_style.into(),
        }
    }
}
impl Into<_cef_window_info_t> for WindowInfo {
    fn into(self) -> _cef_window_info_t {
        _cef_window_info_t {
            window_name: self.window_name.into(),
            bounds: self.bounds.into(),
            parent_window: self.parent_window.into(),
            windowless_rendering_enabled: self.windowless_rendering_enabled.into(),
            shared_texture_enabled: self.shared_texture_enabled.into(),
            external_begin_frame_enabled: self.external_begin_frame_enabled.into(),
            window: self.window.into(),
            runtime_style: self.runtime_style.into(),
        }
    }
}
impl Default for WindowInfo {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [_cef_accelerated_paint_native_pixmap_plane_info_t] for more documentation."]
#[derive(Clone)]
pub struct AcceleratedPaintNativePixmapPlaneInfo {
    pub stride: u32,
    pub offset: u64,
    pub size: u64,
    pub fd: ::std::os::raw::c_int,
}
impl From<_cef_accelerated_paint_native_pixmap_plane_info_t>
    for AcceleratedPaintNativePixmapPlaneInfo
{
    fn from(value: _cef_accelerated_paint_native_pixmap_plane_info_t) -> Self {
        Self {
            stride: value.stride.into(),
            offset: value.offset.into(),
            size: value.size.into(),
            fd: value.fd.into(),
        }
    }
}
impl Into<_cef_accelerated_paint_native_pixmap_plane_info_t>
    for AcceleratedPaintNativePixmapPlaneInfo
{
    fn into(self) -> _cef_accelerated_paint_native_pixmap_plane_info_t {
        _cef_accelerated_paint_native_pixmap_plane_info_t {
            stride: self.stride.into(),
            offset: self.offset.into(),
            size: self.size.into(),
            fd: self.fd.into(),
        }
    }
}
impl Default for AcceleratedPaintNativePixmapPlaneInfo {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [_cef_accelerated_paint_info_t] for more documentation."]
#[derive(Clone)]
pub struct AcceleratedPaintInfo {
    pub planes: [AcceleratedPaintNativePixmapPlaneInfo; 4usize],
    pub plane_count: ::std::os::raw::c_int,
    pub modifier: u64,
    pub format: ColorType,
}
impl From<_cef_accelerated_paint_info_t> for AcceleratedPaintInfo {
    fn from(value: _cef_accelerated_paint_info_t) -> Self {
        Self {
            planes: init_array_field(value.planes),
            plane_count: value.plane_count.into(),
            modifier: value.modifier.into(),
            format: value.format.into(),
        }
    }
}
impl Into<_cef_accelerated_paint_info_t> for AcceleratedPaintInfo {
    fn into(self) -> _cef_accelerated_paint_info_t {
        _cef_accelerated_paint_info_t {
            planes: init_array_field(self.planes),
            plane_count: self.plane_count.into(),
            modifier: self.modifier.into(),
            format: self.format.into(),
        }
    }
}
impl Default for AcceleratedPaintInfo {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [_cef_settings_t] for more documentation."]
#[derive(Clone)]
pub struct Settings {
    pub size: usize,
    pub no_sandbox: ::std::os::raw::c_int,
    pub browser_subprocess_path: CefStringUtf16,
    pub framework_dir_path: CefStringUtf16,
    pub main_bundle_path: CefStringUtf16,
    pub multi_threaded_message_loop: ::std::os::raw::c_int,
    pub external_message_pump: ::std::os::raw::c_int,
    pub windowless_rendering_enabled: ::std::os::raw::c_int,
    pub command_line_args_disabled: ::std::os::raw::c_int,
    pub cache_path: CefStringUtf16,
    pub root_cache_path: CefStringUtf16,
    pub persist_session_cookies: ::std::os::raw::c_int,
    pub user_agent: CefStringUtf16,
    pub user_agent_product: CefStringUtf16,
    pub locale: CefStringUtf16,
    pub log_file: CefStringUtf16,
    pub log_severity: LogSeverity,
    pub log_items: LogItems,
    pub javascript_flags: CefStringUtf16,
    pub resources_dir_path: CefStringUtf16,
    pub locales_dir_path: CefStringUtf16,
    pub remote_debugging_port: ::std::os::raw::c_int,
    pub uncaught_exception_stack_size: ::std::os::raw::c_int,
    pub background_color: u32,
    pub accept_language_list: CefStringUtf16,
    pub cookieable_schemes_list: CefStringUtf16,
    pub cookieable_schemes_exclude_defaults: ::std::os::raw::c_int,
    pub chrome_policy_id: CefStringUtf16,
    pub chrome_app_icon_id: ::std::os::raw::c_int,
    pub disable_signal_handlers: ::std::os::raw::c_int,
}
impl From<_cef_settings_t> for Settings {
    fn from(value: _cef_settings_t) -> Self {
        Self {
            size: value.size.into(),
            no_sandbox: value.no_sandbox.into(),
            browser_subprocess_path: value.browser_subprocess_path.into(),
            framework_dir_path: value.framework_dir_path.into(),
            main_bundle_path: value.main_bundle_path.into(),
            multi_threaded_message_loop: value.multi_threaded_message_loop.into(),
            external_message_pump: value.external_message_pump.into(),
            windowless_rendering_enabled: value.windowless_rendering_enabled.into(),
            command_line_args_disabled: value.command_line_args_disabled.into(),
            cache_path: value.cache_path.into(),
            root_cache_path: value.root_cache_path.into(),
            persist_session_cookies: value.persist_session_cookies.into(),
            user_agent: value.user_agent.into(),
            user_agent_product: value.user_agent_product.into(),
            locale: value.locale.into(),
            log_file: value.log_file.into(),
            log_severity: value.log_severity.into(),
            log_items: value.log_items.into(),
            javascript_flags: value.javascript_flags.into(),
            resources_dir_path: value.resources_dir_path.into(),
            locales_dir_path: value.locales_dir_path.into(),
            remote_debugging_port: value.remote_debugging_port.into(),
            uncaught_exception_stack_size: value.uncaught_exception_stack_size.into(),
            background_color: value.background_color.into(),
            accept_language_list: value.accept_language_list.into(),
            cookieable_schemes_list: value.cookieable_schemes_list.into(),
            cookieable_schemes_exclude_defaults: value.cookieable_schemes_exclude_defaults.into(),
            chrome_policy_id: value.chrome_policy_id.into(),
            chrome_app_icon_id: value.chrome_app_icon_id.into(),
            disable_signal_handlers: value.disable_signal_handlers.into(),
        }
    }
}
impl Into<_cef_settings_t> for Settings {
    fn into(self) -> _cef_settings_t {
        _cef_settings_t {
            size: self.size.into(),
            no_sandbox: self.no_sandbox.into(),
            browser_subprocess_path: self.browser_subprocess_path.into(),
            framework_dir_path: self.framework_dir_path.into(),
            main_bundle_path: self.main_bundle_path.into(),
            multi_threaded_message_loop: self.multi_threaded_message_loop.into(),
            external_message_pump: self.external_message_pump.into(),
            windowless_rendering_enabled: self.windowless_rendering_enabled.into(),
            command_line_args_disabled: self.command_line_args_disabled.into(),
            cache_path: self.cache_path.into(),
            root_cache_path: self.root_cache_path.into(),
            persist_session_cookies: self.persist_session_cookies.into(),
            user_agent: self.user_agent.into(),
            user_agent_product: self.user_agent_product.into(),
            locale: self.locale.into(),
            log_file: self.log_file.into(),
            log_severity: self.log_severity.into(),
            log_items: self.log_items.into(),
            javascript_flags: self.javascript_flags.into(),
            resources_dir_path: self.resources_dir_path.into(),
            locales_dir_path: self.locales_dir_path.into(),
            remote_debugging_port: self.remote_debugging_port.into(),
            uncaught_exception_stack_size: self.uncaught_exception_stack_size.into(),
            background_color: self.background_color.into(),
            accept_language_list: self.accept_language_list.into(),
            cookieable_schemes_list: self.cookieable_schemes_list.into(),
            cookieable_schemes_exclude_defaults: self.cookieable_schemes_exclude_defaults.into(),
            chrome_policy_id: self.chrome_policy_id.into(),
            chrome_app_icon_id: self.chrome_app_icon_id.into(),
            disable_signal_handlers: self.disable_signal_handlers.into(),
        }
    }
}
impl Default for Settings {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [_cef_request_context_settings_t] for more documentation."]
#[derive(Clone)]
pub struct RequestContextSettings {
    pub size: usize,
    pub cache_path: CefStringUtf16,
    pub persist_session_cookies: ::std::os::raw::c_int,
    pub accept_language_list: CefStringUtf16,
    pub cookieable_schemes_list: CefStringUtf16,
    pub cookieable_schemes_exclude_defaults: ::std::os::raw::c_int,
}
impl From<_cef_request_context_settings_t> for RequestContextSettings {
    fn from(value: _cef_request_context_settings_t) -> Self {
        Self {
            size: value.size.into(),
            cache_path: value.cache_path.into(),
            persist_session_cookies: value.persist_session_cookies.into(),
            accept_language_list: value.accept_language_list.into(),
            cookieable_schemes_list: value.cookieable_schemes_list.into(),
            cookieable_schemes_exclude_defaults: value.cookieable_schemes_exclude_defaults.into(),
        }
    }
}
impl Into<_cef_request_context_settings_t> for RequestContextSettings {
    fn into(self) -> _cef_request_context_settings_t {
        _cef_request_context_settings_t {
            size: self.size.into(),
            cache_path: self.cache_path.into(),
            persist_session_cookies: self.persist_session_cookies.into(),
            accept_language_list: self.accept_language_list.into(),
            cookieable_schemes_list: self.cookieable_schemes_list.into(),
            cookieable_schemes_exclude_defaults: self.cookieable_schemes_exclude_defaults.into(),
        }
    }
}
impl Default for RequestContextSettings {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [_cef_browser_settings_t] for more documentation."]
#[derive(Clone)]
pub struct BrowserSettings {
    pub size: usize,
    pub windowless_frame_rate: ::std::os::raw::c_int,
    pub standard_font_family: CefStringUtf16,
    pub fixed_font_family: CefStringUtf16,
    pub serif_font_family: CefStringUtf16,
    pub sans_serif_font_family: CefStringUtf16,
    pub cursive_font_family: CefStringUtf16,
    pub fantasy_font_family: CefStringUtf16,
    pub default_font_size: ::std::os::raw::c_int,
    pub default_fixed_font_size: ::std::os::raw::c_int,
    pub minimum_font_size: ::std::os::raw::c_int,
    pub minimum_logical_font_size: ::std::os::raw::c_int,
    pub default_encoding: CefStringUtf16,
    pub remote_fonts: State,
    pub javascript: State,
    pub javascript_close_windows: State,
    pub javascript_access_clipboard: State,
    pub javascript_dom_paste: State,
    pub image_loading: State,
    pub image_shrink_standalone_to_fit: State,
    pub text_area_resize: State,
    pub tab_to_links: State,
    pub local_storage: State,
    pub databases: State,
    pub webgl: State,
    pub background_color: u32,
    pub chrome_status_bubble: State,
    pub chrome_zoom_bubble: State,
}
impl From<_cef_browser_settings_t> for BrowserSettings {
    fn from(value: _cef_browser_settings_t) -> Self {
        Self {
            size: value.size.into(),
            windowless_frame_rate: value.windowless_frame_rate.into(),
            standard_font_family: value.standard_font_family.into(),
            fixed_font_family: value.fixed_font_family.into(),
            serif_font_family: value.serif_font_family.into(),
            sans_serif_font_family: value.sans_serif_font_family.into(),
            cursive_font_family: value.cursive_font_family.into(),
            fantasy_font_family: value.fantasy_font_family.into(),
            default_font_size: value.default_font_size.into(),
            default_fixed_font_size: value.default_fixed_font_size.into(),
            minimum_font_size: value.minimum_font_size.into(),
            minimum_logical_font_size: value.minimum_logical_font_size.into(),
            default_encoding: value.default_encoding.into(),
            remote_fonts: value.remote_fonts.into(),
            javascript: value.javascript.into(),
            javascript_close_windows: value.javascript_close_windows.into(),
            javascript_access_clipboard: value.javascript_access_clipboard.into(),
            javascript_dom_paste: value.javascript_dom_paste.into(),
            image_loading: value.image_loading.into(),
            image_shrink_standalone_to_fit: value.image_shrink_standalone_to_fit.into(),
            text_area_resize: value.text_area_resize.into(),
            tab_to_links: value.tab_to_links.into(),
            local_storage: value.local_storage.into(),
            databases: value.databases.into(),
            webgl: value.webgl.into(),
            background_color: value.background_color.into(),
            chrome_status_bubble: value.chrome_status_bubble.into(),
            chrome_zoom_bubble: value.chrome_zoom_bubble.into(),
        }
    }
}
impl Into<_cef_browser_settings_t> for BrowserSettings {
    fn into(self) -> _cef_browser_settings_t {
        _cef_browser_settings_t {
            size: self.size.into(),
            windowless_frame_rate: self.windowless_frame_rate.into(),
            standard_font_family: self.standard_font_family.into(),
            fixed_font_family: self.fixed_font_family.into(),
            serif_font_family: self.serif_font_family.into(),
            sans_serif_font_family: self.sans_serif_font_family.into(),
            cursive_font_family: self.cursive_font_family.into(),
            fantasy_font_family: self.fantasy_font_family.into(),
            default_font_size: self.default_font_size.into(),
            default_fixed_font_size: self.default_fixed_font_size.into(),
            minimum_font_size: self.minimum_font_size.into(),
            minimum_logical_font_size: self.minimum_logical_font_size.into(),
            default_encoding: self.default_encoding.into(),
            remote_fonts: self.remote_fonts.into(),
            javascript: self.javascript.into(),
            javascript_close_windows: self.javascript_close_windows.into(),
            javascript_access_clipboard: self.javascript_access_clipboard.into(),
            javascript_dom_paste: self.javascript_dom_paste.into(),
            image_loading: self.image_loading.into(),
            image_shrink_standalone_to_fit: self.image_shrink_standalone_to_fit.into(),
            text_area_resize: self.text_area_resize.into(),
            tab_to_links: self.tab_to_links.into(),
            local_storage: self.local_storage.into(),
            databases: self.databases.into(),
            webgl: self.webgl.into(),
            background_color: self.background_color.into(),
            chrome_status_bubble: self.chrome_status_bubble.into(),
            chrome_zoom_bubble: self.chrome_zoom_bubble.into(),
        }
    }
}
impl Default for BrowserSettings {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [_cef_urlparts_t] for more documentation."]
#[derive(Clone)]
pub struct Urlparts {
    pub spec: CefStringUtf16,
    pub scheme: CefStringUtf16,
    pub username: CefStringUtf16,
    pub password: CefStringUtf16,
    pub host: CefStringUtf16,
    pub port: CefStringUtf16,
    pub origin: CefStringUtf16,
    pub path: CefStringUtf16,
    pub query: CefStringUtf16,
    pub fragment: CefStringUtf16,
}
impl From<_cef_urlparts_t> for Urlparts {
    fn from(value: _cef_urlparts_t) -> Self {
        Self {
            spec: value.spec.into(),
            scheme: value.scheme.into(),
            username: value.username.into(),
            password: value.password.into(),
            host: value.host.into(),
            port: value.port.into(),
            origin: value.origin.into(),
            path: value.path.into(),
            query: value.query.into(),
            fragment: value.fragment.into(),
        }
    }
}
impl Into<_cef_urlparts_t> for Urlparts {
    fn into(self) -> _cef_urlparts_t {
        _cef_urlparts_t {
            spec: self.spec.into(),
            scheme: self.scheme.into(),
            username: self.username.into(),
            password: self.password.into(),
            host: self.host.into(),
            port: self.port.into(),
            origin: self.origin.into(),
            path: self.path.into(),
            query: self.query.into(),
            fragment: self.fragment.into(),
        }
    }
}
impl Default for Urlparts {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [_cef_cookie_t] for more documentation."]
#[derive(Clone)]
pub struct Cookie {
    pub name: CefStringUtf16,
    pub value: CefStringUtf16,
    pub domain: CefStringUtf16,
    pub path: CefStringUtf16,
    pub secure: ::std::os::raw::c_int,
    pub httponly: ::std::os::raw::c_int,
    pub creation: Basetime,
    pub last_access: Basetime,
    pub has_expires: ::std::os::raw::c_int,
    pub expires: Basetime,
    pub same_site: CookieSameSite,
    pub priority: CookiePriority,
}
impl From<_cef_cookie_t> for Cookie {
    fn from(value: _cef_cookie_t) -> Self {
        Self {
            name: value.name.into(),
            value: value.value.into(),
            domain: value.domain.into(),
            path: value.path.into(),
            secure: value.secure.into(),
            httponly: value.httponly.into(),
            creation: value.creation.into(),
            last_access: value.last_access.into(),
            has_expires: value.has_expires.into(),
            expires: value.expires.into(),
            same_site: value.same_site.into(),
            priority: value.priority.into(),
        }
    }
}
impl Into<_cef_cookie_t> for Cookie {
    fn into(self) -> _cef_cookie_t {
        _cef_cookie_t {
            name: self.name.into(),
            value: self.value.into(),
            domain: self.domain.into(),
            path: self.path.into(),
            secure: self.secure.into(),
            httponly: self.httponly.into(),
            creation: self.creation.into(),
            last_access: self.last_access.into(),
            has_expires: self.has_expires.into(),
            expires: self.expires.into(),
            same_site: self.same_site.into(),
            priority: self.priority.into(),
        }
    }
}
impl Default for Cookie {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [_cef_draggable_region_t] for more documentation."]
#[derive(Clone)]
pub struct DraggableRegion {
    pub bounds: Rect,
    pub draggable: ::std::os::raw::c_int,
}
impl From<_cef_draggable_region_t> for DraggableRegion {
    fn from(value: _cef_draggable_region_t) -> Self {
        Self {
            bounds: value.bounds.into(),
            draggable: value.draggable.into(),
        }
    }
}
impl Into<_cef_draggable_region_t> for DraggableRegion {
    fn into(self) -> _cef_draggable_region_t {
        _cef_draggable_region_t {
            bounds: self.bounds.into(),
            draggable: self.draggable.into(),
        }
    }
}
impl Default for DraggableRegion {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [_cef_screen_info_t] for more documentation."]
#[derive(Clone)]
pub struct ScreenInfo {
    pub device_scale_factor: f32,
    pub depth: ::std::os::raw::c_int,
    pub depth_per_component: ::std::os::raw::c_int,
    pub is_monochrome: ::std::os::raw::c_int,
    pub rect: Rect,
    pub available_rect: Rect,
}
impl From<_cef_screen_info_t> for ScreenInfo {
    fn from(value: _cef_screen_info_t) -> Self {
        Self {
            device_scale_factor: value.device_scale_factor.into(),
            depth: value.depth.into(),
            depth_per_component: value.depth_per_component.into(),
            is_monochrome: value.is_monochrome.into(),
            rect: value.rect.into(),
            available_rect: value.available_rect.into(),
        }
    }
}
impl Into<_cef_screen_info_t> for ScreenInfo {
    fn into(self) -> _cef_screen_info_t {
        _cef_screen_info_t {
            device_scale_factor: self.device_scale_factor.into(),
            depth: self.depth.into(),
            depth_per_component: self.depth_per_component.into(),
            is_monochrome: self.is_monochrome.into(),
            rect: self.rect.into(),
            available_rect: self.available_rect.into(),
        }
    }
}
impl Default for ScreenInfo {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [_cef_linux_window_properties_t] for more documentation."]
#[derive(Clone)]
pub struct LinuxWindowProperties {
    pub wayland_app_id: CefStringUtf16,
    pub wm_class_class: CefStringUtf16,
    pub wm_class_name: CefStringUtf16,
    pub wm_role_name: CefStringUtf16,
}
impl From<_cef_linux_window_properties_t> for LinuxWindowProperties {
    fn from(value: _cef_linux_window_properties_t) -> Self {
        Self {
            wayland_app_id: value.wayland_app_id.into(),
            wm_class_class: value.wm_class_class.into(),
            wm_class_name: value.wm_class_name.into(),
            wm_role_name: value.wm_role_name.into(),
        }
    }
}
impl Into<_cef_linux_window_properties_t> for LinuxWindowProperties {
    fn into(self) -> _cef_linux_window_properties_t {
        _cef_linux_window_properties_t {
            wayland_app_id: self.wayland_app_id.into(),
            wm_class_class: self.wm_class_class.into(),
            wm_class_name: self.wm_class_name.into(),
            wm_role_name: self.wm_role_name.into(),
        }
    }
}
impl Default for LinuxWindowProperties {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [_cef_mouse_event_t] for more documentation."]
#[derive(Clone)]
pub struct MouseEvent {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub modifiers: u32,
}
impl From<_cef_mouse_event_t> for MouseEvent {
    fn from(value: _cef_mouse_event_t) -> Self {
        Self {
            x: value.x.into(),
            y: value.y.into(),
            modifiers: value.modifiers.into(),
        }
    }
}
impl Into<_cef_mouse_event_t> for MouseEvent {
    fn into(self) -> _cef_mouse_event_t {
        _cef_mouse_event_t {
            x: self.x.into(),
            y: self.y.into(),
            modifiers: self.modifiers.into(),
        }
    }
}
impl Default for MouseEvent {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [_cef_touch_event_t] for more documentation."]
#[derive(Clone)]
pub struct TouchEvent {
    pub id: ::std::os::raw::c_int,
    pub x: f32,
    pub y: f32,
    pub radius_x: f32,
    pub radius_y: f32,
    pub rotation_angle: f32,
    pub pressure: f32,
    pub type_: TouchEventType,
    pub modifiers: u32,
    pub pointer_type: PointerType,
}
impl From<_cef_touch_event_t> for TouchEvent {
    fn from(value: _cef_touch_event_t) -> Self {
        Self {
            id: value.id.into(),
            x: value.x.into(),
            y: value.y.into(),
            radius_x: value.radius_x.into(),
            radius_y: value.radius_y.into(),
            rotation_angle: value.rotation_angle.into(),
            pressure: value.pressure.into(),
            type_: value.type_.into(),
            modifiers: value.modifiers.into(),
            pointer_type: value.pointer_type.into(),
        }
    }
}
impl Into<_cef_touch_event_t> for TouchEvent {
    fn into(self) -> _cef_touch_event_t {
        _cef_touch_event_t {
            id: self.id.into(),
            x: self.x.into(),
            y: self.y.into(),
            radius_x: self.radius_x.into(),
            radius_y: self.radius_y.into(),
            rotation_angle: self.rotation_angle.into(),
            pressure: self.pressure.into(),
            type_: self.type_.into(),
            modifiers: self.modifiers.into(),
            pointer_type: self.pointer_type.into(),
        }
    }
}
impl Default for TouchEvent {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [_cef_key_event_t] for more documentation."]
#[derive(Clone)]
pub struct KeyEvent {
    pub type_: KeyEventType,
    pub modifiers: u32,
    pub windows_key_code: ::std::os::raw::c_int,
    pub native_key_code: ::std::os::raw::c_int,
    pub is_system_key: ::std::os::raw::c_int,
    pub character: char16_t,
    pub unmodified_character: char16_t,
    pub focus_on_editable_field: ::std::os::raw::c_int,
}
impl From<_cef_key_event_t> for KeyEvent {
    fn from(value: _cef_key_event_t) -> Self {
        Self {
            type_: value.type_.into(),
            modifiers: value.modifiers.into(),
            windows_key_code: value.windows_key_code.into(),
            native_key_code: value.native_key_code.into(),
            is_system_key: value.is_system_key.into(),
            character: value.character.into(),
            unmodified_character: value.unmodified_character.into(),
            focus_on_editable_field: value.focus_on_editable_field.into(),
        }
    }
}
impl Into<_cef_key_event_t> for KeyEvent {
    fn into(self) -> _cef_key_event_t {
        _cef_key_event_t {
            type_: self.type_.into(),
            modifiers: self.modifiers.into(),
            windows_key_code: self.windows_key_code.into(),
            native_key_code: self.native_key_code.into(),
            is_system_key: self.is_system_key.into(),
            character: self.character.into(),
            unmodified_character: self.unmodified_character.into(),
            focus_on_editable_field: self.focus_on_editable_field.into(),
        }
    }
}
impl Default for KeyEvent {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [_cef_popup_features_t] for more documentation."]
#[derive(Clone)]
pub struct PopupFeatures {
    pub x: ::std::os::raw::c_int,
    pub x_set: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub y_set: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub width_set: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub height_set: ::std::os::raw::c_int,
    pub is_popup: ::std::os::raw::c_int,
}
impl From<_cef_popup_features_t> for PopupFeatures {
    fn from(value: _cef_popup_features_t) -> Self {
        Self {
            x: value.x.into(),
            x_set: value.xSet.into(),
            y: value.y.into(),
            y_set: value.ySet.into(),
            width: value.width.into(),
            width_set: value.widthSet.into(),
            height: value.height.into(),
            height_set: value.heightSet.into(),
            is_popup: value.isPopup.into(),
        }
    }
}
impl Into<_cef_popup_features_t> for PopupFeatures {
    fn into(self) -> _cef_popup_features_t {
        _cef_popup_features_t {
            x: self.x.into(),
            xSet: self.x_set.into(),
            y: self.y.into(),
            ySet: self.y_set.into(),
            width: self.width.into(),
            widthSet: self.width_set.into(),
            height: self.height.into(),
            heightSet: self.height_set.into(),
            isPopup: self.is_popup.into(),
        }
    }
}
impl Default for PopupFeatures {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [_cef_cursor_info_t] for more documentation."]
#[derive(Clone)]
pub struct CursorInfo {
    pub hotspot: Point,
    pub image_scale_factor: f32,
    pub buffer: *mut ::std::os::raw::c_void,
    pub size: Size,
}
impl From<_cef_cursor_info_t> for CursorInfo {
    fn from(value: _cef_cursor_info_t) -> Self {
        Self {
            hotspot: value.hotspot.into(),
            image_scale_factor: value.image_scale_factor.into(),
            buffer: value.buffer.into(),
            size: value.size.into(),
        }
    }
}
impl Into<_cef_cursor_info_t> for CursorInfo {
    fn into(self) -> _cef_cursor_info_t {
        _cef_cursor_info_t {
            hotspot: self.hotspot.into(),
            image_scale_factor: self.image_scale_factor.into(),
            buffer: self.buffer.into(),
            size: self.size.into(),
        }
    }
}
impl Default for CursorInfo {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [_cef_pdf_print_settings_t] for more documentation."]
#[derive(Clone)]
pub struct PdfPrintSettings {
    pub landscape: ::std::os::raw::c_int,
    pub print_background: ::std::os::raw::c_int,
    pub scale: f64,
    pub paper_width: f64,
    pub paper_height: f64,
    pub prefer_css_page_size: ::std::os::raw::c_int,
    pub margin_type: PdfPrintMarginType,
    pub margin_top: f64,
    pub margin_right: f64,
    pub margin_bottom: f64,
    pub margin_left: f64,
    pub page_ranges: CefStringUtf16,
    pub display_header_footer: ::std::os::raw::c_int,
    pub header_template: CefStringUtf16,
    pub footer_template: CefStringUtf16,
    pub generate_tagged_pdf: ::std::os::raw::c_int,
    pub generate_document_outline: ::std::os::raw::c_int,
}
impl From<_cef_pdf_print_settings_t> for PdfPrintSettings {
    fn from(value: _cef_pdf_print_settings_t) -> Self {
        Self {
            landscape: value.landscape.into(),
            print_background: value.print_background.into(),
            scale: value.scale.into(),
            paper_width: value.paper_width.into(),
            paper_height: value.paper_height.into(),
            prefer_css_page_size: value.prefer_css_page_size.into(),
            margin_type: value.margin_type.into(),
            margin_top: value.margin_top.into(),
            margin_right: value.margin_right.into(),
            margin_bottom: value.margin_bottom.into(),
            margin_left: value.margin_left.into(),
            page_ranges: value.page_ranges.into(),
            display_header_footer: value.display_header_footer.into(),
            header_template: value.header_template.into(),
            footer_template: value.footer_template.into(),
            generate_tagged_pdf: value.generate_tagged_pdf.into(),
            generate_document_outline: value.generate_document_outline.into(),
        }
    }
}
impl Into<_cef_pdf_print_settings_t> for PdfPrintSettings {
    fn into(self) -> _cef_pdf_print_settings_t {
        _cef_pdf_print_settings_t {
            landscape: self.landscape.into(),
            print_background: self.print_background.into(),
            scale: self.scale.into(),
            paper_width: self.paper_width.into(),
            paper_height: self.paper_height.into(),
            prefer_css_page_size: self.prefer_css_page_size.into(),
            margin_type: self.margin_type.into(),
            margin_top: self.margin_top.into(),
            margin_right: self.margin_right.into(),
            margin_bottom: self.margin_bottom.into(),
            margin_left: self.margin_left.into(),
            page_ranges: self.page_ranges.into(),
            display_header_footer: self.display_header_footer.into(),
            header_template: self.header_template.into(),
            footer_template: self.footer_template.into(),
            generate_tagged_pdf: self.generate_tagged_pdf.into(),
            generate_document_outline: self.generate_document_outline.into(),
        }
    }
}
impl Default for PdfPrintSettings {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [_cef_box_layout_settings_t] for more documentation."]
#[derive(Clone)]
pub struct BoxLayoutSettings {
    pub horizontal: ::std::os::raw::c_int,
    pub inside_border_horizontal_spacing: ::std::os::raw::c_int,
    pub inside_border_vertical_spacing: ::std::os::raw::c_int,
    pub inside_border_insets: Insets,
    pub between_child_spacing: ::std::os::raw::c_int,
    pub main_axis_alignment: AxisAlignment,
    pub cross_axis_alignment: AxisAlignment,
    pub minimum_cross_axis_size: ::std::os::raw::c_int,
    pub default_flex: ::std::os::raw::c_int,
}
impl From<_cef_box_layout_settings_t> for BoxLayoutSettings {
    fn from(value: _cef_box_layout_settings_t) -> Self {
        Self {
            horizontal: value.horizontal.into(),
            inside_border_horizontal_spacing: value.inside_border_horizontal_spacing.into(),
            inside_border_vertical_spacing: value.inside_border_vertical_spacing.into(),
            inside_border_insets: value.inside_border_insets.into(),
            between_child_spacing: value.between_child_spacing.into(),
            main_axis_alignment: value.main_axis_alignment.into(),
            cross_axis_alignment: value.cross_axis_alignment.into(),
            minimum_cross_axis_size: value.minimum_cross_axis_size.into(),
            default_flex: value.default_flex.into(),
        }
    }
}
impl Into<_cef_box_layout_settings_t> for BoxLayoutSettings {
    fn into(self) -> _cef_box_layout_settings_t {
        _cef_box_layout_settings_t {
            horizontal: self.horizontal.into(),
            inside_border_horizontal_spacing: self.inside_border_horizontal_spacing.into(),
            inside_border_vertical_spacing: self.inside_border_vertical_spacing.into(),
            inside_border_insets: self.inside_border_insets.into(),
            between_child_spacing: self.between_child_spacing.into(),
            main_axis_alignment: self.main_axis_alignment.into(),
            cross_axis_alignment: self.cross_axis_alignment.into(),
            minimum_cross_axis_size: self.minimum_cross_axis_size.into(),
            default_flex: self.default_flex.into(),
        }
    }
}
impl Default for BoxLayoutSettings {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [_cef_range_t] for more documentation."]
#[derive(Clone)]
pub struct Range {
    pub from: u32,
    pub to: u32,
}
impl From<_cef_range_t> for Range {
    fn from(value: _cef_range_t) -> Self {
        Self {
            from: value.from.into(),
            to: value.to.into(),
        }
    }
}
impl Into<_cef_range_t> for Range {
    fn into(self) -> _cef_range_t {
        _cef_range_t {
            from: self.from.into(),
            to: self.to.into(),
        }
    }
}
impl Default for Range {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [_cef_composition_underline_t] for more documentation."]
#[derive(Clone)]
pub struct CompositionUnderline {
    pub range: Range,
    pub color: u32,
    pub background_color: u32,
    pub thick: ::std::os::raw::c_int,
    pub style: CompositionUnderlineStyle,
}
impl From<_cef_composition_underline_t> for CompositionUnderline {
    fn from(value: _cef_composition_underline_t) -> Self {
        Self {
            range: value.range.into(),
            color: value.color.into(),
            background_color: value.background_color.into(),
            thick: value.thick.into(),
            style: value.style.into(),
        }
    }
}
impl Into<_cef_composition_underline_t> for CompositionUnderline {
    fn into(self) -> _cef_composition_underline_t {
        _cef_composition_underline_t {
            range: self.range.into(),
            color: self.color.into(),
            background_color: self.background_color.into(),
            thick: self.thick.into(),
            style: self.style.into(),
        }
    }
}
impl Default for CompositionUnderline {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [_cef_audio_parameters_t] for more documentation."]
#[derive(Clone)]
pub struct AudioParameters {
    pub channel_layout: ChannelLayout,
    pub sample_rate: ::std::os::raw::c_int,
    pub frames_per_buffer: ::std::os::raw::c_int,
}
impl From<_cef_audio_parameters_t> for AudioParameters {
    fn from(value: _cef_audio_parameters_t) -> Self {
        Self {
            channel_layout: value.channel_layout.into(),
            sample_rate: value.sample_rate.into(),
            frames_per_buffer: value.frames_per_buffer.into(),
        }
    }
}
impl Into<_cef_audio_parameters_t> for AudioParameters {
    fn into(self) -> _cef_audio_parameters_t {
        _cef_audio_parameters_t {
            channel_layout: self.channel_layout.into(),
            sample_rate: self.sample_rate.into(),
            frames_per_buffer: self.frames_per_buffer.into(),
        }
    }
}
impl Default for AudioParameters {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [_cef_media_sink_device_info_t] for more documentation."]
#[derive(Clone)]
pub struct MediaSinkDeviceInfo {
    pub ip_address: CefStringUtf16,
    pub port: ::std::os::raw::c_int,
    pub model_name: CefStringUtf16,
}
impl From<_cef_media_sink_device_info_t> for MediaSinkDeviceInfo {
    fn from(value: _cef_media_sink_device_info_t) -> Self {
        Self {
            ip_address: value.ip_address.into(),
            port: value.port.into(),
            model_name: value.model_name.into(),
        }
    }
}
impl Into<_cef_media_sink_device_info_t> for MediaSinkDeviceInfo {
    fn into(self) -> _cef_media_sink_device_info_t {
        _cef_media_sink_device_info_t {
            ip_address: self.ip_address.into(),
            port: self.port.into(),
            model_name: self.model_name.into(),
        }
    }
}
impl Default for MediaSinkDeviceInfo {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [_cef_touch_handle_state_t] for more documentation."]
#[derive(Clone)]
pub struct TouchHandleState {
    pub touch_handle_id: ::std::os::raw::c_int,
    pub flags: u32,
    pub enabled: ::std::os::raw::c_int,
    pub orientation: HorizontalAlignment,
    pub mirror_vertical: ::std::os::raw::c_int,
    pub mirror_horizontal: ::std::os::raw::c_int,
    pub origin: Point,
    pub alpha: f32,
}
impl From<_cef_touch_handle_state_t> for TouchHandleState {
    fn from(value: _cef_touch_handle_state_t) -> Self {
        Self {
            touch_handle_id: value.touch_handle_id.into(),
            flags: value.flags.into(),
            enabled: value.enabled.into(),
            orientation: value.orientation.into(),
            mirror_vertical: value.mirror_vertical.into(),
            mirror_horizontal: value.mirror_horizontal.into(),
            origin: value.origin.into(),
            alpha: value.alpha.into(),
        }
    }
}
impl Into<_cef_touch_handle_state_t> for TouchHandleState {
    fn into(self) -> _cef_touch_handle_state_t {
        _cef_touch_handle_state_t {
            touch_handle_id: self.touch_handle_id.into(),
            flags: self.flags.into(),
            enabled: self.enabled.into(),
            orientation: self.orientation.into(),
            mirror_vertical: self.mirror_vertical.into(),
            mirror_horizontal: self.mirror_horizontal.into(),
            origin: self.origin.into(),
            alpha: self.alpha.into(),
        }
    }
}
impl Default for TouchHandleState {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [_cef_task_info_t] for more documentation."]
#[derive(Clone)]
pub struct TaskInfo {
    pub id: i64,
    pub type_: TaskType,
    pub is_killable: ::std::os::raw::c_int,
    pub title: CefStringUtf16,
    pub cpu_usage: f64,
    pub number_of_processors: ::std::os::raw::c_int,
    pub memory: i64,
    pub gpu_memory: i64,
    pub is_gpu_memory_inflated: ::std::os::raw::c_int,
}
impl From<_cef_task_info_t> for TaskInfo {
    fn from(value: _cef_task_info_t) -> Self {
        Self {
            id: value.id.into(),
            type_: value.type_.into(),
            is_killable: value.is_killable.into(),
            title: value.title.into(),
            cpu_usage: value.cpu_usage.into(),
            number_of_processors: value.number_of_processors.into(),
            memory: value.memory.into(),
            gpu_memory: value.gpu_memory.into(),
            is_gpu_memory_inflated: value.is_gpu_memory_inflated.into(),
        }
    }
}
impl Into<_cef_task_info_t> for TaskInfo {
    fn into(self) -> _cef_task_info_t {
        _cef_task_info_t {
            id: self.id.into(),
            type_: self.type_.into(),
            is_killable: self.is_killable.into(),
            title: self.title.into(),
            cpu_usage: self.cpu_usage.into(),
            number_of_processors: self.number_of_processors.into(),
            memory: self.memory.into(),
            gpu_memory: self.gpu_memory.into(),
            is_gpu_memory_inflated: self.is_gpu_memory_inflated.into(),
        }
    }
}
impl Default for TaskInfo {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [_cef_base_ref_counted_t] for more documentation."]
#[repr(transparent)]
pub struct BaseRefCounted(_cef_base_ref_counted_t);
impl From<_cef_base_ref_counted_t> for BaseRefCounted {
    fn from(value: _cef_base_ref_counted_t) -> Self {
        Self(value)
    }
}
impl Into<*const _cef_base_ref_counted_t> for &BaseRefCounted {
    fn into(self) -> *const _cef_base_ref_counted_t {
        self.as_ref() as *const _cef_base_ref_counted_t
    }
}
impl Into<*mut _cef_base_ref_counted_t> for &mut BaseRefCounted {
    fn into(self) -> *mut _cef_base_ref_counted_t {
        self.as_mut() as *mut _cef_base_ref_counted_t
    }
}
impl Into<_cef_base_ref_counted_t> for BaseRefCounted {
    fn into(self) -> _cef_base_ref_counted_t {
        self.0
    }
}
impl AsRef<_cef_base_ref_counted_t> for BaseRefCounted {
    fn as_ref(&self) -> &_cef_base_ref_counted_t {
        &self.0
    }
}
impl AsMut<_cef_base_ref_counted_t> for BaseRefCounted {
    fn as_mut(&mut self) -> &mut _cef_base_ref_counted_t {
        &mut self.0
    }
}
impl Default for BaseRefCounted {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [_cef_base_scoped_t] for more documentation."]
#[repr(transparent)]
pub struct BaseScoped(_cef_base_scoped_t);
impl From<_cef_base_scoped_t> for BaseScoped {
    fn from(value: _cef_base_scoped_t) -> Self {
        Self(value)
    }
}
impl Into<*const _cef_base_scoped_t> for &BaseScoped {
    fn into(self) -> *const _cef_base_scoped_t {
        self.as_ref() as *const _cef_base_scoped_t
    }
}
impl Into<*mut _cef_base_scoped_t> for &mut BaseScoped {
    fn into(self) -> *mut _cef_base_scoped_t {
        self.as_mut() as *mut _cef_base_scoped_t
    }
}
impl Into<_cef_base_scoped_t> for BaseScoped {
    fn into(self) -> _cef_base_scoped_t {
        self.0
    }
}
impl AsRef<_cef_base_scoped_t> for BaseScoped {
    fn as_ref(&self) -> &_cef_base_scoped_t {
        &self.0
    }
}
impl AsMut<_cef_base_scoped_t> for BaseScoped {
    fn as_mut(&mut self) -> &mut _cef_base_scoped_t {
        &mut self.0
    }
}
impl Default for BaseScoped {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplDevToolsMessageObserver: Sized {
    fn on_dev_tools_message<'a>(
        &self,
        browser: &'a mut Browser,
        message: Option<&'a [u8]>,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn on_dev_tools_method_result<'a>(
        &self,
        browser: &'a mut Browser,
        message_id: ::std::os::raw::c_int,
        success: ::std::os::raw::c_int,
        result: Option<&'a [u8]>,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn on_dev_tools_event<'a>(
        &self,
        browser: &'a mut Browser,
        method: &'a CefStringUtf16,
        params: Option<&'a [u8]>,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn on_dev_tools_agent_attached<'a>(&self, browser: &'a mut Browser) {
        unsafe { std::mem::zeroed() }
    }
    fn on_dev_tools_agent_detached<'a>(&self, browser: &'a mut Browser) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_dev_tools_message_observer_t {
        let mut object: _cef_dev_tools_message_observer_t = unsafe { std::mem::zeroed() };
        impl_cef_dev_tools_message_observer_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_dev_tools_message_observer_t {
    use super::*;
    pub fn init_methods<I: ImplDevToolsMessageObserver>(
        object: &mut _cef_dev_tools_message_observer_t,
    ) {
        object.on_dev_tools_message = Some(on_dev_tools_message::<I>);
        object.on_dev_tools_method_result = Some(on_dev_tools_method_result::<I>);
        object.on_dev_tools_event = Some(on_dev_tools_event::<I>);
        object.on_dev_tools_agent_attached = Some(on_dev_tools_agent_attached::<I>);
        object.on_dev_tools_agent_detached = Some(on_dev_tools_agent_detached::<I>);
    }
    extern "C" fn on_dev_tools_message<I: ImplDevToolsMessageObserver>(
        self_: *mut _cef_dev_tools_message_observer_t,
        browser: *mut _cef_browser_t,
        message: *const ::std::os::raw::c_void,
        message_size: usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_message, arg_message_size) =
            (self_, browser, message, message_size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_message = (!arg_message.is_null() && arg_message_size > 0).then(|| unsafe {
            std::slice::from_raw_parts(arg_message as *const _, arg_message_size)
        });
        arg_self_
            .interface
            .on_dev_tools_message(arg_browser, arg_message)
            .into()
    }
    extern "C" fn on_dev_tools_method_result<I: ImplDevToolsMessageObserver>(
        self_: *mut _cef_dev_tools_message_observer_t,
        browser: *mut _cef_browser_t,
        message_id: ::std::os::raw::c_int,
        success: ::std::os::raw::c_int,
        result: *const ::std::os::raw::c_void,
        result_size: usize,
    ) {
        let (arg_self_, arg_browser, arg_message_id, arg_success, arg_result, arg_result_size) =
            (self_, browser, message_id, success, result, result_size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_message_id = arg_message_id.as_raw();
        let arg_success = arg_success.as_raw();
        let arg_result = (!arg_result.is_null() && arg_result_size > 0).then(|| unsafe {
            std::slice::from_raw_parts(arg_result as *const _, arg_result_size)
        });
        arg_self_.interface.on_dev_tools_method_result(
            arg_browser,
            arg_message_id,
            arg_success,
            arg_result,
        )
    }
    extern "C" fn on_dev_tools_event<I: ImplDevToolsMessageObserver>(
        self_: *mut _cef_dev_tools_message_observer_t,
        browser: *mut _cef_browser_t,
        method: *const _cef_string_utf16_t,
        params: *const ::std::os::raw::c_void,
        params_size: usize,
    ) {
        let (arg_self_, arg_browser, arg_method, arg_params, arg_params_size) =
            (self_, browser, method, params, params_size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_method = WrapParamRef::<CefStringUtf16>::from(arg_method);
        let arg_method = arg_method.as_ref();
        let arg_params = (!arg_params.is_null() && arg_params_size > 0).then(|| unsafe {
            std::slice::from_raw_parts(arg_params as *const _, arg_params_size)
        });
        arg_self_
            .interface
            .on_dev_tools_event(arg_browser, arg_method, arg_params)
    }
    extern "C" fn on_dev_tools_agent_attached<I: ImplDevToolsMessageObserver>(
        self_: *mut _cef_dev_tools_message_observer_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        arg_self_.interface.on_dev_tools_agent_attached(arg_browser)
    }
    extern "C" fn on_dev_tools_agent_detached<I: ImplDevToolsMessageObserver>(
        self_: *mut _cef_dev_tools_message_observer_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        arg_self_.interface.on_dev_tools_agent_detached(arg_browser)
    }
}
#[doc = "See [_cef_dev_tools_message_observer_t] for more documentation."]
#[derive(Clone)]
pub struct DevToolsMessageObserver(RefGuard<_cef_dev_tools_message_observer_t>);
impl ImplDevToolsMessageObserver for DevToolsMessageObserver {
    fn on_dev_tools_message<'a>(
        &self,
        browser: &'a mut Browser,
        message: Option<&'a [u8]>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_dev_tools_message
                .map(|f| {
                    let (arg_browser, arg_message) = (browser, message);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_message_size = arg_message.map(|slice| slice.len()).unwrap_or_default();
                    let out_message = arg_message;
                    let arg_message = arg_message
                        .and_then(|slice| {
                            if slice.is_empty() {
                                None
                            } else {
                                Some(slice.as_ptr() as *const _)
                            }
                        })
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_browser, arg_message, arg_message_size);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_dev_tools_method_result<'a>(
        &self,
        browser: &'a mut Browser,
        message_id: ::std::os::raw::c_int,
        success: ::std::os::raw::c_int,
        result: Option<&'a [u8]>,
    ) {
        unsafe {
            self.0
                .on_dev_tools_method_result
                .map(|f| {
                    let (arg_browser, arg_message_id, arg_success, arg_result) =
                        (browser, message_id, success, result);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_message_id = arg_message_id;
                    let arg_success = arg_success;
                    let arg_result_size = arg_result.map(|slice| slice.len()).unwrap_or_default();
                    let out_result = arg_result;
                    let arg_result = arg_result
                        .and_then(|slice| {
                            if slice.is_empty() {
                                None
                            } else {
                                Some(slice.as_ptr() as *const _)
                            }
                        })
                        .unwrap_or(std::ptr::null());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_message_id,
                        arg_success,
                        arg_result,
                        arg_result_size,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_dev_tools_event<'a>(
        &self,
        browser: &'a mut Browser,
        method: &'a CefStringUtf16,
        params: Option<&'a [u8]>,
    ) {
        unsafe {
            self.0
                .on_dev_tools_event
                .map(|f| {
                    let (arg_browser, arg_method, arg_params) = (browser, method, params);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_method = arg_method.as_raw();
                    let arg_params_size = arg_params.map(|slice| slice.len()).unwrap_or_default();
                    let out_params = arg_params;
                    let arg_params = arg_params
                        .and_then(|slice| {
                            if slice.is_empty() {
                                None
                            } else {
                                Some(slice.as_ptr() as *const _)
                            }
                        })
                        .unwrap_or(std::ptr::null());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_method,
                        arg_params,
                        arg_params_size,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_dev_tools_agent_attached<'a>(&self, browser: &'a mut Browser) {
        unsafe {
            self.0
                .on_dev_tools_agent_attached
                .map(|f| {
                    let arg_browser = browser;
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let result = f(arg_self_, arg_browser);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_dev_tools_agent_detached<'a>(&self, browser: &'a mut Browser) {
        unsafe {
            self.0
                .on_dev_tools_agent_detached
                .map(|f| {
                    let arg_browser = browser;
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let result = f(arg_self_, arg_browser);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_dev_tools_message_observer_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for DevToolsMessageObserver {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_dev_tools_message_observer_t> for &DevToolsMessageObserver {
    fn as_raw(self) -> *mut _cef_dev_tools_message_observer_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_dev_tools_message_observer_t> for &mut DevToolsMessageObserver {
    fn as_raw(self) -> *mut _cef_dev_tools_message_observer_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<DevToolsMessageObserver> for *mut _cef_dev_tools_message_observer_t {
    fn as_wrapper(self) -> DevToolsMessageObserver {
        DevToolsMessageObserver(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_dev_tools_message_observer_t> for DevToolsMessageObserver {
    fn into(self) -> *mut _cef_dev_tools_message_observer_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for DevToolsMessageObserver {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplValue: Sized {
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_owned<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_read_only<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_same<'a>(&self, that: &'a mut Value) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_equal<'a>(&self, that: &'a mut Value) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn copy<'a>(&self) -> Value {
        unsafe { std::mem::zeroed() }
    }
    fn get_type<'a>(&self) -> ValueType {
        unsafe { std::mem::zeroed() }
    }
    fn get_bool<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_int<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_double<'a>(&self) -> f64 {
        unsafe { std::mem::zeroed() }
    }
    fn get_string<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_binary<'a>(&self) -> BinaryValue {
        unsafe { std::mem::zeroed() }
    }
    fn get_dictionary<'a>(&self) -> DictionaryValue {
        unsafe { std::mem::zeroed() }
    }
    fn get_list<'a>(&self) -> ListValue {
        unsafe { std::mem::zeroed() }
    }
    fn set_null<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_bool<'a>(&self, value: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_int<'a>(&self, value: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_double<'a>(&self, value: f64) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_string<'a>(&self, value: &'a CefStringUtf16) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_binary<'a>(&self, value: &'a mut BinaryValue) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_dictionary<'a>(&self, value: &'a mut DictionaryValue) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_list<'a>(&self, value: &'a mut ListValue) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_value_t {
        let mut object: _cef_value_t = unsafe { std::mem::zeroed() };
        impl_cef_value_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_value_t {
    use super::*;
    pub fn init_methods<I: ImplValue>(object: &mut _cef_value_t) {
        object.is_valid = Some(is_valid::<I>);
        object.is_owned = Some(is_owned::<I>);
        object.is_read_only = Some(is_read_only::<I>);
        object.is_same = Some(is_same::<I>);
        object.is_equal = Some(is_equal::<I>);
        object.copy = Some(copy::<I>);
        object.get_type = Some(get_type::<I>);
        object.get_bool = Some(get_bool::<I>);
        object.get_int = Some(get_int::<I>);
        object.get_double = Some(get_double::<I>);
        object.get_string = Some(get_string::<I>);
        object.get_binary = Some(get_binary::<I>);
        object.get_dictionary = Some(get_dictionary::<I>);
        object.get_list = Some(get_list::<I>);
        object.set_null = Some(set_null::<I>);
        object.set_bool = Some(set_bool::<I>);
        object.set_int = Some(set_int::<I>);
        object.set_double = Some(set_double::<I>);
        object.set_string = Some(set_string::<I>);
        object.set_binary = Some(set_binary::<I>);
        object.set_dictionary = Some(set_dictionary::<I>);
        object.set_list = Some(set_list::<I>);
    }
    extern "C" fn is_valid<I: ImplValue>(self_: *mut _cef_value_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_valid().into()
    }
    extern "C" fn is_owned<I: ImplValue>(self_: *mut _cef_value_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_owned().into()
    }
    extern "C" fn is_read_only<I: ImplValue>(self_: *mut _cef_value_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_read_only().into()
    }
    extern "C" fn is_same<I: ImplValue>(
        self_: *mut _cef_value_t,
        that: *mut _cef_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_that) = (self_, that);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_that = &mut Value(unsafe { RefGuard::from_raw_add_ref(arg_that) });
        arg_self_.interface.is_same(arg_that).into()
    }
    extern "C" fn is_equal<I: ImplValue>(
        self_: *mut _cef_value_t,
        that: *mut _cef_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_that) = (self_, that);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_that = &mut Value(unsafe { RefGuard::from_raw_add_ref(arg_that) });
        arg_self_.interface.is_equal(arg_that).into()
    }
    extern "C" fn copy<I: ImplValue>(self_: *mut _cef_value_t) -> *mut _cef_value_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.copy().into()
    }
    extern "C" fn get_type<I: ImplValue>(self_: *mut _cef_value_t) -> cef_value_type_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_type().into()
    }
    extern "C" fn get_bool<I: ImplValue>(self_: *mut _cef_value_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_bool().into()
    }
    extern "C" fn get_int<I: ImplValue>(self_: *mut _cef_value_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_int().into()
    }
    extern "C" fn get_double<I: ImplValue>(self_: *mut _cef_value_t) -> f64 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_double().into()
    }
    extern "C" fn get_string<I: ImplValue>(self_: *mut _cef_value_t) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_string().into()
    }
    extern "C" fn get_binary<I: ImplValue>(self_: *mut _cef_value_t) -> *mut _cef_binary_value_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_binary().into()
    }
    extern "C" fn get_dictionary<I: ImplValue>(
        self_: *mut _cef_value_t,
    ) -> *mut _cef_dictionary_value_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_dictionary().into()
    }
    extern "C" fn get_list<I: ImplValue>(self_: *mut _cef_value_t) -> *mut _cef_list_value_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_list().into()
    }
    extern "C" fn set_null<I: ImplValue>(self_: *mut _cef_value_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.set_null().into()
    }
    extern "C" fn set_bool<I: ImplValue>(
        self_: *mut _cef_value_t,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_value) = (self_, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_value = arg_value.as_raw();
        arg_self_.interface.set_bool(arg_value).into()
    }
    extern "C" fn set_int<I: ImplValue>(
        self_: *mut _cef_value_t,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_value) = (self_, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_value = arg_value.as_raw();
        arg_self_.interface.set_int(arg_value).into()
    }
    extern "C" fn set_double<I: ImplValue>(
        self_: *mut _cef_value_t,
        value: f64,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_value) = (self_, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_value = arg_value.as_raw();
        arg_self_.interface.set_double(arg_value).into()
    }
    extern "C" fn set_string<I: ImplValue>(
        self_: *mut _cef_value_t,
        value: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_value) = (self_, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_value = WrapParamRef::<CefStringUtf16>::from(arg_value);
        let arg_value = arg_value.as_ref();
        arg_self_.interface.set_string(arg_value).into()
    }
    extern "C" fn set_binary<I: ImplValue>(
        self_: *mut _cef_value_t,
        value: *mut _cef_binary_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_value) = (self_, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_value = &mut BinaryValue(unsafe { RefGuard::from_raw_add_ref(arg_value) });
        arg_self_.interface.set_binary(arg_value).into()
    }
    extern "C" fn set_dictionary<I: ImplValue>(
        self_: *mut _cef_value_t,
        value: *mut _cef_dictionary_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_value) = (self_, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_value = &mut DictionaryValue(unsafe { RefGuard::from_raw_add_ref(arg_value) });
        arg_self_.interface.set_dictionary(arg_value).into()
    }
    extern "C" fn set_list<I: ImplValue>(
        self_: *mut _cef_value_t,
        value: *mut _cef_list_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_value) = (self_, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_value = &mut ListValue(unsafe { RefGuard::from_raw_add_ref(arg_value) });
        arg_self_.interface.set_list(arg_value).into()
    }
}
#[doc = "See [_cef_value_t] for more documentation."]
#[derive(Clone)]
pub struct Value(RefGuard<_cef_value_t>);
impl ImplValue for Value {
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_owned<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_owned
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_read_only<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_read_only
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_same<'a>(&self, that: &'a mut Value) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_same
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.as_raw();
                    let arg_that = arg_that.as_raw();
                    let result = f(arg_self_, arg_that);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_equal<'a>(&self, that: &'a mut Value) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_equal
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.as_raw();
                    let arg_that = arg_that.as_raw();
                    let result = f(arg_self_, arg_that);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn copy<'a>(&self) -> Value {
        unsafe {
            self.0
                .copy
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_type<'a>(&self) -> ValueType {
        unsafe {
            self.0
                .get_type
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_bool<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_bool
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_int<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_int
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_double<'a>(&self) -> f64 {
        unsafe {
            self.0
                .get_double
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_string<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_string
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_binary<'a>(&self) -> BinaryValue {
        unsafe {
            self.0
                .get_binary
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_dictionary<'a>(&self) -> DictionaryValue {
        unsafe {
            self.0
                .get_dictionary
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_list<'a>(&self) -> ListValue {
        unsafe {
            self.0
                .get_list
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_null<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_null
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_bool<'a>(&self, value: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_bool
                .map(|f| {
                    let arg_value = value;
                    let arg_self_ = self.as_raw();
                    let arg_value = arg_value;
                    let result = f(arg_self_, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_int<'a>(&self, value: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_int
                .map(|f| {
                    let arg_value = value;
                    let arg_self_ = self.as_raw();
                    let arg_value = arg_value;
                    let result = f(arg_self_, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_double<'a>(&self, value: f64) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_double
                .map(|f| {
                    let arg_value = value;
                    let arg_self_ = self.as_raw();
                    let arg_value = arg_value;
                    let result = f(arg_self_, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_string<'a>(&self, value: &'a CefStringUtf16) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_string
                .map(|f| {
                    let arg_value = value;
                    let arg_self_ = self.as_raw();
                    let arg_value = arg_value.as_raw();
                    let result = f(arg_self_, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_binary<'a>(&self, value: &'a mut BinaryValue) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_binary
                .map(|f| {
                    let arg_value = value;
                    let arg_self_ = self.as_raw();
                    let arg_value = arg_value.as_raw();
                    let result = f(arg_self_, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_dictionary<'a>(&self, value: &'a mut DictionaryValue) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_dictionary
                .map(|f| {
                    let arg_value = value;
                    let arg_self_ = self.as_raw();
                    let arg_value = arg_value.as_raw();
                    let result = f(arg_self_, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_list<'a>(&self, value: &'a mut ListValue) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_list
                .map(|f| {
                    let arg_value = value;
                    let arg_self_ = self.as_raw();
                    let arg_value = arg_value.as_raw();
                    let result = f(arg_self_, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_value_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Value {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_value_t> for &Value {
    fn as_raw(self) -> *mut _cef_value_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_value_t> for &mut Value {
    fn as_raw(self) -> *mut _cef_value_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<Value> for *mut _cef_value_t {
    fn as_wrapper(self) -> Value {
        Value(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_value_t> for Value {
    fn into(self) -> *mut _cef_value_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for Value {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplBinaryValue: Sized {
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_owned<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_same<'a>(&self, that: &'a mut BinaryValue) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_equal<'a>(&self, that: &'a mut BinaryValue) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn copy<'a>(&self) -> BinaryValue {
        unsafe { std::mem::zeroed() }
    }
    fn get_raw_data<'a>(&self) -> *const ::std::os::raw::c_void {
        unsafe { std::mem::zeroed() }
    }
    fn get_size<'a>(&self) -> usize {
        unsafe { std::mem::zeroed() }
    }
    fn get_data<'a>(&self, buffer: Option<&'a mut &'a mut [u8]>, data_offset: usize) -> usize {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_binary_value_t {
        let mut object: _cef_binary_value_t = unsafe { std::mem::zeroed() };
        impl_cef_binary_value_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_binary_value_t {
    use super::*;
    pub fn init_methods<I: ImplBinaryValue>(object: &mut _cef_binary_value_t) {
        object.is_valid = Some(is_valid::<I>);
        object.is_owned = Some(is_owned::<I>);
        object.is_same = Some(is_same::<I>);
        object.is_equal = Some(is_equal::<I>);
        object.copy = Some(copy::<I>);
        object.get_raw_data = Some(get_raw_data::<I>);
        object.get_size = Some(get_size::<I>);
        object.get_data = Some(get_data::<I>);
    }
    extern "C" fn is_valid<I: ImplBinaryValue>(
        self_: *mut _cef_binary_value_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_valid().into()
    }
    extern "C" fn is_owned<I: ImplBinaryValue>(
        self_: *mut _cef_binary_value_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_owned().into()
    }
    extern "C" fn is_same<I: ImplBinaryValue>(
        self_: *mut _cef_binary_value_t,
        that: *mut _cef_binary_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_that) = (self_, that);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_that = &mut BinaryValue(unsafe { RefGuard::from_raw_add_ref(arg_that) });
        arg_self_.interface.is_same(arg_that).into()
    }
    extern "C" fn is_equal<I: ImplBinaryValue>(
        self_: *mut _cef_binary_value_t,
        that: *mut _cef_binary_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_that) = (self_, that);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_that = &mut BinaryValue(unsafe { RefGuard::from_raw_add_ref(arg_that) });
        arg_self_.interface.is_equal(arg_that).into()
    }
    extern "C" fn copy<I: ImplBinaryValue>(
        self_: *mut _cef_binary_value_t,
    ) -> *mut _cef_binary_value_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.copy().into()
    }
    extern "C" fn get_raw_data<I: ImplBinaryValue>(
        self_: *mut _cef_binary_value_t,
    ) -> *const ::std::os::raw::c_void {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_raw_data().into()
    }
    extern "C" fn get_size<I: ImplBinaryValue>(self_: *mut _cef_binary_value_t) -> usize {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_size().into()
    }
    extern "C" fn get_data<I: ImplBinaryValue>(
        self_: *mut _cef_binary_value_t,
        buffer: *mut ::std::os::raw::c_void,
        buffer_size: usize,
        data_offset: usize,
    ) -> usize {
        let (arg_self_, arg_buffer, arg_buffer_size, arg_data_offset) =
            (self_, buffer, buffer_size, data_offset);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut out_buffer = (!arg_buffer.is_null() && arg_buffer_size > 0).then(|| unsafe {
            std::slice::from_raw_parts_mut(arg_buffer as *mut _, arg_buffer_size)
        });
        let arg_buffer = out_buffer.as_mut();
        let arg_data_offset = arg_data_offset.as_raw();
        arg_self_
            .interface
            .get_data(arg_buffer, arg_data_offset)
            .into()
    }
}
#[doc = "See [_cef_binary_value_t] for more documentation."]
#[derive(Clone)]
pub struct BinaryValue(RefGuard<_cef_binary_value_t>);
impl ImplBinaryValue for BinaryValue {
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_owned<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_owned
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_same<'a>(&self, that: &'a mut BinaryValue) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_same
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.as_raw();
                    let arg_that = arg_that.as_raw();
                    let result = f(arg_self_, arg_that);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_equal<'a>(&self, that: &'a mut BinaryValue) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_equal
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.as_raw();
                    let arg_that = arg_that.as_raw();
                    let result = f(arg_self_, arg_that);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn copy<'a>(&self) -> BinaryValue {
        unsafe {
            self.0
                .copy
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw_data<'a>(&self) -> *const ::std::os::raw::c_void {
        unsafe {
            self.0
                .get_raw_data
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_size<'a>(&self) -> usize {
        unsafe {
            self.0
                .get_size
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_data<'a>(&self, buffer: Option<&'a mut &'a mut [u8]>, data_offset: usize) -> usize {
        unsafe {
            self.0
                .get_data
                .map(|f| {
                    let (arg_buffer, arg_data_offset) = (buffer, data_offset);
                    let arg_self_ = self.as_raw();
                    let arg_buffer_size = arg_buffer
                        .as_ref()
                        .map(|slice| slice.len())
                        .unwrap_or_default();
                    let mut out_buffer = arg_buffer;
                    let arg_buffer = out_buffer
                        .as_mut()
                        .and_then(|slice| {
                            if slice.is_empty() {
                                None
                            } else {
                                Some(slice.as_mut_ptr() as *mut _)
                            }
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_data_offset = arg_data_offset;
                    let result = f(arg_self_, arg_buffer, arg_buffer_size, arg_data_offset);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_binary_value_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for BinaryValue {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_binary_value_t> for &BinaryValue {
    fn as_raw(self) -> *mut _cef_binary_value_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_binary_value_t> for &mut BinaryValue {
    fn as_raw(self) -> *mut _cef_binary_value_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<BinaryValue> for *mut _cef_binary_value_t {
    fn as_wrapper(self) -> BinaryValue {
        BinaryValue(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_binary_value_t> for BinaryValue {
    fn into(self) -> *mut _cef_binary_value_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for BinaryValue {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplDictionaryValue: Sized {
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_owned<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_read_only<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_same<'a>(&self, that: &'a mut DictionaryValue) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_equal<'a>(&self, that: &'a mut DictionaryValue) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn copy<'a>(&self, exclude_empty_children: ::std::os::raw::c_int) -> DictionaryValue {
        unsafe { std::mem::zeroed() }
    }
    fn get_size<'a>(&self) -> usize {
        unsafe { std::mem::zeroed() }
    }
    fn clear<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn has_key<'a>(&self, key: &'a CefStringUtf16) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_keys<'a>(&self, keys: &'a mut CefStringList) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn remove<'a>(&self, key: &'a CefStringUtf16) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_type<'a>(&self, key: &'a CefStringUtf16) -> ValueType {
        unsafe { std::mem::zeroed() }
    }
    fn get_value<'a>(&self, key: &'a CefStringUtf16) -> Value {
        unsafe { std::mem::zeroed() }
    }
    fn get_bool<'a>(&self, key: &'a CefStringUtf16) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_int<'a>(&self, key: &'a CefStringUtf16) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_double<'a>(&self, key: &'a CefStringUtf16) -> f64 {
        unsafe { std::mem::zeroed() }
    }
    fn get_string<'a>(&self, key: &'a CefStringUtf16) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_binary<'a>(&self, key: &'a CefStringUtf16) -> BinaryValue {
        unsafe { std::mem::zeroed() }
    }
    fn get_dictionary<'a>(&self, key: &'a CefStringUtf16) -> DictionaryValue {
        unsafe { std::mem::zeroed() }
    }
    fn get_list<'a>(&self, key: &'a CefStringUtf16) -> ListValue {
        unsafe { std::mem::zeroed() }
    }
    fn set_value<'a>(
        &self,
        key: &'a CefStringUtf16,
        value: &'a mut Value,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_null<'a>(&self, key: &'a CefStringUtf16) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_bool<'a>(
        &self,
        key: &'a CefStringUtf16,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_int<'a>(
        &self,
        key: &'a CefStringUtf16,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_double<'a>(&self, key: &'a CefStringUtf16, value: f64) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_string<'a>(
        &self,
        key: &'a CefStringUtf16,
        value: &'a CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_binary<'a>(
        &self,
        key: &'a CefStringUtf16,
        value: &'a mut BinaryValue,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_dictionary<'a>(
        &self,
        key: &'a CefStringUtf16,
        value: &'a mut DictionaryValue,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_list<'a>(
        &self,
        key: &'a CefStringUtf16,
        value: &'a mut ListValue,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_dictionary_value_t {
        let mut object: _cef_dictionary_value_t = unsafe { std::mem::zeroed() };
        impl_cef_dictionary_value_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_dictionary_value_t {
    use super::*;
    pub fn init_methods<I: ImplDictionaryValue>(object: &mut _cef_dictionary_value_t) {
        object.is_valid = Some(is_valid::<I>);
        object.is_owned = Some(is_owned::<I>);
        object.is_read_only = Some(is_read_only::<I>);
        object.is_same = Some(is_same::<I>);
        object.is_equal = Some(is_equal::<I>);
        object.copy = Some(copy::<I>);
        object.get_size = Some(get_size::<I>);
        object.clear = Some(clear::<I>);
        object.has_key = Some(has_key::<I>);
        object.get_keys = Some(get_keys::<I>);
        object.remove = Some(remove::<I>);
        object.get_type = Some(get_type::<I>);
        object.get_value = Some(get_value::<I>);
        object.get_bool = Some(get_bool::<I>);
        object.get_int = Some(get_int::<I>);
        object.get_double = Some(get_double::<I>);
        object.get_string = Some(get_string::<I>);
        object.get_binary = Some(get_binary::<I>);
        object.get_dictionary = Some(get_dictionary::<I>);
        object.get_list = Some(get_list::<I>);
        object.set_value = Some(set_value::<I>);
        object.set_null = Some(set_null::<I>);
        object.set_bool = Some(set_bool::<I>);
        object.set_int = Some(set_int::<I>);
        object.set_double = Some(set_double::<I>);
        object.set_string = Some(set_string::<I>);
        object.set_binary = Some(set_binary::<I>);
        object.set_dictionary = Some(set_dictionary::<I>);
        object.set_list = Some(set_list::<I>);
    }
    extern "C" fn is_valid<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_valid().into()
    }
    extern "C" fn is_owned<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_owned().into()
    }
    extern "C" fn is_read_only<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_read_only().into()
    }
    extern "C" fn is_same<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        that: *mut _cef_dictionary_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_that) = (self_, that);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_that = &mut DictionaryValue(unsafe { RefGuard::from_raw_add_ref(arg_that) });
        arg_self_.interface.is_same(arg_that).into()
    }
    extern "C" fn is_equal<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        that: *mut _cef_dictionary_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_that) = (self_, that);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_that = &mut DictionaryValue(unsafe { RefGuard::from_raw_add_ref(arg_that) });
        arg_self_.interface.is_equal(arg_that).into()
    }
    extern "C" fn copy<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        exclude_empty_children: ::std::os::raw::c_int,
    ) -> *mut _cef_dictionary_value_t {
        let (arg_self_, arg_exclude_empty_children) = (self_, exclude_empty_children);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_exclude_empty_children = arg_exclude_empty_children.as_raw();
        arg_self_.interface.copy(arg_exclude_empty_children).into()
    }
    extern "C" fn get_size<I: ImplDictionaryValue>(self_: *mut _cef_dictionary_value_t) -> usize {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_size().into()
    }
    extern "C" fn clear<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.clear().into()
    }
    extern "C" fn has_key<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        key: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_key) = (self_, key);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = WrapParamRef::<CefStringUtf16>::from(arg_key);
        let arg_key = arg_key.as_ref();
        arg_self_.interface.has_key(arg_key).into()
    }
    extern "C" fn get_keys<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        keys: *mut _cef_string_list_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_keys) = (self_, keys);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_keys = WrapParamRef::<CefStringList>::from(arg_keys);
        let arg_keys = arg_keys.as_mut();
        arg_self_.interface.get_keys(arg_keys).into()
    }
    extern "C" fn remove<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        key: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_key) = (self_, key);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = WrapParamRef::<CefStringUtf16>::from(arg_key);
        let arg_key = arg_key.as_ref();
        arg_self_.interface.remove(arg_key).into()
    }
    extern "C" fn get_type<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        key: *const _cef_string_utf16_t,
    ) -> cef_value_type_t {
        let (arg_self_, arg_key) = (self_, key);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = WrapParamRef::<CefStringUtf16>::from(arg_key);
        let arg_key = arg_key.as_ref();
        arg_self_.interface.get_type(arg_key).into()
    }
    extern "C" fn get_value<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        key: *const _cef_string_utf16_t,
    ) -> *mut _cef_value_t {
        let (arg_self_, arg_key) = (self_, key);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = WrapParamRef::<CefStringUtf16>::from(arg_key);
        let arg_key = arg_key.as_ref();
        arg_self_.interface.get_value(arg_key).into()
    }
    extern "C" fn get_bool<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        key: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_key) = (self_, key);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = WrapParamRef::<CefStringUtf16>::from(arg_key);
        let arg_key = arg_key.as_ref();
        arg_self_.interface.get_bool(arg_key).into()
    }
    extern "C" fn get_int<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        key: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_key) = (self_, key);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = WrapParamRef::<CefStringUtf16>::from(arg_key);
        let arg_key = arg_key.as_ref();
        arg_self_.interface.get_int(arg_key).into()
    }
    extern "C" fn get_double<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        key: *const _cef_string_utf16_t,
    ) -> f64 {
        let (arg_self_, arg_key) = (self_, key);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = WrapParamRef::<CefStringUtf16>::from(arg_key);
        let arg_key = arg_key.as_ref();
        arg_self_.interface.get_double(arg_key).into()
    }
    extern "C" fn get_string<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        key: *const _cef_string_utf16_t,
    ) -> *mut _cef_string_utf16_t {
        let (arg_self_, arg_key) = (self_, key);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = WrapParamRef::<CefStringUtf16>::from(arg_key);
        let arg_key = arg_key.as_ref();
        arg_self_.interface.get_string(arg_key).into()
    }
    extern "C" fn get_binary<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        key: *const _cef_string_utf16_t,
    ) -> *mut _cef_binary_value_t {
        let (arg_self_, arg_key) = (self_, key);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = WrapParamRef::<CefStringUtf16>::from(arg_key);
        let arg_key = arg_key.as_ref();
        arg_self_.interface.get_binary(arg_key).into()
    }
    extern "C" fn get_dictionary<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        key: *const _cef_string_utf16_t,
    ) -> *mut _cef_dictionary_value_t {
        let (arg_self_, arg_key) = (self_, key);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = WrapParamRef::<CefStringUtf16>::from(arg_key);
        let arg_key = arg_key.as_ref();
        arg_self_.interface.get_dictionary(arg_key).into()
    }
    extern "C" fn get_list<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        key: *const _cef_string_utf16_t,
    ) -> *mut _cef_list_value_t {
        let (arg_self_, arg_key) = (self_, key);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = WrapParamRef::<CefStringUtf16>::from(arg_key);
        let arg_key = arg_key.as_ref();
        arg_self_.interface.get_list(arg_key).into()
    }
    extern "C" fn set_value<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        key: *const _cef_string_utf16_t,
        value: *mut _cef_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_key, arg_value) = (self_, key, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = WrapParamRef::<CefStringUtf16>::from(arg_key);
        let arg_key = arg_key.as_ref();
        let arg_value = &mut Value(unsafe { RefGuard::from_raw_add_ref(arg_value) });
        arg_self_.interface.set_value(arg_key, arg_value).into()
    }
    extern "C" fn set_null<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        key: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_key) = (self_, key);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = WrapParamRef::<CefStringUtf16>::from(arg_key);
        let arg_key = arg_key.as_ref();
        arg_self_.interface.set_null(arg_key).into()
    }
    extern "C" fn set_bool<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        key: *const _cef_string_utf16_t,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_key, arg_value) = (self_, key, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = WrapParamRef::<CefStringUtf16>::from(arg_key);
        let arg_key = arg_key.as_ref();
        let arg_value = arg_value.as_raw();
        arg_self_.interface.set_bool(arg_key, arg_value).into()
    }
    extern "C" fn set_int<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        key: *const _cef_string_utf16_t,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_key, arg_value) = (self_, key, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = WrapParamRef::<CefStringUtf16>::from(arg_key);
        let arg_key = arg_key.as_ref();
        let arg_value = arg_value.as_raw();
        arg_self_.interface.set_int(arg_key, arg_value).into()
    }
    extern "C" fn set_double<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        key: *const _cef_string_utf16_t,
        value: f64,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_key, arg_value) = (self_, key, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = WrapParamRef::<CefStringUtf16>::from(arg_key);
        let arg_key = arg_key.as_ref();
        let arg_value = arg_value.as_raw();
        arg_self_.interface.set_double(arg_key, arg_value).into()
    }
    extern "C" fn set_string<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        key: *const _cef_string_utf16_t,
        value: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_key, arg_value) = (self_, key, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = WrapParamRef::<CefStringUtf16>::from(arg_key);
        let arg_key = arg_key.as_ref();
        let arg_value = WrapParamRef::<CefStringUtf16>::from(arg_value);
        let arg_value = arg_value.as_ref();
        arg_self_.interface.set_string(arg_key, arg_value).into()
    }
    extern "C" fn set_binary<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        key: *const _cef_string_utf16_t,
        value: *mut _cef_binary_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_key, arg_value) = (self_, key, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = WrapParamRef::<CefStringUtf16>::from(arg_key);
        let arg_key = arg_key.as_ref();
        let arg_value = &mut BinaryValue(unsafe { RefGuard::from_raw_add_ref(arg_value) });
        arg_self_.interface.set_binary(arg_key, arg_value).into()
    }
    extern "C" fn set_dictionary<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        key: *const _cef_string_utf16_t,
        value: *mut _cef_dictionary_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_key, arg_value) = (self_, key, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = WrapParamRef::<CefStringUtf16>::from(arg_key);
        let arg_key = arg_key.as_ref();
        let arg_value = &mut DictionaryValue(unsafe { RefGuard::from_raw_add_ref(arg_value) });
        arg_self_
            .interface
            .set_dictionary(arg_key, arg_value)
            .into()
    }
    extern "C" fn set_list<I: ImplDictionaryValue>(
        self_: *mut _cef_dictionary_value_t,
        key: *const _cef_string_utf16_t,
        value: *mut _cef_list_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_key, arg_value) = (self_, key, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = WrapParamRef::<CefStringUtf16>::from(arg_key);
        let arg_key = arg_key.as_ref();
        let arg_value = &mut ListValue(unsafe { RefGuard::from_raw_add_ref(arg_value) });
        arg_self_.interface.set_list(arg_key, arg_value).into()
    }
}
#[doc = "See [_cef_dictionary_value_t] for more documentation."]
#[derive(Clone)]
pub struct DictionaryValue(RefGuard<_cef_dictionary_value_t>);
impl ImplDictionaryValue for DictionaryValue {
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_owned<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_owned
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_read_only<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_read_only
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_same<'a>(&self, that: &'a mut DictionaryValue) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_same
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.as_raw();
                    let arg_that = arg_that.as_raw();
                    let result = f(arg_self_, arg_that);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_equal<'a>(&self, that: &'a mut DictionaryValue) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_equal
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.as_raw();
                    let arg_that = arg_that.as_raw();
                    let result = f(arg_self_, arg_that);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn copy<'a>(&self, exclude_empty_children: ::std::os::raw::c_int) -> DictionaryValue {
        unsafe {
            self.0
                .copy
                .map(|f| {
                    let arg_exclude_empty_children = exclude_empty_children;
                    let arg_self_ = self.as_raw();
                    let arg_exclude_empty_children = arg_exclude_empty_children;
                    let result = f(arg_self_, arg_exclude_empty_children);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_size<'a>(&self) -> usize {
        unsafe {
            self.0
                .get_size
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn clear<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .clear
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn has_key<'a>(&self, key: &'a CefStringUtf16) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_key
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.as_raw();
                    let result = f(arg_self_, arg_key);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_keys<'a>(&self, keys: &'a mut CefStringList) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_keys
                .map(|f| {
                    let arg_keys = keys;
                    let arg_self_ = self.as_raw();
                    let arg_keys = arg_keys.as_raw();
                    let result = f(arg_self_, arg_keys);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn remove<'a>(&self, key: &'a CefStringUtf16) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .remove
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.as_raw();
                    let result = f(arg_self_, arg_key);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_type<'a>(&self, key: &'a CefStringUtf16) -> ValueType {
        unsafe {
            self.0
                .get_type
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.as_raw();
                    let result = f(arg_self_, arg_key);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_value<'a>(&self, key: &'a CefStringUtf16) -> Value {
        unsafe {
            self.0
                .get_value
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.as_raw();
                    let result = f(arg_self_, arg_key);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_bool<'a>(&self, key: &'a CefStringUtf16) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_bool
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.as_raw();
                    let result = f(arg_self_, arg_key);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_int<'a>(&self, key: &'a CefStringUtf16) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_int
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.as_raw();
                    let result = f(arg_self_, arg_key);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_double<'a>(&self, key: &'a CefStringUtf16) -> f64 {
        unsafe {
            self.0
                .get_double
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.as_raw();
                    let result = f(arg_self_, arg_key);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_string<'a>(&self, key: &'a CefStringUtf16) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_string
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.as_raw();
                    let result = f(arg_self_, arg_key);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_binary<'a>(&self, key: &'a CefStringUtf16) -> BinaryValue {
        unsafe {
            self.0
                .get_binary
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.as_raw();
                    let result = f(arg_self_, arg_key);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_dictionary<'a>(&self, key: &'a CefStringUtf16) -> DictionaryValue {
        unsafe {
            self.0
                .get_dictionary
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.as_raw();
                    let result = f(arg_self_, arg_key);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_list<'a>(&self, key: &'a CefStringUtf16) -> ListValue {
        unsafe {
            self.0
                .get_list
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.as_raw();
                    let result = f(arg_self_, arg_key);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_value<'a>(
        &self,
        key: &'a CefStringUtf16,
        value: &'a mut Value,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_value
                .map(|f| {
                    let (arg_key, arg_value) = (key, value);
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.as_raw();
                    let arg_value = arg_value.as_raw();
                    let result = f(arg_self_, arg_key, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_null<'a>(&self, key: &'a CefStringUtf16) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_null
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.as_raw();
                    let result = f(arg_self_, arg_key);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_bool<'a>(
        &self,
        key: &'a CefStringUtf16,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_bool
                .map(|f| {
                    let (arg_key, arg_value) = (key, value);
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.as_raw();
                    let arg_value = arg_value;
                    let result = f(arg_self_, arg_key, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_int<'a>(
        &self,
        key: &'a CefStringUtf16,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_int
                .map(|f| {
                    let (arg_key, arg_value) = (key, value);
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.as_raw();
                    let arg_value = arg_value;
                    let result = f(arg_self_, arg_key, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_double<'a>(&self, key: &'a CefStringUtf16, value: f64) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_double
                .map(|f| {
                    let (arg_key, arg_value) = (key, value);
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.as_raw();
                    let arg_value = arg_value;
                    let result = f(arg_self_, arg_key, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_string<'a>(
        &self,
        key: &'a CefStringUtf16,
        value: &'a CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_string
                .map(|f| {
                    let (arg_key, arg_value) = (key, value);
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.as_raw();
                    let arg_value = arg_value.as_raw();
                    let result = f(arg_self_, arg_key, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_binary<'a>(
        &self,
        key: &'a CefStringUtf16,
        value: &'a mut BinaryValue,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_binary
                .map(|f| {
                    let (arg_key, arg_value) = (key, value);
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.as_raw();
                    let arg_value = arg_value.as_raw();
                    let result = f(arg_self_, arg_key, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_dictionary<'a>(
        &self,
        key: &'a CefStringUtf16,
        value: &'a mut DictionaryValue,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_dictionary
                .map(|f| {
                    let (arg_key, arg_value) = (key, value);
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.as_raw();
                    let arg_value = arg_value.as_raw();
                    let result = f(arg_self_, arg_key, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_list<'a>(
        &self,
        key: &'a CefStringUtf16,
        value: &'a mut ListValue,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_list
                .map(|f| {
                    let (arg_key, arg_value) = (key, value);
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.as_raw();
                    let arg_value = arg_value.as_raw();
                    let result = f(arg_self_, arg_key, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_dictionary_value_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for DictionaryValue {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_dictionary_value_t> for &DictionaryValue {
    fn as_raw(self) -> *mut _cef_dictionary_value_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_dictionary_value_t> for &mut DictionaryValue {
    fn as_raw(self) -> *mut _cef_dictionary_value_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<DictionaryValue> for *mut _cef_dictionary_value_t {
    fn as_wrapper(self) -> DictionaryValue {
        DictionaryValue(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_dictionary_value_t> for DictionaryValue {
    fn into(self) -> *mut _cef_dictionary_value_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for DictionaryValue {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplListValue: Sized {
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_owned<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_read_only<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_same<'a>(&self, that: &'a mut ListValue) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_equal<'a>(&self, that: &'a mut ListValue) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn copy<'a>(&self) -> ListValue {
        unsafe { std::mem::zeroed() }
    }
    fn set_size<'a>(&self, size: usize) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_size<'a>(&self) -> usize {
        unsafe { std::mem::zeroed() }
    }
    fn clear<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn remove<'a>(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_type<'a>(&self, index: usize) -> ValueType {
        unsafe { std::mem::zeroed() }
    }
    fn get_value<'a>(&self, index: usize) -> Value {
        unsafe { std::mem::zeroed() }
    }
    fn get_bool<'a>(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_int<'a>(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_double<'a>(&self, index: usize) -> f64 {
        unsafe { std::mem::zeroed() }
    }
    fn get_string<'a>(&self, index: usize) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_binary<'a>(&self, index: usize) -> BinaryValue {
        unsafe { std::mem::zeroed() }
    }
    fn get_dictionary<'a>(&self, index: usize) -> DictionaryValue {
        unsafe { std::mem::zeroed() }
    }
    fn get_list<'a>(&self, index: usize) -> ListValue {
        unsafe { std::mem::zeroed() }
    }
    fn set_value<'a>(&self, index: usize, value: &'a mut Value) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_null<'a>(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_bool<'a>(&self, index: usize, value: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_int<'a>(&self, index: usize, value: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_double<'a>(&self, index: usize, value: f64) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_string<'a>(&self, index: usize, value: &'a CefStringUtf16) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_binary<'a>(&self, index: usize, value: &'a mut BinaryValue) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_dictionary<'a>(
        &self,
        index: usize,
        value: &'a mut DictionaryValue,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_list<'a>(&self, index: usize, value: &'a mut ListValue) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_list_value_t {
        let mut object: _cef_list_value_t = unsafe { std::mem::zeroed() };
        impl_cef_list_value_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_list_value_t {
    use super::*;
    pub fn init_methods<I: ImplListValue>(object: &mut _cef_list_value_t) {
        object.is_valid = Some(is_valid::<I>);
        object.is_owned = Some(is_owned::<I>);
        object.is_read_only = Some(is_read_only::<I>);
        object.is_same = Some(is_same::<I>);
        object.is_equal = Some(is_equal::<I>);
        object.copy = Some(copy::<I>);
        object.set_size = Some(set_size::<I>);
        object.get_size = Some(get_size::<I>);
        object.clear = Some(clear::<I>);
        object.remove = Some(remove::<I>);
        object.get_type = Some(get_type::<I>);
        object.get_value = Some(get_value::<I>);
        object.get_bool = Some(get_bool::<I>);
        object.get_int = Some(get_int::<I>);
        object.get_double = Some(get_double::<I>);
        object.get_string = Some(get_string::<I>);
        object.get_binary = Some(get_binary::<I>);
        object.get_dictionary = Some(get_dictionary::<I>);
        object.get_list = Some(get_list::<I>);
        object.set_value = Some(set_value::<I>);
        object.set_null = Some(set_null::<I>);
        object.set_bool = Some(set_bool::<I>);
        object.set_int = Some(set_int::<I>);
        object.set_double = Some(set_double::<I>);
        object.set_string = Some(set_string::<I>);
        object.set_binary = Some(set_binary::<I>);
        object.set_dictionary = Some(set_dictionary::<I>);
        object.set_list = Some(set_list::<I>);
    }
    extern "C" fn is_valid<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_valid().into()
    }
    extern "C" fn is_owned<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_owned().into()
    }
    extern "C" fn is_read_only<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_read_only().into()
    }
    extern "C" fn is_same<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        that: *mut _cef_list_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_that) = (self_, that);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_that = &mut ListValue(unsafe { RefGuard::from_raw_add_ref(arg_that) });
        arg_self_.interface.is_same(arg_that).into()
    }
    extern "C" fn is_equal<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        that: *mut _cef_list_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_that) = (self_, that);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_that = &mut ListValue(unsafe { RefGuard::from_raw_add_ref(arg_that) });
        arg_self_.interface.is_equal(arg_that).into()
    }
    extern "C" fn copy<I: ImplListValue>(self_: *mut _cef_list_value_t) -> *mut _cef_list_value_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.copy().into()
    }
    extern "C" fn set_size<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        size: usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_size) = (self_, size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_size = arg_size.as_raw();
        arg_self_.interface.set_size(arg_size).into()
    }
    extern "C" fn get_size<I: ImplListValue>(self_: *mut _cef_list_value_t) -> usize {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_size().into()
    }
    extern "C" fn clear<I: ImplListValue>(self_: *mut _cef_list_value_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.clear().into()
    }
    extern "C" fn remove<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        index: usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        arg_self_.interface.remove(arg_index).into()
    }
    extern "C" fn get_type<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        index: usize,
    ) -> cef_value_type_t {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        arg_self_.interface.get_type(arg_index).into()
    }
    extern "C" fn get_value<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        index: usize,
    ) -> *mut _cef_value_t {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        arg_self_.interface.get_value(arg_index).into()
    }
    extern "C" fn get_bool<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        index: usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        arg_self_.interface.get_bool(arg_index).into()
    }
    extern "C" fn get_int<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        index: usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        arg_self_.interface.get_int(arg_index).into()
    }
    extern "C" fn get_double<I: ImplListValue>(self_: *mut _cef_list_value_t, index: usize) -> f64 {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        arg_self_.interface.get_double(arg_index).into()
    }
    extern "C" fn get_string<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        index: usize,
    ) -> *mut _cef_string_utf16_t {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        arg_self_.interface.get_string(arg_index).into()
    }
    extern "C" fn get_binary<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        index: usize,
    ) -> *mut _cef_binary_value_t {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        arg_self_.interface.get_binary(arg_index).into()
    }
    extern "C" fn get_dictionary<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        index: usize,
    ) -> *mut _cef_dictionary_value_t {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        arg_self_.interface.get_dictionary(arg_index).into()
    }
    extern "C" fn get_list<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        index: usize,
    ) -> *mut _cef_list_value_t {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        arg_self_.interface.get_list(arg_index).into()
    }
    extern "C" fn set_value<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        index: usize,
        value: *mut _cef_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_value) = (self_, index, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_value = &mut Value(unsafe { RefGuard::from_raw_add_ref(arg_value) });
        arg_self_.interface.set_value(arg_index, arg_value).into()
    }
    extern "C" fn set_null<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        index: usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        arg_self_.interface.set_null(arg_index).into()
    }
    extern "C" fn set_bool<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        index: usize,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_value) = (self_, index, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_value = arg_value.as_raw();
        arg_self_.interface.set_bool(arg_index, arg_value).into()
    }
    extern "C" fn set_int<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        index: usize,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_value) = (self_, index, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_value = arg_value.as_raw();
        arg_self_.interface.set_int(arg_index, arg_value).into()
    }
    extern "C" fn set_double<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        index: usize,
        value: f64,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_value) = (self_, index, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_value = arg_value.as_raw();
        arg_self_.interface.set_double(arg_index, arg_value).into()
    }
    extern "C" fn set_string<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        index: usize,
        value: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_value) = (self_, index, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_value = WrapParamRef::<CefStringUtf16>::from(arg_value);
        let arg_value = arg_value.as_ref();
        arg_self_.interface.set_string(arg_index, arg_value).into()
    }
    extern "C" fn set_binary<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        index: usize,
        value: *mut _cef_binary_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_value) = (self_, index, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_value = &mut BinaryValue(unsafe { RefGuard::from_raw_add_ref(arg_value) });
        arg_self_.interface.set_binary(arg_index, arg_value).into()
    }
    extern "C" fn set_dictionary<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        index: usize,
        value: *mut _cef_dictionary_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_value) = (self_, index, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_value = &mut DictionaryValue(unsafe { RefGuard::from_raw_add_ref(arg_value) });
        arg_self_
            .interface
            .set_dictionary(arg_index, arg_value)
            .into()
    }
    extern "C" fn set_list<I: ImplListValue>(
        self_: *mut _cef_list_value_t,
        index: usize,
        value: *mut _cef_list_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_value) = (self_, index, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_value = &mut ListValue(unsafe { RefGuard::from_raw_add_ref(arg_value) });
        arg_self_.interface.set_list(arg_index, arg_value).into()
    }
}
#[doc = "See [_cef_list_value_t] for more documentation."]
#[derive(Clone)]
pub struct ListValue(RefGuard<_cef_list_value_t>);
impl ImplListValue for ListValue {
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_owned<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_owned
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_read_only<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_read_only
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_same<'a>(&self, that: &'a mut ListValue) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_same
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.as_raw();
                    let arg_that = arg_that.as_raw();
                    let result = f(arg_self_, arg_that);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_equal<'a>(&self, that: &'a mut ListValue) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_equal
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.as_raw();
                    let arg_that = arg_that.as_raw();
                    let result = f(arg_self_, arg_that);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn copy<'a>(&self) -> ListValue {
        unsafe {
            self.0
                .copy
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_size<'a>(&self, size: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_size
                .map(|f| {
                    let arg_size = size;
                    let arg_self_ = self.as_raw();
                    let arg_size = arg_size;
                    let result = f(arg_self_, arg_size);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_size<'a>(&self) -> usize {
        unsafe {
            self.0
                .get_size
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn clear<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .clear
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn remove<'a>(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .remove
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_type<'a>(&self, index: usize) -> ValueType {
        unsafe {
            self.0
                .get_type
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_value<'a>(&self, index: usize) -> Value {
        unsafe {
            self.0
                .get_value
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_bool<'a>(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_bool
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_int<'a>(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_int
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_double<'a>(&self, index: usize) -> f64 {
        unsafe {
            self.0
                .get_double
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_string<'a>(&self, index: usize) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_string
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_binary<'a>(&self, index: usize) -> BinaryValue {
        unsafe {
            self.0
                .get_binary
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_dictionary<'a>(&self, index: usize) -> DictionaryValue {
        unsafe {
            self.0
                .get_dictionary
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_list<'a>(&self, index: usize) -> ListValue {
        unsafe {
            self.0
                .get_list
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_value<'a>(&self, index: usize, value: &'a mut Value) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_value
                .map(|f| {
                    let (arg_index, arg_value) = (index, value);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_value = arg_value.as_raw();
                    let result = f(arg_self_, arg_index, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_null<'a>(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_null
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_bool<'a>(&self, index: usize, value: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_bool
                .map(|f| {
                    let (arg_index, arg_value) = (index, value);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_value = arg_value;
                    let result = f(arg_self_, arg_index, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_int<'a>(&self, index: usize, value: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_int
                .map(|f| {
                    let (arg_index, arg_value) = (index, value);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_value = arg_value;
                    let result = f(arg_self_, arg_index, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_double<'a>(&self, index: usize, value: f64) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_double
                .map(|f| {
                    let (arg_index, arg_value) = (index, value);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_value = arg_value;
                    let result = f(arg_self_, arg_index, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_string<'a>(&self, index: usize, value: &'a CefStringUtf16) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_string
                .map(|f| {
                    let (arg_index, arg_value) = (index, value);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_value = arg_value.as_raw();
                    let result = f(arg_self_, arg_index, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_binary<'a>(&self, index: usize, value: &'a mut BinaryValue) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_binary
                .map(|f| {
                    let (arg_index, arg_value) = (index, value);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_value = arg_value.as_raw();
                    let result = f(arg_self_, arg_index, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_dictionary<'a>(
        &self,
        index: usize,
        value: &'a mut DictionaryValue,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_dictionary
                .map(|f| {
                    let (arg_index, arg_value) = (index, value);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_value = arg_value.as_raw();
                    let result = f(arg_self_, arg_index, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_list<'a>(&self, index: usize, value: &'a mut ListValue) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_list
                .map(|f| {
                    let (arg_index, arg_value) = (index, value);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_value = arg_value.as_raw();
                    let result = f(arg_self_, arg_index, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_list_value_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ListValue {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_list_value_t> for &ListValue {
    fn as_raw(self) -> *mut _cef_list_value_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_list_value_t> for &mut ListValue {
    fn as_raw(self) -> *mut _cef_list_value_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<ListValue> for *mut _cef_list_value_t {
    fn as_wrapper(self) -> ListValue {
        ListValue(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_list_value_t> for ListValue {
    fn into(self) -> *mut _cef_list_value_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for ListValue {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplImage: Sized {
    fn is_empty<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_same<'a>(&self, that: &'a mut Image) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn add_bitmap<'a>(
        &self,
        scale_factor: f32,
        pixel_width: ::std::os::raw::c_int,
        pixel_height: ::std::os::raw::c_int,
        color_type: ColorType,
        alpha_type: AlphaType,
        pixel_data: Option<&'a [u8]>,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn add_png<'a>(&self, scale_factor: f32, png_data: Option<&'a [u8]>) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn add_jpeg<'a>(
        &self,
        scale_factor: f32,
        jpeg_data: Option<&'a [u8]>,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_width<'a>(&self) -> usize {
        unsafe { std::mem::zeroed() }
    }
    fn get_height<'a>(&self) -> usize {
        unsafe { std::mem::zeroed() }
    }
    fn has_representation<'a>(&self, scale_factor: f32) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn remove_representation<'a>(&self, scale_factor: f32) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_representation_info<'a>(
        &self,
        scale_factor: f32,
        actual_scale_factor: *mut f32,
        pixel_width: *mut ::std::os::raw::c_int,
        pixel_height: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_as_bitmap<'a>(
        &self,
        scale_factor: f32,
        color_type: ColorType,
        alpha_type: AlphaType,
        pixel_width: *mut ::std::os::raw::c_int,
        pixel_height: *mut ::std::os::raw::c_int,
    ) -> BinaryValue {
        unsafe { std::mem::zeroed() }
    }
    fn get_as_png<'a>(
        &self,
        scale_factor: f32,
        with_transparency: ::std::os::raw::c_int,
        pixel_width: *mut ::std::os::raw::c_int,
        pixel_height: *mut ::std::os::raw::c_int,
    ) -> BinaryValue {
        unsafe { std::mem::zeroed() }
    }
    fn get_as_jpeg<'a>(
        &self,
        scale_factor: f32,
        quality: ::std::os::raw::c_int,
        pixel_width: *mut ::std::os::raw::c_int,
        pixel_height: *mut ::std::os::raw::c_int,
    ) -> BinaryValue {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_image_t {
        let mut object: _cef_image_t = unsafe { std::mem::zeroed() };
        impl_cef_image_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_image_t {
    use super::*;
    pub fn init_methods<I: ImplImage>(object: &mut _cef_image_t) {
        object.is_empty = Some(is_empty::<I>);
        object.is_same = Some(is_same::<I>);
        object.add_bitmap = Some(add_bitmap::<I>);
        object.add_png = Some(add_png::<I>);
        object.add_jpeg = Some(add_jpeg::<I>);
        object.get_width = Some(get_width::<I>);
        object.get_height = Some(get_height::<I>);
        object.has_representation = Some(has_representation::<I>);
        object.remove_representation = Some(remove_representation::<I>);
        object.get_representation_info = Some(get_representation_info::<I>);
        object.get_as_bitmap = Some(get_as_bitmap::<I>);
        object.get_as_png = Some(get_as_png::<I>);
        object.get_as_jpeg = Some(get_as_jpeg::<I>);
    }
    extern "C" fn is_empty<I: ImplImage>(self_: *mut _cef_image_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_empty().into()
    }
    extern "C" fn is_same<I: ImplImage>(
        self_: *mut _cef_image_t,
        that: *mut _cef_image_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_that) = (self_, that);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_that = &mut Image(unsafe { RefGuard::from_raw_add_ref(arg_that) });
        arg_self_.interface.is_same(arg_that).into()
    }
    extern "C" fn add_bitmap<I: ImplImage>(
        self_: *mut _cef_image_t,
        scale_factor: f32,
        pixel_width: ::std::os::raw::c_int,
        pixel_height: ::std::os::raw::c_int,
        color_type: cef_color_type_t,
        alpha_type: cef_alpha_type_t,
        pixel_data: *const ::std::os::raw::c_void,
        pixel_data_size: usize,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_scale_factor,
            arg_pixel_width,
            arg_pixel_height,
            arg_color_type,
            arg_alpha_type,
            arg_pixel_data,
            arg_pixel_data_size,
        ) = (
            self_,
            scale_factor,
            pixel_width,
            pixel_height,
            color_type,
            alpha_type,
            pixel_data,
            pixel_data_size,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_scale_factor = arg_scale_factor.as_raw();
        let arg_pixel_width = arg_pixel_width.as_raw();
        let arg_pixel_height = arg_pixel_height.as_raw();
        let arg_color_type = arg_color_type.as_raw();
        let arg_alpha_type = arg_alpha_type.as_raw();
        let arg_pixel_data =
            (!arg_pixel_data.is_null() && arg_pixel_data_size > 0).then(|| unsafe {
                std::slice::from_raw_parts(arg_pixel_data as *const _, arg_pixel_data_size)
            });
        arg_self_
            .interface
            .add_bitmap(
                arg_scale_factor,
                arg_pixel_width,
                arg_pixel_height,
                arg_color_type,
                arg_alpha_type,
                arg_pixel_data,
            )
            .into()
    }
    extern "C" fn add_png<I: ImplImage>(
        self_: *mut _cef_image_t,
        scale_factor: f32,
        png_data: *const ::std::os::raw::c_void,
        png_data_size: usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_scale_factor, arg_png_data, arg_png_data_size) =
            (self_, scale_factor, png_data, png_data_size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_scale_factor = arg_scale_factor.as_raw();
        let arg_png_data = (!arg_png_data.is_null() && arg_png_data_size > 0).then(|| unsafe {
            std::slice::from_raw_parts(arg_png_data as *const _, arg_png_data_size)
        });
        arg_self_
            .interface
            .add_png(arg_scale_factor, arg_png_data)
            .into()
    }
    extern "C" fn add_jpeg<I: ImplImage>(
        self_: *mut _cef_image_t,
        scale_factor: f32,
        jpeg_data: *const ::std::os::raw::c_void,
        jpeg_data_size: usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_scale_factor, arg_jpeg_data, arg_jpeg_data_size) =
            (self_, scale_factor, jpeg_data, jpeg_data_size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_scale_factor = arg_scale_factor.as_raw();
        let arg_jpeg_data = (!arg_jpeg_data.is_null() && arg_jpeg_data_size > 0).then(|| unsafe {
            std::slice::from_raw_parts(arg_jpeg_data as *const _, arg_jpeg_data_size)
        });
        arg_self_
            .interface
            .add_jpeg(arg_scale_factor, arg_jpeg_data)
            .into()
    }
    extern "C" fn get_width<I: ImplImage>(self_: *mut _cef_image_t) -> usize {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_width().into()
    }
    extern "C" fn get_height<I: ImplImage>(self_: *mut _cef_image_t) -> usize {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_height().into()
    }
    extern "C" fn has_representation<I: ImplImage>(
        self_: *mut _cef_image_t,
        scale_factor: f32,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_scale_factor) = (self_, scale_factor);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_scale_factor = arg_scale_factor.as_raw();
        arg_self_
            .interface
            .has_representation(arg_scale_factor)
            .into()
    }
    extern "C" fn remove_representation<I: ImplImage>(
        self_: *mut _cef_image_t,
        scale_factor: f32,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_scale_factor) = (self_, scale_factor);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_scale_factor = arg_scale_factor.as_raw();
        arg_self_
            .interface
            .remove_representation(arg_scale_factor)
            .into()
    }
    extern "C" fn get_representation_info<I: ImplImage>(
        self_: *mut _cef_image_t,
        scale_factor: f32,
        actual_scale_factor: *mut f32,
        pixel_width: *mut ::std::os::raw::c_int,
        pixel_height: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_scale_factor,
            arg_actual_scale_factor,
            arg_pixel_width,
            arg_pixel_height,
        ) = (
            self_,
            scale_factor,
            actual_scale_factor,
            pixel_width,
            pixel_height,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_scale_factor = arg_scale_factor.as_raw();
        let mut arg_actual_scale_factor = WrapParamRef::<f32>::from(arg_actual_scale_factor);
        let arg_actual_scale_factor = arg_actual_scale_factor.as_mut();
        let mut arg_pixel_width = WrapParamRef::<::std::os::raw::c_int>::from(arg_pixel_width);
        let arg_pixel_width = arg_pixel_width.as_mut();
        let mut arg_pixel_height = WrapParamRef::<::std::os::raw::c_int>::from(arg_pixel_height);
        let arg_pixel_height = arg_pixel_height.as_mut();
        arg_self_
            .interface
            .get_representation_info(
                arg_scale_factor,
                arg_actual_scale_factor,
                arg_pixel_width,
                arg_pixel_height,
            )
            .into()
    }
    extern "C" fn get_as_bitmap<I: ImplImage>(
        self_: *mut _cef_image_t,
        scale_factor: f32,
        color_type: cef_color_type_t,
        alpha_type: cef_alpha_type_t,
        pixel_width: *mut ::std::os::raw::c_int,
        pixel_height: *mut ::std::os::raw::c_int,
    ) -> *mut _cef_binary_value_t {
        let (
            arg_self_,
            arg_scale_factor,
            arg_color_type,
            arg_alpha_type,
            arg_pixel_width,
            arg_pixel_height,
        ) = (
            self_,
            scale_factor,
            color_type,
            alpha_type,
            pixel_width,
            pixel_height,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_scale_factor = arg_scale_factor.as_raw();
        let arg_color_type = arg_color_type.as_raw();
        let arg_alpha_type = arg_alpha_type.as_raw();
        let mut arg_pixel_width = WrapParamRef::<::std::os::raw::c_int>::from(arg_pixel_width);
        let arg_pixel_width = arg_pixel_width.as_mut();
        let mut arg_pixel_height = WrapParamRef::<::std::os::raw::c_int>::from(arg_pixel_height);
        let arg_pixel_height = arg_pixel_height.as_mut();
        arg_self_
            .interface
            .get_as_bitmap(
                arg_scale_factor,
                arg_color_type,
                arg_alpha_type,
                arg_pixel_width,
                arg_pixel_height,
            )
            .into()
    }
    extern "C" fn get_as_png<I: ImplImage>(
        self_: *mut _cef_image_t,
        scale_factor: f32,
        with_transparency: ::std::os::raw::c_int,
        pixel_width: *mut ::std::os::raw::c_int,
        pixel_height: *mut ::std::os::raw::c_int,
    ) -> *mut _cef_binary_value_t {
        let (arg_self_, arg_scale_factor, arg_with_transparency, arg_pixel_width, arg_pixel_height) = (
            self_,
            scale_factor,
            with_transparency,
            pixel_width,
            pixel_height,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_scale_factor = arg_scale_factor.as_raw();
        let arg_with_transparency = arg_with_transparency.as_raw();
        let mut arg_pixel_width = WrapParamRef::<::std::os::raw::c_int>::from(arg_pixel_width);
        let arg_pixel_width = arg_pixel_width.as_mut();
        let mut arg_pixel_height = WrapParamRef::<::std::os::raw::c_int>::from(arg_pixel_height);
        let arg_pixel_height = arg_pixel_height.as_mut();
        arg_self_
            .interface
            .get_as_png(
                arg_scale_factor,
                arg_with_transparency,
                arg_pixel_width,
                arg_pixel_height,
            )
            .into()
    }
    extern "C" fn get_as_jpeg<I: ImplImage>(
        self_: *mut _cef_image_t,
        scale_factor: f32,
        quality: ::std::os::raw::c_int,
        pixel_width: *mut ::std::os::raw::c_int,
        pixel_height: *mut ::std::os::raw::c_int,
    ) -> *mut _cef_binary_value_t {
        let (arg_self_, arg_scale_factor, arg_quality, arg_pixel_width, arg_pixel_height) =
            (self_, scale_factor, quality, pixel_width, pixel_height);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_scale_factor = arg_scale_factor.as_raw();
        let arg_quality = arg_quality.as_raw();
        let mut arg_pixel_width = WrapParamRef::<::std::os::raw::c_int>::from(arg_pixel_width);
        let arg_pixel_width = arg_pixel_width.as_mut();
        let mut arg_pixel_height = WrapParamRef::<::std::os::raw::c_int>::from(arg_pixel_height);
        let arg_pixel_height = arg_pixel_height.as_mut();
        arg_self_
            .interface
            .get_as_jpeg(
                arg_scale_factor,
                arg_quality,
                arg_pixel_width,
                arg_pixel_height,
            )
            .into()
    }
}
#[doc = "See [_cef_image_t] for more documentation."]
#[derive(Clone)]
pub struct Image(RefGuard<_cef_image_t>);
impl ImplImage for Image {
    fn is_empty<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_empty
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_same<'a>(&self, that: &'a mut Image) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_same
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.as_raw();
                    let arg_that = arg_that.as_raw();
                    let result = f(arg_self_, arg_that);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn add_bitmap<'a>(
        &self,
        scale_factor: f32,
        pixel_width: ::std::os::raw::c_int,
        pixel_height: ::std::os::raw::c_int,
        color_type: ColorType,
        alpha_type: AlphaType,
        pixel_data: Option<&'a [u8]>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .add_bitmap
                .map(|f| {
                    let (
                        arg_scale_factor,
                        arg_pixel_width,
                        arg_pixel_height,
                        arg_color_type,
                        arg_alpha_type,
                        arg_pixel_data,
                    ) = (
                        scale_factor,
                        pixel_width,
                        pixel_height,
                        color_type,
                        alpha_type,
                        pixel_data,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_scale_factor = arg_scale_factor;
                    let arg_pixel_width = arg_pixel_width;
                    let arg_pixel_height = arg_pixel_height;
                    let arg_color_type = arg_color_type.as_raw();
                    let arg_alpha_type = arg_alpha_type.as_raw();
                    let arg_pixel_data_size =
                        arg_pixel_data.map(|slice| slice.len()).unwrap_or_default();
                    let out_pixel_data = arg_pixel_data;
                    let arg_pixel_data = arg_pixel_data
                        .and_then(|slice| {
                            if slice.is_empty() {
                                None
                            } else {
                                Some(slice.as_ptr() as *const _)
                            }
                        })
                        .unwrap_or(std::ptr::null());
                    let result = f(
                        arg_self_,
                        arg_scale_factor,
                        arg_pixel_width,
                        arg_pixel_height,
                        arg_color_type,
                        arg_alpha_type,
                        arg_pixel_data,
                        arg_pixel_data_size,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn add_png<'a>(&self, scale_factor: f32, png_data: Option<&'a [u8]>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .add_png
                .map(|f| {
                    let (arg_scale_factor, arg_png_data) = (scale_factor, png_data);
                    let arg_self_ = self.as_raw();
                    let arg_scale_factor = arg_scale_factor;
                    let arg_png_data_size =
                        arg_png_data.map(|slice| slice.len()).unwrap_or_default();
                    let out_png_data = arg_png_data;
                    let arg_png_data = arg_png_data
                        .and_then(|slice| {
                            if slice.is_empty() {
                                None
                            } else {
                                Some(slice.as_ptr() as *const _)
                            }
                        })
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_scale_factor, arg_png_data, arg_png_data_size);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn add_jpeg<'a>(
        &self,
        scale_factor: f32,
        jpeg_data: Option<&'a [u8]>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .add_jpeg
                .map(|f| {
                    let (arg_scale_factor, arg_jpeg_data) = (scale_factor, jpeg_data);
                    let arg_self_ = self.as_raw();
                    let arg_scale_factor = arg_scale_factor;
                    let arg_jpeg_data_size =
                        arg_jpeg_data.map(|slice| slice.len()).unwrap_or_default();
                    let out_jpeg_data = arg_jpeg_data;
                    let arg_jpeg_data = arg_jpeg_data
                        .and_then(|slice| {
                            if slice.is_empty() {
                                None
                            } else {
                                Some(slice.as_ptr() as *const _)
                            }
                        })
                        .unwrap_or(std::ptr::null());
                    let result = f(
                        arg_self_,
                        arg_scale_factor,
                        arg_jpeg_data,
                        arg_jpeg_data_size,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_width<'a>(&self) -> usize {
        unsafe {
            self.0
                .get_width
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_height<'a>(&self) -> usize {
        unsafe {
            self.0
                .get_height
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn has_representation<'a>(&self, scale_factor: f32) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_representation
                .map(|f| {
                    let arg_scale_factor = scale_factor;
                    let arg_self_ = self.as_raw();
                    let arg_scale_factor = arg_scale_factor;
                    let result = f(arg_self_, arg_scale_factor);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn remove_representation<'a>(&self, scale_factor: f32) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .remove_representation
                .map(|f| {
                    let arg_scale_factor = scale_factor;
                    let arg_self_ = self.as_raw();
                    let arg_scale_factor = arg_scale_factor;
                    let result = f(arg_self_, arg_scale_factor);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_representation_info<'a>(
        &self,
        scale_factor: f32,
        actual_scale_factor: *mut f32,
        pixel_width: *mut ::std::os::raw::c_int,
        pixel_height: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_representation_info
                .map(|f| {
                    let (
                        arg_scale_factor,
                        arg_actual_scale_factor,
                        arg_pixel_width,
                        arg_pixel_height,
                    ) = (scale_factor, actual_scale_factor, pixel_width, pixel_height);
                    let arg_self_ = self.as_raw();
                    let arg_scale_factor = arg_scale_factor;
                    let arg_actual_scale_factor = arg_actual_scale_factor as *mut _;
                    let arg_pixel_width = arg_pixel_width as *mut _;
                    let arg_pixel_height = arg_pixel_height as *mut _;
                    let result = f(
                        arg_self_,
                        arg_scale_factor,
                        arg_actual_scale_factor,
                        arg_pixel_width,
                        arg_pixel_height,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_as_bitmap<'a>(
        &self,
        scale_factor: f32,
        color_type: ColorType,
        alpha_type: AlphaType,
        pixel_width: *mut ::std::os::raw::c_int,
        pixel_height: *mut ::std::os::raw::c_int,
    ) -> BinaryValue {
        unsafe {
            self.0
                .get_as_bitmap
                .map(|f| {
                    let (
                        arg_scale_factor,
                        arg_color_type,
                        arg_alpha_type,
                        arg_pixel_width,
                        arg_pixel_height,
                    ) = (
                        scale_factor,
                        color_type,
                        alpha_type,
                        pixel_width,
                        pixel_height,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_scale_factor = arg_scale_factor;
                    let arg_color_type = arg_color_type.as_raw();
                    let arg_alpha_type = arg_alpha_type.as_raw();
                    let arg_pixel_width = arg_pixel_width as *mut _;
                    let arg_pixel_height = arg_pixel_height as *mut _;
                    let result = f(
                        arg_self_,
                        arg_scale_factor,
                        arg_color_type,
                        arg_alpha_type,
                        arg_pixel_width,
                        arg_pixel_height,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_as_png<'a>(
        &self,
        scale_factor: f32,
        with_transparency: ::std::os::raw::c_int,
        pixel_width: *mut ::std::os::raw::c_int,
        pixel_height: *mut ::std::os::raw::c_int,
    ) -> BinaryValue {
        unsafe {
            self.0
                .get_as_png
                .map(|f| {
                    let (
                        arg_scale_factor,
                        arg_with_transparency,
                        arg_pixel_width,
                        arg_pixel_height,
                    ) = (scale_factor, with_transparency, pixel_width, pixel_height);
                    let arg_self_ = self.as_raw();
                    let arg_scale_factor = arg_scale_factor;
                    let arg_with_transparency = arg_with_transparency;
                    let arg_pixel_width = arg_pixel_width as *mut _;
                    let arg_pixel_height = arg_pixel_height as *mut _;
                    let result = f(
                        arg_self_,
                        arg_scale_factor,
                        arg_with_transparency,
                        arg_pixel_width,
                        arg_pixel_height,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_as_jpeg<'a>(
        &self,
        scale_factor: f32,
        quality: ::std::os::raw::c_int,
        pixel_width: *mut ::std::os::raw::c_int,
        pixel_height: *mut ::std::os::raw::c_int,
    ) -> BinaryValue {
        unsafe {
            self.0
                .get_as_jpeg
                .map(|f| {
                    let (arg_scale_factor, arg_quality, arg_pixel_width, arg_pixel_height) =
                        (scale_factor, quality, pixel_width, pixel_height);
                    let arg_self_ = self.as_raw();
                    let arg_scale_factor = arg_scale_factor;
                    let arg_quality = arg_quality;
                    let arg_pixel_width = arg_pixel_width as *mut _;
                    let arg_pixel_height = arg_pixel_height as *mut _;
                    let result = f(
                        arg_self_,
                        arg_scale_factor,
                        arg_quality,
                        arg_pixel_width,
                        arg_pixel_height,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_image_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Image {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_image_t> for &Image {
    fn as_raw(self) -> *mut _cef_image_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_image_t> for &mut Image {
    fn as_raw(self) -> *mut _cef_image_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<Image> for *mut _cef_image_t {
    fn as_wrapper(self) -> Image {
        Image(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_image_t> for Image {
    fn into(self) -> *mut _cef_image_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for Image {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplReadHandler: Sized {
    fn read<'a>(&self, ptr: *mut ::std::os::raw::c_void, size: usize, n: usize) -> usize {
        unsafe { std::mem::zeroed() }
    }
    fn seek<'a>(&self, offset: i64, whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn tell<'a>(&self) -> i64 {
        unsafe { std::mem::zeroed() }
    }
    fn eof<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn may_block<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_read_handler_t {
        let mut object: _cef_read_handler_t = unsafe { std::mem::zeroed() };
        impl_cef_read_handler_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_read_handler_t {
    use super::*;
    pub fn init_methods<I: ImplReadHandler>(object: &mut _cef_read_handler_t) {
        object.read = Some(read::<I>);
        object.seek = Some(seek::<I>);
        object.tell = Some(tell::<I>);
        object.eof = Some(eof::<I>);
        object.may_block = Some(may_block::<I>);
    }
    extern "C" fn read<I: ImplReadHandler>(
        self_: *mut _cef_read_handler_t,
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        n: usize,
    ) -> usize {
        let (arg_self_, arg_ptr, arg_size, arg_n) = (self_, ptr, size, n);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_size = arg_size.as_raw();
        let arg_n = arg_n.as_raw();
        arg_self_.interface.read(arg_ptr, arg_size, arg_n).into()
    }
    extern "C" fn seek<I: ImplReadHandler>(
        self_: *mut _cef_read_handler_t,
        offset: i64,
        whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_offset, arg_whence) = (self_, offset, whence);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_offset = arg_offset.as_raw();
        let arg_whence = arg_whence.as_raw();
        arg_self_.interface.seek(arg_offset, arg_whence).into()
    }
    extern "C" fn tell<I: ImplReadHandler>(self_: *mut _cef_read_handler_t) -> i64 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.tell().into()
    }
    extern "C" fn eof<I: ImplReadHandler>(
        self_: *mut _cef_read_handler_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.eof().into()
    }
    extern "C" fn may_block<I: ImplReadHandler>(
        self_: *mut _cef_read_handler_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.may_block().into()
    }
}
#[doc = "See [_cef_read_handler_t] for more documentation."]
#[derive(Clone)]
pub struct ReadHandler(RefGuard<_cef_read_handler_t>);
impl ImplReadHandler for ReadHandler {
    fn read<'a>(&self, ptr: *mut ::std::os::raw::c_void, size: usize, n: usize) -> usize {
        unsafe {
            self.0
                .read
                .map(|f| {
                    let (arg_ptr, arg_size, arg_n) = (ptr, size, n);
                    let arg_self_ = self.as_raw();
                    let arg_ptr = arg_ptr as *mut _;
                    let arg_size = arg_size;
                    let arg_n = arg_n;
                    let result = f(arg_self_, arg_ptr, arg_size, arg_n);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn seek<'a>(&self, offset: i64, whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .seek
                .map(|f| {
                    let (arg_offset, arg_whence) = (offset, whence);
                    let arg_self_ = self.as_raw();
                    let arg_offset = arg_offset;
                    let arg_whence = arg_whence;
                    let result = f(arg_self_, arg_offset, arg_whence);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn tell<'a>(&self) -> i64 {
        unsafe {
            self.0
                .tell
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn eof<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .eof
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn may_block<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .may_block
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_read_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ReadHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_read_handler_t> for &ReadHandler {
    fn as_raw(self) -> *mut _cef_read_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_read_handler_t> for &mut ReadHandler {
    fn as_raw(self) -> *mut _cef_read_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<ReadHandler> for *mut _cef_read_handler_t {
    fn as_wrapper(self) -> ReadHandler {
        ReadHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_read_handler_t> for ReadHandler {
    fn into(self) -> *mut _cef_read_handler_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for ReadHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplStreamReader: Sized {
    fn read<'a>(&self, ptr: *mut ::std::os::raw::c_void, size: usize, n: usize) -> usize {
        unsafe { std::mem::zeroed() }
    }
    fn seek<'a>(&self, offset: i64, whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn tell<'a>(&self) -> i64 {
        unsafe { std::mem::zeroed() }
    }
    fn eof<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn may_block<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_stream_reader_t {
        let mut object: _cef_stream_reader_t = unsafe { std::mem::zeroed() };
        impl_cef_stream_reader_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_stream_reader_t {
    use super::*;
    pub fn init_methods<I: ImplStreamReader>(object: &mut _cef_stream_reader_t) {
        object.read = Some(read::<I>);
        object.seek = Some(seek::<I>);
        object.tell = Some(tell::<I>);
        object.eof = Some(eof::<I>);
        object.may_block = Some(may_block::<I>);
    }
    extern "C" fn read<I: ImplStreamReader>(
        self_: *mut _cef_stream_reader_t,
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        n: usize,
    ) -> usize {
        let (arg_self_, arg_ptr, arg_size, arg_n) = (self_, ptr, size, n);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_size = arg_size.as_raw();
        let arg_n = arg_n.as_raw();
        arg_self_.interface.read(arg_ptr, arg_size, arg_n).into()
    }
    extern "C" fn seek<I: ImplStreamReader>(
        self_: *mut _cef_stream_reader_t,
        offset: i64,
        whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_offset, arg_whence) = (self_, offset, whence);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_offset = arg_offset.as_raw();
        let arg_whence = arg_whence.as_raw();
        arg_self_.interface.seek(arg_offset, arg_whence).into()
    }
    extern "C" fn tell<I: ImplStreamReader>(self_: *mut _cef_stream_reader_t) -> i64 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.tell().into()
    }
    extern "C" fn eof<I: ImplStreamReader>(
        self_: *mut _cef_stream_reader_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.eof().into()
    }
    extern "C" fn may_block<I: ImplStreamReader>(
        self_: *mut _cef_stream_reader_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.may_block().into()
    }
}
#[doc = "See [_cef_stream_reader_t] for more documentation."]
#[derive(Clone)]
pub struct StreamReader(RefGuard<_cef_stream_reader_t>);
impl ImplStreamReader for StreamReader {
    fn read<'a>(&self, ptr: *mut ::std::os::raw::c_void, size: usize, n: usize) -> usize {
        unsafe {
            self.0
                .read
                .map(|f| {
                    let (arg_ptr, arg_size, arg_n) = (ptr, size, n);
                    let arg_self_ = self.as_raw();
                    let arg_ptr = arg_ptr as *mut _;
                    let arg_size = arg_size;
                    let arg_n = arg_n;
                    let result = f(arg_self_, arg_ptr, arg_size, arg_n);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn seek<'a>(&self, offset: i64, whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .seek
                .map(|f| {
                    let (arg_offset, arg_whence) = (offset, whence);
                    let arg_self_ = self.as_raw();
                    let arg_offset = arg_offset;
                    let arg_whence = arg_whence;
                    let result = f(arg_self_, arg_offset, arg_whence);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn tell<'a>(&self) -> i64 {
        unsafe {
            self.0
                .tell
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn eof<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .eof
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn may_block<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .may_block
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_stream_reader_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for StreamReader {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_stream_reader_t> for &StreamReader {
    fn as_raw(self) -> *mut _cef_stream_reader_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_stream_reader_t> for &mut StreamReader {
    fn as_raw(self) -> *mut _cef_stream_reader_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<StreamReader> for *mut _cef_stream_reader_t {
    fn as_wrapper(self) -> StreamReader {
        StreamReader(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_stream_reader_t> for StreamReader {
    fn into(self) -> *mut _cef_stream_reader_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for StreamReader {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplWriteHandler: Sized {
    fn write<'a>(&self, ptr: *const ::std::os::raw::c_void, size: usize, n: usize) -> usize {
        unsafe { std::mem::zeroed() }
    }
    fn seek<'a>(&self, offset: i64, whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn tell<'a>(&self) -> i64 {
        unsafe { std::mem::zeroed() }
    }
    fn flush<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn may_block<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_write_handler_t {
        let mut object: _cef_write_handler_t = unsafe { std::mem::zeroed() };
        impl_cef_write_handler_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_write_handler_t {
    use super::*;
    pub fn init_methods<I: ImplWriteHandler>(object: &mut _cef_write_handler_t) {
        object.write = Some(write::<I>);
        object.seek = Some(seek::<I>);
        object.tell = Some(tell::<I>);
        object.flush = Some(flush::<I>);
        object.may_block = Some(may_block::<I>);
    }
    extern "C" fn write<I: ImplWriteHandler>(
        self_: *mut _cef_write_handler_t,
        ptr: *const ::std::os::raw::c_void,
        size: usize,
        n: usize,
    ) -> usize {
        let (arg_self_, arg_ptr, arg_size, arg_n) = (self_, ptr, size, n);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_size = arg_size.as_raw();
        let arg_n = arg_n.as_raw();
        arg_self_.interface.write(arg_ptr, arg_size, arg_n).into()
    }
    extern "C" fn seek<I: ImplWriteHandler>(
        self_: *mut _cef_write_handler_t,
        offset: i64,
        whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_offset, arg_whence) = (self_, offset, whence);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_offset = arg_offset.as_raw();
        let arg_whence = arg_whence.as_raw();
        arg_self_.interface.seek(arg_offset, arg_whence).into()
    }
    extern "C" fn tell<I: ImplWriteHandler>(self_: *mut _cef_write_handler_t) -> i64 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.tell().into()
    }
    extern "C" fn flush<I: ImplWriteHandler>(
        self_: *mut _cef_write_handler_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.flush().into()
    }
    extern "C" fn may_block<I: ImplWriteHandler>(
        self_: *mut _cef_write_handler_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.may_block().into()
    }
}
#[doc = "See [_cef_write_handler_t] for more documentation."]
#[derive(Clone)]
pub struct WriteHandler(RefGuard<_cef_write_handler_t>);
impl ImplWriteHandler for WriteHandler {
    fn write<'a>(&self, ptr: *const ::std::os::raw::c_void, size: usize, n: usize) -> usize {
        unsafe {
            self.0
                .write
                .map(|f| {
                    let (arg_ptr, arg_size, arg_n) = (ptr, size, n);
                    let arg_self_ = self.as_raw();
                    let arg_ptr = arg_ptr as *const _;
                    let arg_size = arg_size;
                    let arg_n = arg_n;
                    let result = f(arg_self_, arg_ptr, arg_size, arg_n);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn seek<'a>(&self, offset: i64, whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .seek
                .map(|f| {
                    let (arg_offset, arg_whence) = (offset, whence);
                    let arg_self_ = self.as_raw();
                    let arg_offset = arg_offset;
                    let arg_whence = arg_whence;
                    let result = f(arg_self_, arg_offset, arg_whence);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn tell<'a>(&self) -> i64 {
        unsafe {
            self.0
                .tell
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn flush<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .flush
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn may_block<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .may_block
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_write_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for WriteHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_write_handler_t> for &WriteHandler {
    fn as_raw(self) -> *mut _cef_write_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_write_handler_t> for &mut WriteHandler {
    fn as_raw(self) -> *mut _cef_write_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<WriteHandler> for *mut _cef_write_handler_t {
    fn as_wrapper(self) -> WriteHandler {
        WriteHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_write_handler_t> for WriteHandler {
    fn into(self) -> *mut _cef_write_handler_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for WriteHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplStreamWriter: Sized {
    fn write<'a>(&self, ptr: *const ::std::os::raw::c_void, size: usize, n: usize) -> usize {
        unsafe { std::mem::zeroed() }
    }
    fn seek<'a>(&self, offset: i64, whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn tell<'a>(&self) -> i64 {
        unsafe { std::mem::zeroed() }
    }
    fn flush<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn may_block<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_stream_writer_t {
        let mut object: _cef_stream_writer_t = unsafe { std::mem::zeroed() };
        impl_cef_stream_writer_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_stream_writer_t {
    use super::*;
    pub fn init_methods<I: ImplStreamWriter>(object: &mut _cef_stream_writer_t) {
        object.write = Some(write::<I>);
        object.seek = Some(seek::<I>);
        object.tell = Some(tell::<I>);
        object.flush = Some(flush::<I>);
        object.may_block = Some(may_block::<I>);
    }
    extern "C" fn write<I: ImplStreamWriter>(
        self_: *mut _cef_stream_writer_t,
        ptr: *const ::std::os::raw::c_void,
        size: usize,
        n: usize,
    ) -> usize {
        let (arg_self_, arg_ptr, arg_size, arg_n) = (self_, ptr, size, n);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_size = arg_size.as_raw();
        let arg_n = arg_n.as_raw();
        arg_self_.interface.write(arg_ptr, arg_size, arg_n).into()
    }
    extern "C" fn seek<I: ImplStreamWriter>(
        self_: *mut _cef_stream_writer_t,
        offset: i64,
        whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_offset, arg_whence) = (self_, offset, whence);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_offset = arg_offset.as_raw();
        let arg_whence = arg_whence.as_raw();
        arg_self_.interface.seek(arg_offset, arg_whence).into()
    }
    extern "C" fn tell<I: ImplStreamWriter>(self_: *mut _cef_stream_writer_t) -> i64 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.tell().into()
    }
    extern "C" fn flush<I: ImplStreamWriter>(
        self_: *mut _cef_stream_writer_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.flush().into()
    }
    extern "C" fn may_block<I: ImplStreamWriter>(
        self_: *mut _cef_stream_writer_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.may_block().into()
    }
}
#[doc = "See [_cef_stream_writer_t] for more documentation."]
#[derive(Clone)]
pub struct StreamWriter(RefGuard<_cef_stream_writer_t>);
impl ImplStreamWriter for StreamWriter {
    fn write<'a>(&self, ptr: *const ::std::os::raw::c_void, size: usize, n: usize) -> usize {
        unsafe {
            self.0
                .write
                .map(|f| {
                    let (arg_ptr, arg_size, arg_n) = (ptr, size, n);
                    let arg_self_ = self.as_raw();
                    let arg_ptr = arg_ptr as *const _;
                    let arg_size = arg_size;
                    let arg_n = arg_n;
                    let result = f(arg_self_, arg_ptr, arg_size, arg_n);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn seek<'a>(&self, offset: i64, whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .seek
                .map(|f| {
                    let (arg_offset, arg_whence) = (offset, whence);
                    let arg_self_ = self.as_raw();
                    let arg_offset = arg_offset;
                    let arg_whence = arg_whence;
                    let result = f(arg_self_, arg_offset, arg_whence);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn tell<'a>(&self) -> i64 {
        unsafe {
            self.0
                .tell
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn flush<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .flush
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn may_block<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .may_block
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_stream_writer_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for StreamWriter {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_stream_writer_t> for &StreamWriter {
    fn as_raw(self) -> *mut _cef_stream_writer_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_stream_writer_t> for &mut StreamWriter {
    fn as_raw(self) -> *mut _cef_stream_writer_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<StreamWriter> for *mut _cef_stream_writer_t {
    fn as_wrapper(self) -> StreamWriter {
        StreamWriter(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_stream_writer_t> for StreamWriter {
    fn into(self) -> *mut _cef_stream_writer_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for StreamWriter {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplDragData: Sized {
    fn clone<'a>(&self) -> DragData {
        unsafe { std::mem::zeroed() }
    }
    fn is_read_only<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_link<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_fragment<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_file<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_link_url<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_link_title<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_link_metadata<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_fragment_text<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_fragment_html<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_fragment_base_url<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_file_name<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_file_contents<'a>(&self, writer: &'a mut StreamWriter) -> usize {
        unsafe { std::mem::zeroed() }
    }
    fn get_file_names<'a>(&self, names: &'a mut CefStringList) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_file_paths<'a>(&self, paths: &'a mut CefStringList) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_link_url<'a>(&self, url: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn set_link_title<'a>(&self, title: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn set_link_metadata<'a>(&self, data: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn set_fragment_text<'a>(&self, text: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn set_fragment_html<'a>(&self, html: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn set_fragment_base_url<'a>(&self, base_url: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn reset_file_contents<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn add_file<'a>(&self, path: &'a CefStringUtf16, display_name: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn clear_filenames<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn get_image<'a>(&self) -> Image {
        unsafe { std::mem::zeroed() }
    }
    fn get_image_hotspot<'a>(&self) -> Point {
        unsafe { std::mem::zeroed() }
    }
    fn has_image<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_drag_data_t {
        let mut object: _cef_drag_data_t = unsafe { std::mem::zeroed() };
        impl_cef_drag_data_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_drag_data_t {
    use super::*;
    pub fn init_methods<I: ImplDragData>(object: &mut _cef_drag_data_t) {
        object.clone = Some(clone::<I>);
        object.is_read_only = Some(is_read_only::<I>);
        object.is_link = Some(is_link::<I>);
        object.is_fragment = Some(is_fragment::<I>);
        object.is_file = Some(is_file::<I>);
        object.get_link_url = Some(get_link_url::<I>);
        object.get_link_title = Some(get_link_title::<I>);
        object.get_link_metadata = Some(get_link_metadata::<I>);
        object.get_fragment_text = Some(get_fragment_text::<I>);
        object.get_fragment_html = Some(get_fragment_html::<I>);
        object.get_fragment_base_url = Some(get_fragment_base_url::<I>);
        object.get_file_name = Some(get_file_name::<I>);
        object.get_file_contents = Some(get_file_contents::<I>);
        object.get_file_names = Some(get_file_names::<I>);
        object.get_file_paths = Some(get_file_paths::<I>);
        object.set_link_url = Some(set_link_url::<I>);
        object.set_link_title = Some(set_link_title::<I>);
        object.set_link_metadata = Some(set_link_metadata::<I>);
        object.set_fragment_text = Some(set_fragment_text::<I>);
        object.set_fragment_html = Some(set_fragment_html::<I>);
        object.set_fragment_base_url = Some(set_fragment_base_url::<I>);
        object.reset_file_contents = Some(reset_file_contents::<I>);
        object.add_file = Some(add_file::<I>);
        object.clear_filenames = Some(clear_filenames::<I>);
        object.get_image = Some(get_image::<I>);
        object.get_image_hotspot = Some(get_image_hotspot::<I>);
        object.has_image = Some(has_image::<I>);
    }
    extern "C" fn clone<I: ImplDragData>(self_: *mut _cef_drag_data_t) -> *mut _cef_drag_data_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.clone().into()
    }
    extern "C" fn is_read_only<I: ImplDragData>(
        self_: *mut _cef_drag_data_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_read_only().into()
    }
    extern "C" fn is_link<I: ImplDragData>(self_: *mut _cef_drag_data_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_link().into()
    }
    extern "C" fn is_fragment<I: ImplDragData>(
        self_: *mut _cef_drag_data_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_fragment().into()
    }
    extern "C" fn is_file<I: ImplDragData>(self_: *mut _cef_drag_data_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_file().into()
    }
    extern "C" fn get_link_url<I: ImplDragData>(
        self_: *mut _cef_drag_data_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_link_url().into()
    }
    extern "C" fn get_link_title<I: ImplDragData>(
        self_: *mut _cef_drag_data_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_link_title().into()
    }
    extern "C" fn get_link_metadata<I: ImplDragData>(
        self_: *mut _cef_drag_data_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_link_metadata().into()
    }
    extern "C" fn get_fragment_text<I: ImplDragData>(
        self_: *mut _cef_drag_data_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_fragment_text().into()
    }
    extern "C" fn get_fragment_html<I: ImplDragData>(
        self_: *mut _cef_drag_data_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_fragment_html().into()
    }
    extern "C" fn get_fragment_base_url<I: ImplDragData>(
        self_: *mut _cef_drag_data_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_fragment_base_url().into()
    }
    extern "C" fn get_file_name<I: ImplDragData>(
        self_: *mut _cef_drag_data_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_file_name().into()
    }
    extern "C" fn get_file_contents<I: ImplDragData>(
        self_: *mut _cef_drag_data_t,
        writer: *mut _cef_stream_writer_t,
    ) -> usize {
        let (arg_self_, arg_writer) = (self_, writer);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_writer = &mut StreamWriter(unsafe { RefGuard::from_raw_add_ref(arg_writer) });
        arg_self_.interface.get_file_contents(arg_writer).into()
    }
    extern "C" fn get_file_names<I: ImplDragData>(
        self_: *mut _cef_drag_data_t,
        names: *mut _cef_string_list_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_names) = (self_, names);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_names = WrapParamRef::<CefStringList>::from(arg_names);
        let arg_names = arg_names.as_mut();
        arg_self_.interface.get_file_names(arg_names).into()
    }
    extern "C" fn get_file_paths<I: ImplDragData>(
        self_: *mut _cef_drag_data_t,
        paths: *mut _cef_string_list_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_paths) = (self_, paths);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_paths = WrapParamRef::<CefStringList>::from(arg_paths);
        let arg_paths = arg_paths.as_mut();
        arg_self_.interface.get_file_paths(arg_paths).into()
    }
    extern "C" fn set_link_url<I: ImplDragData>(
        self_: *mut _cef_drag_data_t,
        url: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_url) = (self_, url);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_url = WrapParamRef::<CefStringUtf16>::from(arg_url);
        let arg_url = arg_url.as_ref();
        arg_self_.interface.set_link_url(arg_url)
    }
    extern "C" fn set_link_title<I: ImplDragData>(
        self_: *mut _cef_drag_data_t,
        title: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_title) = (self_, title);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_title = WrapParamRef::<CefStringUtf16>::from(arg_title);
        let arg_title = arg_title.as_ref();
        arg_self_.interface.set_link_title(arg_title)
    }
    extern "C" fn set_link_metadata<I: ImplDragData>(
        self_: *mut _cef_drag_data_t,
        data: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_data) = (self_, data);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_data = WrapParamRef::<CefStringUtf16>::from(arg_data);
        let arg_data = arg_data.as_ref();
        arg_self_.interface.set_link_metadata(arg_data)
    }
    extern "C" fn set_fragment_text<I: ImplDragData>(
        self_: *mut _cef_drag_data_t,
        text: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_text) = (self_, text);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_text = WrapParamRef::<CefStringUtf16>::from(arg_text);
        let arg_text = arg_text.as_ref();
        arg_self_.interface.set_fragment_text(arg_text)
    }
    extern "C" fn set_fragment_html<I: ImplDragData>(
        self_: *mut _cef_drag_data_t,
        html: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_html) = (self_, html);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_html = WrapParamRef::<CefStringUtf16>::from(arg_html);
        let arg_html = arg_html.as_ref();
        arg_self_.interface.set_fragment_html(arg_html)
    }
    extern "C" fn set_fragment_base_url<I: ImplDragData>(
        self_: *mut _cef_drag_data_t,
        base_url: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_base_url) = (self_, base_url);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_base_url = WrapParamRef::<CefStringUtf16>::from(arg_base_url);
        let arg_base_url = arg_base_url.as_ref();
        arg_self_.interface.set_fragment_base_url(arg_base_url)
    }
    extern "C" fn reset_file_contents<I: ImplDragData>(self_: *mut _cef_drag_data_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.reset_file_contents()
    }
    extern "C" fn add_file<I: ImplDragData>(
        self_: *mut _cef_drag_data_t,
        path: *const _cef_string_utf16_t,
        display_name: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_path, arg_display_name) = (self_, path, display_name);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_path = WrapParamRef::<CefStringUtf16>::from(arg_path);
        let arg_path = arg_path.as_ref();
        let arg_display_name = WrapParamRef::<CefStringUtf16>::from(arg_display_name);
        let arg_display_name = arg_display_name.as_ref();
        arg_self_.interface.add_file(arg_path, arg_display_name)
    }
    extern "C" fn clear_filenames<I: ImplDragData>(self_: *mut _cef_drag_data_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.clear_filenames()
    }
    extern "C" fn get_image<I: ImplDragData>(self_: *mut _cef_drag_data_t) -> *mut _cef_image_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_image().into()
    }
    extern "C" fn get_image_hotspot<I: ImplDragData>(self_: *mut _cef_drag_data_t) -> _cef_point_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_image_hotspot().into()
    }
    extern "C" fn has_image<I: ImplDragData>(
        self_: *mut _cef_drag_data_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.has_image().into()
    }
}
#[doc = "See [_cef_drag_data_t] for more documentation."]
#[derive(Clone)]
pub struct DragData(RefGuard<_cef_drag_data_t>);
impl ImplDragData for DragData {
    fn clone<'a>(&self) -> DragData {
        unsafe {
            self.0
                .clone
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_read_only<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_read_only
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_link<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_link
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_fragment<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_fragment
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_file<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_file
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_link_url<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_link_url
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_link_title<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_link_title
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_link_metadata<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_link_metadata
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_fragment_text<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_fragment_text
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_fragment_html<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_fragment_html
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_fragment_base_url<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_fragment_base_url
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_file_name<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_file_name
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_file_contents<'a>(&self, writer: &'a mut StreamWriter) -> usize {
        unsafe {
            self.0
                .get_file_contents
                .map(|f| {
                    let arg_writer = writer;
                    let arg_self_ = self.as_raw();
                    let arg_writer = arg_writer.as_raw();
                    let result = f(arg_self_, arg_writer);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_file_names<'a>(&self, names: &'a mut CefStringList) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_file_names
                .map(|f| {
                    let arg_names = names;
                    let arg_self_ = self.as_raw();
                    let arg_names = arg_names.as_raw();
                    let result = f(arg_self_, arg_names);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_file_paths<'a>(&self, paths: &'a mut CefStringList) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_file_paths
                .map(|f| {
                    let arg_paths = paths;
                    let arg_self_ = self.as_raw();
                    let arg_paths = arg_paths.as_raw();
                    let result = f(arg_self_, arg_paths);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_link_url<'a>(&self, url: &'a CefStringUtf16) {
        unsafe {
            self.0
                .set_link_url
                .map(|f| {
                    let arg_url = url;
                    let arg_self_ = self.as_raw();
                    let arg_url = arg_url.as_raw();
                    let result = f(arg_self_, arg_url);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_link_title<'a>(&self, title: &'a CefStringUtf16) {
        unsafe {
            self.0
                .set_link_title
                .map(|f| {
                    let arg_title = title;
                    let arg_self_ = self.as_raw();
                    let arg_title = arg_title.as_raw();
                    let result = f(arg_self_, arg_title);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_link_metadata<'a>(&self, data: &'a CefStringUtf16) {
        unsafe {
            self.0
                .set_link_metadata
                .map(|f| {
                    let arg_data = data;
                    let arg_self_ = self.as_raw();
                    let arg_data = arg_data.as_raw();
                    let result = f(arg_self_, arg_data);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_fragment_text<'a>(&self, text: &'a CefStringUtf16) {
        unsafe {
            self.0
                .set_fragment_text
                .map(|f| {
                    let arg_text = text;
                    let arg_self_ = self.as_raw();
                    let arg_text = arg_text.as_raw();
                    let result = f(arg_self_, arg_text);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_fragment_html<'a>(&self, html: &'a CefStringUtf16) {
        unsafe {
            self.0
                .set_fragment_html
                .map(|f| {
                    let arg_html = html;
                    let arg_self_ = self.as_raw();
                    let arg_html = arg_html.as_raw();
                    let result = f(arg_self_, arg_html);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_fragment_base_url<'a>(&self, base_url: &'a CefStringUtf16) {
        unsafe {
            self.0
                .set_fragment_base_url
                .map(|f| {
                    let arg_base_url = base_url;
                    let arg_self_ = self.as_raw();
                    let arg_base_url = arg_base_url.as_raw();
                    let result = f(arg_self_, arg_base_url);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn reset_file_contents<'a>(&self) {
        unsafe {
            self.0
                .reset_file_contents
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn add_file<'a>(&self, path: &'a CefStringUtf16, display_name: &'a CefStringUtf16) {
        unsafe {
            self.0
                .add_file
                .map(|f| {
                    let (arg_path, arg_display_name) = (path, display_name);
                    let arg_self_ = self.as_raw();
                    let arg_path = arg_path.as_raw();
                    let arg_display_name = arg_display_name.as_raw();
                    let result = f(arg_self_, arg_path, arg_display_name);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn clear_filenames<'a>(&self) {
        unsafe {
            self.0
                .clear_filenames
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_image<'a>(&self) -> Image {
        unsafe {
            self.0
                .get_image
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_image_hotspot<'a>(&self) -> Point {
        unsafe {
            self.0
                .get_image_hotspot
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn has_image<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_image
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_drag_data_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for DragData {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_drag_data_t> for &DragData {
    fn as_raw(self) -> *mut _cef_drag_data_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_drag_data_t> for &mut DragData {
    fn as_raw(self) -> *mut _cef_drag_data_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<DragData> for *mut _cef_drag_data_t {
    fn as_wrapper(self) -> DragData {
        DragData(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_drag_data_t> for DragData {
    fn into(self) -> *mut _cef_drag_data_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for DragData {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplDomvisitor: Sized {
    fn visit<'a>(&self, document: &'a mut Domdocument) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_domvisitor_t {
        let mut object: _cef_domvisitor_t = unsafe { std::mem::zeroed() };
        impl_cef_domvisitor_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_domvisitor_t {
    use super::*;
    pub fn init_methods<I: ImplDomvisitor>(object: &mut _cef_domvisitor_t) {
        object.visit = Some(visit::<I>);
    }
    extern "C" fn visit<I: ImplDomvisitor>(
        self_: *mut _cef_domvisitor_t,
        document: *mut _cef_domdocument_t,
    ) {
        let (arg_self_, arg_document) = (self_, document);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_document = &mut Domdocument(unsafe { RefGuard::from_raw_add_ref(arg_document) });
        arg_self_.interface.visit(arg_document)
    }
}
#[doc = "See [_cef_domvisitor_t] for more documentation."]
#[derive(Clone)]
pub struct Domvisitor(RefGuard<_cef_domvisitor_t>);
impl ImplDomvisitor for Domvisitor {
    fn visit<'a>(&self, document: &'a mut Domdocument) {
        unsafe {
            self.0
                .visit
                .map(|f| {
                    let arg_document = document;
                    let arg_self_ = self.as_raw();
                    let arg_document = arg_document.as_raw();
                    let result = f(arg_self_, arg_document);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_domvisitor_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Domvisitor {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_domvisitor_t> for &Domvisitor {
    fn as_raw(self) -> *mut _cef_domvisitor_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_domvisitor_t> for &mut Domvisitor {
    fn as_raw(self) -> *mut _cef_domvisitor_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<Domvisitor> for *mut _cef_domvisitor_t {
    fn as_wrapper(self) -> Domvisitor {
        Domvisitor(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_domvisitor_t> for Domvisitor {
    fn into(self) -> *mut _cef_domvisitor_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for Domvisitor {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplDomdocument: Sized {
    fn get_type<'a>(&self) -> DomDocumentType {
        unsafe { std::mem::zeroed() }
    }
    fn get_document<'a>(&self) -> Domnode {
        unsafe { std::mem::zeroed() }
    }
    fn get_body<'a>(&self) -> Domnode {
        unsafe { std::mem::zeroed() }
    }
    fn get_head<'a>(&self) -> Domnode {
        unsafe { std::mem::zeroed() }
    }
    fn get_title<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_element_by_id<'a>(&self, id: &'a CefStringUtf16) -> Domnode {
        unsafe { std::mem::zeroed() }
    }
    fn get_focused_node<'a>(&self) -> Domnode {
        unsafe { std::mem::zeroed() }
    }
    fn has_selection<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_selection_start_offset<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_selection_end_offset<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_selection_as_markup<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_selection_as_text<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_base_url<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_complete_url<'a>(&self, partial_url: &'a CefStringUtf16) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_domdocument_t {
        let mut object: _cef_domdocument_t = unsafe { std::mem::zeroed() };
        impl_cef_domdocument_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_domdocument_t {
    use super::*;
    pub fn init_methods<I: ImplDomdocument>(object: &mut _cef_domdocument_t) {
        object.get_type = Some(get_type::<I>);
        object.get_document = Some(get_document::<I>);
        object.get_body = Some(get_body::<I>);
        object.get_head = Some(get_head::<I>);
        object.get_title = Some(get_title::<I>);
        object.get_element_by_id = Some(get_element_by_id::<I>);
        object.get_focused_node = Some(get_focused_node::<I>);
        object.has_selection = Some(has_selection::<I>);
        object.get_selection_start_offset = Some(get_selection_start_offset::<I>);
        object.get_selection_end_offset = Some(get_selection_end_offset::<I>);
        object.get_selection_as_markup = Some(get_selection_as_markup::<I>);
        object.get_selection_as_text = Some(get_selection_as_text::<I>);
        object.get_base_url = Some(get_base_url::<I>);
        object.get_complete_url = Some(get_complete_url::<I>);
    }
    extern "C" fn get_type<I: ImplDomdocument>(
        self_: *mut _cef_domdocument_t,
    ) -> cef_dom_document_type_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_type().into()
    }
    extern "C" fn get_document<I: ImplDomdocument>(
        self_: *mut _cef_domdocument_t,
    ) -> *mut _cef_domnode_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_document().into()
    }
    extern "C" fn get_body<I: ImplDomdocument>(
        self_: *mut _cef_domdocument_t,
    ) -> *mut _cef_domnode_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_body().into()
    }
    extern "C" fn get_head<I: ImplDomdocument>(
        self_: *mut _cef_domdocument_t,
    ) -> *mut _cef_domnode_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_head().into()
    }
    extern "C" fn get_title<I: ImplDomdocument>(
        self_: *mut _cef_domdocument_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_title().into()
    }
    extern "C" fn get_element_by_id<I: ImplDomdocument>(
        self_: *mut _cef_domdocument_t,
        id: *const _cef_string_utf16_t,
    ) -> *mut _cef_domnode_t {
        let (arg_self_, arg_id) = (self_, id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_id = WrapParamRef::<CefStringUtf16>::from(arg_id);
        let arg_id = arg_id.as_ref();
        arg_self_.interface.get_element_by_id(arg_id).into()
    }
    extern "C" fn get_focused_node<I: ImplDomdocument>(
        self_: *mut _cef_domdocument_t,
    ) -> *mut _cef_domnode_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_focused_node().into()
    }
    extern "C" fn has_selection<I: ImplDomdocument>(
        self_: *mut _cef_domdocument_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.has_selection().into()
    }
    extern "C" fn get_selection_start_offset<I: ImplDomdocument>(
        self_: *mut _cef_domdocument_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_selection_start_offset().into()
    }
    extern "C" fn get_selection_end_offset<I: ImplDomdocument>(
        self_: *mut _cef_domdocument_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_selection_end_offset().into()
    }
    extern "C" fn get_selection_as_markup<I: ImplDomdocument>(
        self_: *mut _cef_domdocument_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_selection_as_markup().into()
    }
    extern "C" fn get_selection_as_text<I: ImplDomdocument>(
        self_: *mut _cef_domdocument_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_selection_as_text().into()
    }
    extern "C" fn get_base_url<I: ImplDomdocument>(
        self_: *mut _cef_domdocument_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_base_url().into()
    }
    extern "C" fn get_complete_url<I: ImplDomdocument>(
        self_: *mut _cef_domdocument_t,
        partial_url: *const _cef_string_utf16_t,
    ) -> *mut _cef_string_utf16_t {
        let (arg_self_, arg_partial_url) = (self_, partial_url);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_partial_url = WrapParamRef::<CefStringUtf16>::from(arg_partial_url);
        let arg_partial_url = arg_partial_url.as_ref();
        arg_self_.interface.get_complete_url(arg_partial_url).into()
    }
}
#[doc = "See [_cef_domdocument_t] for more documentation."]
#[derive(Clone)]
pub struct Domdocument(RefGuard<_cef_domdocument_t>);
impl ImplDomdocument for Domdocument {
    fn get_type<'a>(&self) -> DomDocumentType {
        unsafe {
            self.0
                .get_type
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_document<'a>(&self) -> Domnode {
        unsafe {
            self.0
                .get_document
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_body<'a>(&self) -> Domnode {
        unsafe {
            self.0
                .get_body
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_head<'a>(&self) -> Domnode {
        unsafe {
            self.0
                .get_head
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_title<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_title
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_element_by_id<'a>(&self, id: &'a CefStringUtf16) -> Domnode {
        unsafe {
            self.0
                .get_element_by_id
                .map(|f| {
                    let arg_id = id;
                    let arg_self_ = self.as_raw();
                    let arg_id = arg_id.as_raw();
                    let result = f(arg_self_, arg_id);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_focused_node<'a>(&self) -> Domnode {
        unsafe {
            self.0
                .get_focused_node
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn has_selection<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_selection
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_selection_start_offset<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_selection_start_offset
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_selection_end_offset<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_selection_end_offset
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_selection_as_markup<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_selection_as_markup
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_selection_as_text<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_selection_as_text
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_base_url<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_base_url
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_complete_url<'a>(&self, partial_url: &'a CefStringUtf16) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_complete_url
                .map(|f| {
                    let arg_partial_url = partial_url;
                    let arg_self_ = self.as_raw();
                    let arg_partial_url = arg_partial_url.as_raw();
                    let result = f(arg_self_, arg_partial_url);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_domdocument_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Domdocument {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_domdocument_t> for &Domdocument {
    fn as_raw(self) -> *mut _cef_domdocument_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_domdocument_t> for &mut Domdocument {
    fn as_raw(self) -> *mut _cef_domdocument_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<Domdocument> for *mut _cef_domdocument_t {
    fn as_wrapper(self) -> Domdocument {
        Domdocument(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_domdocument_t> for Domdocument {
    fn into(self) -> *mut _cef_domdocument_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for Domdocument {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplDomnode: Sized {
    fn get_type<'a>(&self) -> DomNodeType {
        unsafe { std::mem::zeroed() }
    }
    fn is_text<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_element<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_editable<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_form_control_element<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_form_control_element_type<'a>(&self) -> DomFormControlType {
        unsafe { std::mem::zeroed() }
    }
    fn is_same<'a>(&self, that: &'a mut Domnode) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_name<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_value<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn set_value<'a>(&self, value: &'a CefStringUtf16) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_as_markup<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_document<'a>(&self) -> Domdocument {
        unsafe { std::mem::zeroed() }
    }
    fn get_parent<'a>(&self) -> Domnode {
        unsafe { std::mem::zeroed() }
    }
    fn get_previous_sibling<'a>(&self) -> Domnode {
        unsafe { std::mem::zeroed() }
    }
    fn get_next_sibling<'a>(&self) -> Domnode {
        unsafe { std::mem::zeroed() }
    }
    fn has_children<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_first_child<'a>(&self) -> Domnode {
        unsafe { std::mem::zeroed() }
    }
    fn get_last_child<'a>(&self) -> Domnode {
        unsafe { std::mem::zeroed() }
    }
    fn get_element_tag_name<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn has_element_attributes<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn has_element_attribute<'a>(&self, attr_name: &'a CefStringUtf16) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_element_attribute<'a>(&self, attr_name: &'a CefStringUtf16) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_element_attributes<'a>(&self, attr_map: &'a mut CefStringMap) {
        unsafe { std::mem::zeroed() }
    }
    fn set_element_attribute<'a>(
        &self,
        attr_name: &'a CefStringUtf16,
        value: &'a CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_element_inner_text<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_element_bounds<'a>(&self) -> Rect {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_domnode_t {
        let mut object: _cef_domnode_t = unsafe { std::mem::zeroed() };
        impl_cef_domnode_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_domnode_t {
    use super::*;
    pub fn init_methods<I: ImplDomnode>(object: &mut _cef_domnode_t) {
        object.get_type = Some(get_type::<I>);
        object.is_text = Some(is_text::<I>);
        object.is_element = Some(is_element::<I>);
        object.is_editable = Some(is_editable::<I>);
        object.is_form_control_element = Some(is_form_control_element::<I>);
        object.get_form_control_element_type = Some(get_form_control_element_type::<I>);
        object.is_same = Some(is_same::<I>);
        object.get_name = Some(get_name::<I>);
        object.get_value = Some(get_value::<I>);
        object.set_value = Some(set_value::<I>);
        object.get_as_markup = Some(get_as_markup::<I>);
        object.get_document = Some(get_document::<I>);
        object.get_parent = Some(get_parent::<I>);
        object.get_previous_sibling = Some(get_previous_sibling::<I>);
        object.get_next_sibling = Some(get_next_sibling::<I>);
        object.has_children = Some(has_children::<I>);
        object.get_first_child = Some(get_first_child::<I>);
        object.get_last_child = Some(get_last_child::<I>);
        object.get_element_tag_name = Some(get_element_tag_name::<I>);
        object.has_element_attributes = Some(has_element_attributes::<I>);
        object.has_element_attribute = Some(has_element_attribute::<I>);
        object.get_element_attribute = Some(get_element_attribute::<I>);
        object.get_element_attributes = Some(get_element_attributes::<I>);
        object.set_element_attribute = Some(set_element_attribute::<I>);
        object.get_element_inner_text = Some(get_element_inner_text::<I>);
        object.get_element_bounds = Some(get_element_bounds::<I>);
    }
    extern "C" fn get_type<I: ImplDomnode>(self_: *mut _cef_domnode_t) -> cef_dom_node_type_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_type().into()
    }
    extern "C" fn is_text<I: ImplDomnode>(self_: *mut _cef_domnode_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_text().into()
    }
    extern "C" fn is_element<I: ImplDomnode>(self_: *mut _cef_domnode_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_element().into()
    }
    extern "C" fn is_editable<I: ImplDomnode>(self_: *mut _cef_domnode_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_editable().into()
    }
    extern "C" fn is_form_control_element<I: ImplDomnode>(
        self_: *mut _cef_domnode_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_form_control_element().into()
    }
    extern "C" fn get_form_control_element_type<I: ImplDomnode>(
        self_: *mut _cef_domnode_t,
    ) -> cef_dom_form_control_type_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_form_control_element_type().into()
    }
    extern "C" fn is_same<I: ImplDomnode>(
        self_: *mut _cef_domnode_t,
        that: *mut _cef_domnode_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_that) = (self_, that);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_that = &mut Domnode(unsafe { RefGuard::from_raw_add_ref(arg_that) });
        arg_self_.interface.is_same(arg_that).into()
    }
    extern "C" fn get_name<I: ImplDomnode>(self_: *mut _cef_domnode_t) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_name().into()
    }
    extern "C" fn get_value<I: ImplDomnode>(
        self_: *mut _cef_domnode_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_value().into()
    }
    extern "C" fn set_value<I: ImplDomnode>(
        self_: *mut _cef_domnode_t,
        value: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_value) = (self_, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_value = WrapParamRef::<CefStringUtf16>::from(arg_value);
        let arg_value = arg_value.as_ref();
        arg_self_.interface.set_value(arg_value).into()
    }
    extern "C" fn get_as_markup<I: ImplDomnode>(
        self_: *mut _cef_domnode_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_as_markup().into()
    }
    extern "C" fn get_document<I: ImplDomnode>(
        self_: *mut _cef_domnode_t,
    ) -> *mut _cef_domdocument_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_document().into()
    }
    extern "C" fn get_parent<I: ImplDomnode>(self_: *mut _cef_domnode_t) -> *mut _cef_domnode_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_parent().into()
    }
    extern "C" fn get_previous_sibling<I: ImplDomnode>(
        self_: *mut _cef_domnode_t,
    ) -> *mut _cef_domnode_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_previous_sibling().into()
    }
    extern "C" fn get_next_sibling<I: ImplDomnode>(
        self_: *mut _cef_domnode_t,
    ) -> *mut _cef_domnode_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_next_sibling().into()
    }
    extern "C" fn has_children<I: ImplDomnode>(
        self_: *mut _cef_domnode_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.has_children().into()
    }
    extern "C" fn get_first_child<I: ImplDomnode>(
        self_: *mut _cef_domnode_t,
    ) -> *mut _cef_domnode_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_first_child().into()
    }
    extern "C" fn get_last_child<I: ImplDomnode>(
        self_: *mut _cef_domnode_t,
    ) -> *mut _cef_domnode_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_last_child().into()
    }
    extern "C" fn get_element_tag_name<I: ImplDomnode>(
        self_: *mut _cef_domnode_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_element_tag_name().into()
    }
    extern "C" fn has_element_attributes<I: ImplDomnode>(
        self_: *mut _cef_domnode_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.has_element_attributes().into()
    }
    extern "C" fn has_element_attribute<I: ImplDomnode>(
        self_: *mut _cef_domnode_t,
        attr_name: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_attr_name) = (self_, attr_name);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_attr_name = WrapParamRef::<CefStringUtf16>::from(arg_attr_name);
        let arg_attr_name = arg_attr_name.as_ref();
        arg_self_
            .interface
            .has_element_attribute(arg_attr_name)
            .into()
    }
    extern "C" fn get_element_attribute<I: ImplDomnode>(
        self_: *mut _cef_domnode_t,
        attr_name: *const _cef_string_utf16_t,
    ) -> *mut _cef_string_utf16_t {
        let (arg_self_, arg_attr_name) = (self_, attr_name);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_attr_name = WrapParamRef::<CefStringUtf16>::from(arg_attr_name);
        let arg_attr_name = arg_attr_name.as_ref();
        arg_self_
            .interface
            .get_element_attribute(arg_attr_name)
            .into()
    }
    extern "C" fn get_element_attributes<I: ImplDomnode>(
        self_: *mut _cef_domnode_t,
        attr_map: *mut _cef_string_map_t,
    ) {
        let (arg_self_, arg_attr_map) = (self_, attr_map);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_attr_map = WrapParamRef::<CefStringMap>::from(arg_attr_map);
        let arg_attr_map = arg_attr_map.as_mut();
        arg_self_.interface.get_element_attributes(arg_attr_map)
    }
    extern "C" fn set_element_attribute<I: ImplDomnode>(
        self_: *mut _cef_domnode_t,
        attr_name: *const _cef_string_utf16_t,
        value: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_attr_name, arg_value) = (self_, attr_name, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_attr_name = WrapParamRef::<CefStringUtf16>::from(arg_attr_name);
        let arg_attr_name = arg_attr_name.as_ref();
        let arg_value = WrapParamRef::<CefStringUtf16>::from(arg_value);
        let arg_value = arg_value.as_ref();
        arg_self_
            .interface
            .set_element_attribute(arg_attr_name, arg_value)
            .into()
    }
    extern "C" fn get_element_inner_text<I: ImplDomnode>(
        self_: *mut _cef_domnode_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_element_inner_text().into()
    }
    extern "C" fn get_element_bounds<I: ImplDomnode>(self_: *mut _cef_domnode_t) -> _cef_rect_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_element_bounds().into()
    }
}
#[doc = "See [_cef_domnode_t] for more documentation."]
#[derive(Clone)]
pub struct Domnode(RefGuard<_cef_domnode_t>);
impl ImplDomnode for Domnode {
    fn get_type<'a>(&self) -> DomNodeType {
        unsafe {
            self.0
                .get_type
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_text<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_text
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_element<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_element
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_editable<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_editable
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_form_control_element<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_form_control_element
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_form_control_element_type<'a>(&self) -> DomFormControlType {
        unsafe {
            self.0
                .get_form_control_element_type
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_same<'a>(&self, that: &'a mut Domnode) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_same
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.as_raw();
                    let arg_that = arg_that.as_raw();
                    let result = f(arg_self_, arg_that);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_name<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_name
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_value<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_value
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_value<'a>(&self, value: &'a CefStringUtf16) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_value
                .map(|f| {
                    let arg_value = value;
                    let arg_self_ = self.as_raw();
                    let arg_value = arg_value.as_raw();
                    let result = f(arg_self_, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_as_markup<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_as_markup
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_document<'a>(&self) -> Domdocument {
        unsafe {
            self.0
                .get_document
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_parent<'a>(&self) -> Domnode {
        unsafe {
            self.0
                .get_parent
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_previous_sibling<'a>(&self) -> Domnode {
        unsafe {
            self.0
                .get_previous_sibling
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_next_sibling<'a>(&self) -> Domnode {
        unsafe {
            self.0
                .get_next_sibling
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn has_children<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_children
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_first_child<'a>(&self) -> Domnode {
        unsafe {
            self.0
                .get_first_child
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_last_child<'a>(&self) -> Domnode {
        unsafe {
            self.0
                .get_last_child
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_element_tag_name<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_element_tag_name
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn has_element_attributes<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_element_attributes
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn has_element_attribute<'a>(&self, attr_name: &'a CefStringUtf16) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_element_attribute
                .map(|f| {
                    let arg_attr_name = attr_name;
                    let arg_self_ = self.as_raw();
                    let arg_attr_name = arg_attr_name.as_raw();
                    let result = f(arg_self_, arg_attr_name);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_element_attribute<'a>(&self, attr_name: &'a CefStringUtf16) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_element_attribute
                .map(|f| {
                    let arg_attr_name = attr_name;
                    let arg_self_ = self.as_raw();
                    let arg_attr_name = arg_attr_name.as_raw();
                    let result = f(arg_self_, arg_attr_name);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_element_attributes<'a>(&self, attr_map: &'a mut CefStringMap) {
        unsafe {
            self.0
                .get_element_attributes
                .map(|f| {
                    let arg_attr_map = attr_map;
                    let arg_self_ = self.as_raw();
                    let arg_attr_map = arg_attr_map.as_raw();
                    let result = f(arg_self_, arg_attr_map);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_element_attribute<'a>(
        &self,
        attr_name: &'a CefStringUtf16,
        value: &'a CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_element_attribute
                .map(|f| {
                    let (arg_attr_name, arg_value) = (attr_name, value);
                    let arg_self_ = self.as_raw();
                    let arg_attr_name = arg_attr_name.as_raw();
                    let arg_value = arg_value.as_raw();
                    let result = f(arg_self_, arg_attr_name, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_element_inner_text<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_element_inner_text
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_element_bounds<'a>(&self) -> Rect {
        unsafe {
            self.0
                .get_element_bounds
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_domnode_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Domnode {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_domnode_t> for &Domnode {
    fn as_raw(self) -> *mut _cef_domnode_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_domnode_t> for &mut Domnode {
    fn as_raw(self) -> *mut _cef_domnode_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<Domnode> for *mut _cef_domnode_t {
    fn as_wrapper(self) -> Domnode {
        Domnode(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_domnode_t> for Domnode {
    fn into(self) -> *mut _cef_domnode_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for Domnode {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplSharedMemoryRegion: Sized {
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn size<'a>(&self) -> usize {
        unsafe { std::mem::zeroed() }
    }
    fn memory<'a>(&self) -> *mut ::std::os::raw::c_void {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_shared_memory_region_t {
        let mut object: _cef_shared_memory_region_t = unsafe { std::mem::zeroed() };
        impl_cef_shared_memory_region_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_shared_memory_region_t {
    use super::*;
    pub fn init_methods<I: ImplSharedMemoryRegion>(object: &mut _cef_shared_memory_region_t) {
        object.is_valid = Some(is_valid::<I>);
        object.size = Some(size::<I>);
        object.memory = Some(memory::<I>);
    }
    extern "C" fn is_valid<I: ImplSharedMemoryRegion>(
        self_: *mut _cef_shared_memory_region_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_valid().into()
    }
    extern "C" fn size<I: ImplSharedMemoryRegion>(
        self_: *mut _cef_shared_memory_region_t,
    ) -> usize {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.size().into()
    }
    extern "C" fn memory<I: ImplSharedMemoryRegion>(
        self_: *mut _cef_shared_memory_region_t,
    ) -> *mut ::std::os::raw::c_void {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.memory().into()
    }
}
#[doc = "See [_cef_shared_memory_region_t] for more documentation."]
#[derive(Clone)]
pub struct SharedMemoryRegion(RefGuard<_cef_shared_memory_region_t>);
impl ImplSharedMemoryRegion for SharedMemoryRegion {
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn size<'a>(&self) -> usize {
        unsafe {
            self.0
                .size
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn memory<'a>(&self) -> *mut ::std::os::raw::c_void {
        unsafe {
            self.0
                .memory
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_shared_memory_region_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for SharedMemoryRegion {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_shared_memory_region_t> for &SharedMemoryRegion {
    fn as_raw(self) -> *mut _cef_shared_memory_region_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_shared_memory_region_t> for &mut SharedMemoryRegion {
    fn as_raw(self) -> *mut _cef_shared_memory_region_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<SharedMemoryRegion> for *mut _cef_shared_memory_region_t {
    fn as_wrapper(self) -> SharedMemoryRegion {
        SharedMemoryRegion(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_shared_memory_region_t> for SharedMemoryRegion {
    fn into(self) -> *mut _cef_shared_memory_region_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for SharedMemoryRegion {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplProcessMessage: Sized {
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_read_only<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn copy<'a>(&self) -> ProcessMessage {
        unsafe { std::mem::zeroed() }
    }
    fn get_name<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_argument_list<'a>(&self) -> ListValue {
        unsafe { std::mem::zeroed() }
    }
    fn get_shared_memory_region<'a>(&self) -> SharedMemoryRegion {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_process_message_t {
        let mut object: _cef_process_message_t = unsafe { std::mem::zeroed() };
        impl_cef_process_message_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_process_message_t {
    use super::*;
    pub fn init_methods<I: ImplProcessMessage>(object: &mut _cef_process_message_t) {
        object.is_valid = Some(is_valid::<I>);
        object.is_read_only = Some(is_read_only::<I>);
        object.copy = Some(copy::<I>);
        object.get_name = Some(get_name::<I>);
        object.get_argument_list = Some(get_argument_list::<I>);
        object.get_shared_memory_region = Some(get_shared_memory_region::<I>);
    }
    extern "C" fn is_valid<I: ImplProcessMessage>(
        self_: *mut _cef_process_message_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_valid().into()
    }
    extern "C" fn is_read_only<I: ImplProcessMessage>(
        self_: *mut _cef_process_message_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_read_only().into()
    }
    extern "C" fn copy<I: ImplProcessMessage>(
        self_: *mut _cef_process_message_t,
    ) -> *mut _cef_process_message_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.copy().into()
    }
    extern "C" fn get_name<I: ImplProcessMessage>(
        self_: *mut _cef_process_message_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_name().into()
    }
    extern "C" fn get_argument_list<I: ImplProcessMessage>(
        self_: *mut _cef_process_message_t,
    ) -> *mut _cef_list_value_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_argument_list().into()
    }
    extern "C" fn get_shared_memory_region<I: ImplProcessMessage>(
        self_: *mut _cef_process_message_t,
    ) -> *mut _cef_shared_memory_region_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_shared_memory_region().into()
    }
}
#[doc = "See [_cef_process_message_t] for more documentation."]
#[derive(Clone)]
pub struct ProcessMessage(RefGuard<_cef_process_message_t>);
impl ImplProcessMessage for ProcessMessage {
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_read_only<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_read_only
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn copy<'a>(&self) -> ProcessMessage {
        unsafe {
            self.0
                .copy
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_name<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_name
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_argument_list<'a>(&self) -> ListValue {
        unsafe {
            self.0
                .get_argument_list
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_shared_memory_region<'a>(&self) -> SharedMemoryRegion {
        unsafe {
            self.0
                .get_shared_memory_region
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_process_message_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ProcessMessage {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_process_message_t> for &ProcessMessage {
    fn as_raw(self) -> *mut _cef_process_message_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_process_message_t> for &mut ProcessMessage {
    fn as_raw(self) -> *mut _cef_process_message_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<ProcessMessage> for *mut _cef_process_message_t {
    fn as_wrapper(self) -> ProcessMessage {
        ProcessMessage(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_process_message_t> for ProcessMessage {
    fn into(self) -> *mut _cef_process_message_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for ProcessMessage {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplRequest: Sized {
    fn is_read_only<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_url<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn set_url<'a>(&self, url: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn get_method<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn set_method<'a>(&self, method: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn set_referrer<'a>(&self, referrer_url: &'a CefStringUtf16, policy: ReferrerPolicy) {
        unsafe { std::mem::zeroed() }
    }
    fn get_referrer_url<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_referrer_policy<'a>(&self) -> ReferrerPolicy {
        unsafe { std::mem::zeroed() }
    }
    fn get_post_data<'a>(&self) -> PostData {
        unsafe { std::mem::zeroed() }
    }
    fn set_post_data<'a>(&self, post_data: &'a mut PostData) {
        unsafe { std::mem::zeroed() }
    }
    fn get_header_map<'a>(&self, header_map: &'a mut CefStringMultimap) {
        unsafe { std::mem::zeroed() }
    }
    fn set_header_map<'a>(&self, header_map: &'a mut CefStringMultimap) {
        unsafe { std::mem::zeroed() }
    }
    fn get_header_by_name<'a>(&self, name: &'a CefStringUtf16) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn set_header_by_name<'a>(
        &self,
        name: &'a CefStringUtf16,
        value: &'a CefStringUtf16,
        overwrite: ::std::os::raw::c_int,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn set<'a>(
        &self,
        url: &'a CefStringUtf16,
        method: &'a CefStringUtf16,
        post_data: &'a mut PostData,
        header_map: &'a mut CefStringMultimap,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn get_flags<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_flags<'a>(&self, flags: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn get_first_party_for_cookies<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn set_first_party_for_cookies<'a>(&self, url: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn get_resource_type<'a>(&self) -> ResourceType {
        unsafe { std::mem::zeroed() }
    }
    fn get_transition_type<'a>(&self) -> TransitionType {
        unsafe { std::mem::zeroed() }
    }
    fn get_identifier<'a>(&self) -> u64 {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_request_t {
        let mut object: _cef_request_t = unsafe { std::mem::zeroed() };
        impl_cef_request_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_request_t {
    use super::*;
    pub fn init_methods<I: ImplRequest>(object: &mut _cef_request_t) {
        object.is_read_only = Some(is_read_only::<I>);
        object.get_url = Some(get_url::<I>);
        object.set_url = Some(set_url::<I>);
        object.get_method = Some(get_method::<I>);
        object.set_method = Some(set_method::<I>);
        object.set_referrer = Some(set_referrer::<I>);
        object.get_referrer_url = Some(get_referrer_url::<I>);
        object.get_referrer_policy = Some(get_referrer_policy::<I>);
        object.get_post_data = Some(get_post_data::<I>);
        object.set_post_data = Some(set_post_data::<I>);
        object.get_header_map = Some(get_header_map::<I>);
        object.set_header_map = Some(set_header_map::<I>);
        object.get_header_by_name = Some(get_header_by_name::<I>);
        object.set_header_by_name = Some(set_header_by_name::<I>);
        object.set = Some(set::<I>);
        object.get_flags = Some(get_flags::<I>);
        object.set_flags = Some(set_flags::<I>);
        object.get_first_party_for_cookies = Some(get_first_party_for_cookies::<I>);
        object.set_first_party_for_cookies = Some(set_first_party_for_cookies::<I>);
        object.get_resource_type = Some(get_resource_type::<I>);
        object.get_transition_type = Some(get_transition_type::<I>);
        object.get_identifier = Some(get_identifier::<I>);
    }
    extern "C" fn is_read_only<I: ImplRequest>(
        self_: *mut _cef_request_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_read_only().into()
    }
    extern "C" fn get_url<I: ImplRequest>(self_: *mut _cef_request_t) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_url().into()
    }
    extern "C" fn set_url<I: ImplRequest>(
        self_: *mut _cef_request_t,
        url: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_url) = (self_, url);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_url = WrapParamRef::<CefStringUtf16>::from(arg_url);
        let arg_url = arg_url.as_ref();
        arg_self_.interface.set_url(arg_url)
    }
    extern "C" fn get_method<I: ImplRequest>(
        self_: *mut _cef_request_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_method().into()
    }
    extern "C" fn set_method<I: ImplRequest>(
        self_: *mut _cef_request_t,
        method: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_method) = (self_, method);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_method = WrapParamRef::<CefStringUtf16>::from(arg_method);
        let arg_method = arg_method.as_ref();
        arg_self_.interface.set_method(arg_method)
    }
    extern "C" fn set_referrer<I: ImplRequest>(
        self_: *mut _cef_request_t,
        referrer_url: *const _cef_string_utf16_t,
        policy: cef_referrer_policy_t,
    ) {
        let (arg_self_, arg_referrer_url, arg_policy) = (self_, referrer_url, policy);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_referrer_url = WrapParamRef::<CefStringUtf16>::from(arg_referrer_url);
        let arg_referrer_url = arg_referrer_url.as_ref();
        let arg_policy = arg_policy.as_raw();
        arg_self_
            .interface
            .set_referrer(arg_referrer_url, arg_policy)
    }
    extern "C" fn get_referrer_url<I: ImplRequest>(
        self_: *mut _cef_request_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_referrer_url().into()
    }
    extern "C" fn get_referrer_policy<I: ImplRequest>(
        self_: *mut _cef_request_t,
    ) -> cef_referrer_policy_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_referrer_policy().into()
    }
    extern "C" fn get_post_data<I: ImplRequest>(
        self_: *mut _cef_request_t,
    ) -> *mut _cef_post_data_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_post_data().into()
    }
    extern "C" fn set_post_data<I: ImplRequest>(
        self_: *mut _cef_request_t,
        post_data: *mut _cef_post_data_t,
    ) {
        let (arg_self_, arg_post_data) = (self_, post_data);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_post_data = &mut PostData(unsafe { RefGuard::from_raw_add_ref(arg_post_data) });
        arg_self_.interface.set_post_data(arg_post_data)
    }
    extern "C" fn get_header_map<I: ImplRequest>(
        self_: *mut _cef_request_t,
        header_map: *mut _cef_string_multimap_t,
    ) {
        let (arg_self_, arg_header_map) = (self_, header_map);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_header_map = WrapParamRef::<CefStringMultimap>::from(arg_header_map);
        let arg_header_map = arg_header_map.as_mut();
        arg_self_.interface.get_header_map(arg_header_map)
    }
    extern "C" fn set_header_map<I: ImplRequest>(
        self_: *mut _cef_request_t,
        header_map: *mut _cef_string_multimap_t,
    ) {
        let (arg_self_, arg_header_map) = (self_, header_map);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_header_map = WrapParamRef::<CefStringMultimap>::from(arg_header_map);
        let arg_header_map = arg_header_map.as_mut();
        arg_self_.interface.set_header_map(arg_header_map)
    }
    extern "C" fn get_header_by_name<I: ImplRequest>(
        self_: *mut _cef_request_t,
        name: *const _cef_string_utf16_t,
    ) -> *mut _cef_string_utf16_t {
        let (arg_self_, arg_name) = (self_, name);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = WrapParamRef::<CefStringUtf16>::from(arg_name);
        let arg_name = arg_name.as_ref();
        arg_self_.interface.get_header_by_name(arg_name).into()
    }
    extern "C" fn set_header_by_name<I: ImplRequest>(
        self_: *mut _cef_request_t,
        name: *const _cef_string_utf16_t,
        value: *const _cef_string_utf16_t,
        overwrite: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_name, arg_value, arg_overwrite) = (self_, name, value, overwrite);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = WrapParamRef::<CefStringUtf16>::from(arg_name);
        let arg_name = arg_name.as_ref();
        let arg_value = WrapParamRef::<CefStringUtf16>::from(arg_value);
        let arg_value = arg_value.as_ref();
        let arg_overwrite = arg_overwrite.as_raw();
        arg_self_
            .interface
            .set_header_by_name(arg_name, arg_value, arg_overwrite)
    }
    extern "C" fn set<I: ImplRequest>(
        self_: *mut _cef_request_t,
        url: *const _cef_string_utf16_t,
        method: *const _cef_string_utf16_t,
        post_data: *mut _cef_post_data_t,
        header_map: *mut _cef_string_multimap_t,
    ) {
        let (arg_self_, arg_url, arg_method, arg_post_data, arg_header_map) =
            (self_, url, method, post_data, header_map);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_url = WrapParamRef::<CefStringUtf16>::from(arg_url);
        let arg_url = arg_url.as_ref();
        let arg_method = WrapParamRef::<CefStringUtf16>::from(arg_method);
        let arg_method = arg_method.as_ref();
        let arg_post_data = &mut PostData(unsafe { RefGuard::from_raw_add_ref(arg_post_data) });
        let mut arg_header_map = WrapParamRef::<CefStringMultimap>::from(arg_header_map);
        let arg_header_map = arg_header_map.as_mut();
        arg_self_
            .interface
            .set(arg_url, arg_method, arg_post_data, arg_header_map)
    }
    extern "C" fn get_flags<I: ImplRequest>(self_: *mut _cef_request_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_flags().into()
    }
    extern "C" fn set_flags<I: ImplRequest>(
        self_: *mut _cef_request_t,
        flags: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_flags) = (self_, flags);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_flags = arg_flags.as_raw();
        arg_self_.interface.set_flags(arg_flags)
    }
    extern "C" fn get_first_party_for_cookies<I: ImplRequest>(
        self_: *mut _cef_request_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_first_party_for_cookies().into()
    }
    extern "C" fn set_first_party_for_cookies<I: ImplRequest>(
        self_: *mut _cef_request_t,
        url: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_url) = (self_, url);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_url = WrapParamRef::<CefStringUtf16>::from(arg_url);
        let arg_url = arg_url.as_ref();
        arg_self_.interface.set_first_party_for_cookies(arg_url)
    }
    extern "C" fn get_resource_type<I: ImplRequest>(
        self_: *mut _cef_request_t,
    ) -> cef_resource_type_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_resource_type().into()
    }
    extern "C" fn get_transition_type<I: ImplRequest>(
        self_: *mut _cef_request_t,
    ) -> cef_transition_type_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_transition_type().into()
    }
    extern "C" fn get_identifier<I: ImplRequest>(self_: *mut _cef_request_t) -> u64 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_identifier().into()
    }
}
#[doc = "See [_cef_request_t] for more documentation."]
#[derive(Clone)]
pub struct Request(RefGuard<_cef_request_t>);
impl ImplRequest for Request {
    fn is_read_only<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_read_only
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_url<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_url
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_url<'a>(&self, url: &'a CefStringUtf16) {
        unsafe {
            self.0
                .set_url
                .map(|f| {
                    let arg_url = url;
                    let arg_self_ = self.as_raw();
                    let arg_url = arg_url.as_raw();
                    let result = f(arg_self_, arg_url);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_method<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_method
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_method<'a>(&self, method: &'a CefStringUtf16) {
        unsafe {
            self.0
                .set_method
                .map(|f| {
                    let arg_method = method;
                    let arg_self_ = self.as_raw();
                    let arg_method = arg_method.as_raw();
                    let result = f(arg_self_, arg_method);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_referrer<'a>(&self, referrer_url: &'a CefStringUtf16, policy: ReferrerPolicy) {
        unsafe {
            self.0
                .set_referrer
                .map(|f| {
                    let (arg_referrer_url, arg_policy) = (referrer_url, policy);
                    let arg_self_ = self.as_raw();
                    let arg_referrer_url = arg_referrer_url.as_raw();
                    let arg_policy = arg_policy.as_raw();
                    let result = f(arg_self_, arg_referrer_url, arg_policy);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_referrer_url<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_referrer_url
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_referrer_policy<'a>(&self) -> ReferrerPolicy {
        unsafe {
            self.0
                .get_referrer_policy
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_post_data<'a>(&self) -> PostData {
        unsafe {
            self.0
                .get_post_data
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_post_data<'a>(&self, post_data: &'a mut PostData) {
        unsafe {
            self.0
                .set_post_data
                .map(|f| {
                    let arg_post_data = post_data;
                    let arg_self_ = self.as_raw();
                    let arg_post_data = arg_post_data.as_raw();
                    let result = f(arg_self_, arg_post_data);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_header_map<'a>(&self, header_map: &'a mut CefStringMultimap) {
        unsafe {
            self.0
                .get_header_map
                .map(|f| {
                    let arg_header_map = header_map;
                    let arg_self_ = self.as_raw();
                    let arg_header_map = arg_header_map.as_raw();
                    let result = f(arg_self_, arg_header_map);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_header_map<'a>(&self, header_map: &'a mut CefStringMultimap) {
        unsafe {
            self.0
                .set_header_map
                .map(|f| {
                    let arg_header_map = header_map;
                    let arg_self_ = self.as_raw();
                    let arg_header_map = arg_header_map.as_raw();
                    let result = f(arg_self_, arg_header_map);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_header_by_name<'a>(&self, name: &'a CefStringUtf16) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_header_by_name
                .map(|f| {
                    let arg_name = name;
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.as_raw();
                    let result = f(arg_self_, arg_name);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_header_by_name<'a>(
        &self,
        name: &'a CefStringUtf16,
        value: &'a CefStringUtf16,
        overwrite: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .set_header_by_name
                .map(|f| {
                    let (arg_name, arg_value, arg_overwrite) = (name, value, overwrite);
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.as_raw();
                    let arg_value = arg_value.as_raw();
                    let arg_overwrite = arg_overwrite;
                    let result = f(arg_self_, arg_name, arg_value, arg_overwrite);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set<'a>(
        &self,
        url: &'a CefStringUtf16,
        method: &'a CefStringUtf16,
        post_data: &'a mut PostData,
        header_map: &'a mut CefStringMultimap,
    ) {
        unsafe {
            self.0
                .set
                .map(|f| {
                    let (arg_url, arg_method, arg_post_data, arg_header_map) =
                        (url, method, post_data, header_map);
                    let arg_self_ = self.as_raw();
                    let arg_url = arg_url.as_raw();
                    let arg_method = arg_method.as_raw();
                    let arg_post_data = arg_post_data.as_raw();
                    let arg_header_map = arg_header_map.as_raw();
                    let result = f(
                        arg_self_,
                        arg_url,
                        arg_method,
                        arg_post_data,
                        arg_header_map,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_flags<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_flags
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_flags<'a>(&self, flags: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_flags
                .map(|f| {
                    let arg_flags = flags;
                    let arg_self_ = self.as_raw();
                    let arg_flags = arg_flags;
                    let result = f(arg_self_, arg_flags);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_first_party_for_cookies<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_first_party_for_cookies
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_first_party_for_cookies<'a>(&self, url: &'a CefStringUtf16) {
        unsafe {
            self.0
                .set_first_party_for_cookies
                .map(|f| {
                    let arg_url = url;
                    let arg_self_ = self.as_raw();
                    let arg_url = arg_url.as_raw();
                    let result = f(arg_self_, arg_url);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_resource_type<'a>(&self) -> ResourceType {
        unsafe {
            self.0
                .get_resource_type
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_transition_type<'a>(&self) -> TransitionType {
        unsafe {
            self.0
                .get_transition_type
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_identifier<'a>(&self) -> u64 {
        unsafe {
            self.0
                .get_identifier
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_request_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Request {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_request_t> for &Request {
    fn as_raw(self) -> *mut _cef_request_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_request_t> for &mut Request {
    fn as_raw(self) -> *mut _cef_request_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<Request> for *mut _cef_request_t {
    fn as_wrapper(self) -> Request {
        Request(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_request_t> for Request {
    fn into(self) -> *mut _cef_request_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for Request {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplPostData: Sized {
    fn is_read_only<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn has_excluded_elements<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_element_count<'a>(&self) -> usize {
        unsafe { std::mem::zeroed() }
    }
    fn get_elements<'a>(&self, elements: Option<&'a mut &'a mut [Option<PostDataElement>]>) {
        unsafe { std::mem::zeroed() }
    }
    fn remove_element<'a>(&self, element: &'a mut PostDataElement) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn add_element<'a>(&self, element: &'a mut PostDataElement) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn remove_elements<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_post_data_t {
        let mut object: _cef_post_data_t = unsafe { std::mem::zeroed() };
        impl_cef_post_data_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_post_data_t {
    use super::*;
    pub fn init_methods<I: ImplPostData>(object: &mut _cef_post_data_t) {
        object.is_read_only = Some(is_read_only::<I>);
        object.has_excluded_elements = Some(has_excluded_elements::<I>);
        object.get_element_count = Some(get_element_count::<I>);
        object.get_elements = Some(get_elements::<I>);
        object.remove_element = Some(remove_element::<I>);
        object.add_element = Some(add_element::<I>);
        object.remove_elements = Some(remove_elements::<I>);
    }
    extern "C" fn is_read_only<I: ImplPostData>(
        self_: *mut _cef_post_data_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_read_only().into()
    }
    extern "C" fn has_excluded_elements<I: ImplPostData>(
        self_: *mut _cef_post_data_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.has_excluded_elements().into()
    }
    extern "C" fn get_element_count<I: ImplPostData>(self_: *mut _cef_post_data_t) -> usize {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_element_count().into()
    }
    extern "C" fn get_elements<I: ImplPostData>(
        self_: *mut _cef_post_data_t,
        elements_count: *mut usize,
        elements: *mut *mut _cef_post_data_element_t,
    ) {
        let (arg_self_, arg_elements_count, arg_elements) = (self_, elements_count, elements);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut out_elements_count = unsafe { arg_elements_count.as_mut() };
        let arg_elements_count = out_elements_count.map(|count| *count).unwrap_or_default();
        let mut vec_elements = unsafe { arg_elements.as_mut() }.map(|arg| {
            let arg = unsafe {
                std::slice::from_raw_parts_mut(std::ptr::from_mut(arg), arg_elements_count)
            };
            arg.iter_mut()
                .map(|arg| {
                    if arg.is_null() {
                        None
                    } else {
                        Some(PostDataElement(unsafe { RefGuard::from_raw_add_ref(*arg) }))
                    }
                })
                .collect::<Vec<_>>()
        });
        let mut arg_elements = vec_elements.as_mut().map(|arg| arg.as_mut_slice());
        let arg_elements = arg_elements.as_mut();
        arg_self_.interface.get_elements(arg_elements)
    }
    extern "C" fn remove_element<I: ImplPostData>(
        self_: *mut _cef_post_data_t,
        element: *mut _cef_post_data_element_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_element) = (self_, element);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_element = &mut PostDataElement(unsafe { RefGuard::from_raw_add_ref(arg_element) });
        arg_self_.interface.remove_element(arg_element).into()
    }
    extern "C" fn add_element<I: ImplPostData>(
        self_: *mut _cef_post_data_t,
        element: *mut _cef_post_data_element_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_element) = (self_, element);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_element = &mut PostDataElement(unsafe { RefGuard::from_raw_add_ref(arg_element) });
        arg_self_.interface.add_element(arg_element).into()
    }
    extern "C" fn remove_elements<I: ImplPostData>(self_: *mut _cef_post_data_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.remove_elements()
    }
}
#[doc = "See [_cef_post_data_t] for more documentation."]
#[derive(Clone)]
pub struct PostData(RefGuard<_cef_post_data_t>);
impl ImplPostData for PostData {
    fn is_read_only<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_read_only
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn has_excluded_elements<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_excluded_elements
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_element_count<'a>(&self) -> usize {
        unsafe {
            self.0
                .get_element_count
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_elements<'a>(&self, elements: Option<&'a mut &'a mut [Option<PostDataElement>]>) {
        unsafe {
            self.0
                .get_elements
                .map(|f| {
                    let arg_elements = elements;
                    let arg_self_ = self.as_raw();
                    let mut out_elements_count = arg_elements
                        .as_ref()
                        .map(|slice| slice.len())
                        .unwrap_or_default();
                    let arg_elements_count = &mut out_elements_count;
                    let mut out_elements = arg_elements;
                    let arg_elements = &mut out_elements;
                    let mut vec_elements = arg_elements
                        .as_mut()
                        .map(|slice| {
                            slice
                                .iter_mut()
                                .map(|elem| {
                                    elem.as_mut()
                                        .map(|elem| std::mem::take(elem).into_raw())
                                        .unwrap_or(std::ptr::null_mut())
                                })
                                .collect::<Vec<_>>()
                        })
                        .unwrap_or_default();
                    let arg_elements = if vec_elements.is_empty() {
                        std::ptr::null_mut()
                    } else {
                        vec_elements.as_mut_ptr()
                    };
                    let result = f(arg_self_, arg_elements_count, arg_elements);
                    if let Some(out_elements) = out_elements {
                        for i in 0..out_elements_count {
                            out_elements[i] = if vec_elements[i].is_null() {
                                None
                            } else {
                                Some(vec_elements[i].as_wrapper())
                            };
                        }
                        *out_elements = &mut (*out_elements)[..out_elements_count];
                    }
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn remove_element<'a>(&self, element: &'a mut PostDataElement) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .remove_element
                .map(|f| {
                    let arg_element = element;
                    let arg_self_ = self.as_raw();
                    let arg_element = arg_element.as_raw();
                    let result = f(arg_self_, arg_element);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn add_element<'a>(&self, element: &'a mut PostDataElement) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .add_element
                .map(|f| {
                    let arg_element = element;
                    let arg_self_ = self.as_raw();
                    let arg_element = arg_element.as_raw();
                    let result = f(arg_self_, arg_element);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn remove_elements<'a>(&self) {
        unsafe {
            self.0
                .remove_elements
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_post_data_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for PostData {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_post_data_t> for &PostData {
    fn as_raw(self) -> *mut _cef_post_data_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_post_data_t> for &mut PostData {
    fn as_raw(self) -> *mut _cef_post_data_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<PostData> for *mut _cef_post_data_t {
    fn as_wrapper(self) -> PostData {
        PostData(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_post_data_t> for PostData {
    fn into(self) -> *mut _cef_post_data_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for PostData {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplPostDataElement: Sized {
    fn is_read_only<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_to_empty<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn set_to_file<'a>(&self, file_name: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn set_to_bytes<'a>(&self, size: usize, bytes: *const ::std::os::raw::c_void) {
        unsafe { std::mem::zeroed() }
    }
    fn get_type<'a>(&self) -> PostdataelementType {
        unsafe { std::mem::zeroed() }
    }
    fn get_file<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_bytes_count<'a>(&self) -> usize {
        unsafe { std::mem::zeroed() }
    }
    fn get_bytes<'a>(&self, size: usize, bytes: *mut ::std::os::raw::c_void) -> usize {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_post_data_element_t {
        let mut object: _cef_post_data_element_t = unsafe { std::mem::zeroed() };
        impl_cef_post_data_element_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_post_data_element_t {
    use super::*;
    pub fn init_methods<I: ImplPostDataElement>(object: &mut _cef_post_data_element_t) {
        object.is_read_only = Some(is_read_only::<I>);
        object.set_to_empty = Some(set_to_empty::<I>);
        object.set_to_file = Some(set_to_file::<I>);
        object.set_to_bytes = Some(set_to_bytes::<I>);
        object.get_type = Some(get_type::<I>);
        object.get_file = Some(get_file::<I>);
        object.get_bytes_count = Some(get_bytes_count::<I>);
        object.get_bytes = Some(get_bytes::<I>);
    }
    extern "C" fn is_read_only<I: ImplPostDataElement>(
        self_: *mut _cef_post_data_element_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_read_only().into()
    }
    extern "C" fn set_to_empty<I: ImplPostDataElement>(self_: *mut _cef_post_data_element_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.set_to_empty()
    }
    extern "C" fn set_to_file<I: ImplPostDataElement>(
        self_: *mut _cef_post_data_element_t,
        file_name: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_file_name) = (self_, file_name);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_file_name = WrapParamRef::<CefStringUtf16>::from(arg_file_name);
        let arg_file_name = arg_file_name.as_ref();
        arg_self_.interface.set_to_file(arg_file_name)
    }
    extern "C" fn set_to_bytes<I: ImplPostDataElement>(
        self_: *mut _cef_post_data_element_t,
        size: usize,
        bytes: *const ::std::os::raw::c_void,
    ) {
        let (arg_self_, arg_size, arg_bytes) = (self_, size, bytes);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_size = arg_size.as_raw();
        arg_self_.interface.set_to_bytes(arg_size, arg_bytes)
    }
    extern "C" fn get_type<I: ImplPostDataElement>(
        self_: *mut _cef_post_data_element_t,
    ) -> cef_postdataelement_type_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_type().into()
    }
    extern "C" fn get_file<I: ImplPostDataElement>(
        self_: *mut _cef_post_data_element_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_file().into()
    }
    extern "C" fn get_bytes_count<I: ImplPostDataElement>(
        self_: *mut _cef_post_data_element_t,
    ) -> usize {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_bytes_count().into()
    }
    extern "C" fn get_bytes<I: ImplPostDataElement>(
        self_: *mut _cef_post_data_element_t,
        size: usize,
        bytes: *mut ::std::os::raw::c_void,
    ) -> usize {
        let (arg_self_, arg_size, arg_bytes) = (self_, size, bytes);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_size = arg_size.as_raw();
        arg_self_.interface.get_bytes(arg_size, arg_bytes).into()
    }
}
#[doc = "See [_cef_post_data_element_t] for more documentation."]
#[derive(Clone)]
pub struct PostDataElement(RefGuard<_cef_post_data_element_t>);
impl ImplPostDataElement for PostDataElement {
    fn is_read_only<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_read_only
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_to_empty<'a>(&self) {
        unsafe {
            self.0
                .set_to_empty
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_to_file<'a>(&self, file_name: &'a CefStringUtf16) {
        unsafe {
            self.0
                .set_to_file
                .map(|f| {
                    let arg_file_name = file_name;
                    let arg_self_ = self.as_raw();
                    let arg_file_name = arg_file_name.as_raw();
                    let result = f(arg_self_, arg_file_name);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_to_bytes<'a>(&self, size: usize, bytes: *const ::std::os::raw::c_void) {
        unsafe {
            self.0
                .set_to_bytes
                .map(|f| {
                    let (arg_size, arg_bytes) = (size, bytes);
                    let arg_self_ = self.as_raw();
                    let arg_size = arg_size;
                    let arg_bytes = arg_bytes as *const _;
                    let result = f(arg_self_, arg_size, arg_bytes);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_type<'a>(&self) -> PostdataelementType {
        unsafe {
            self.0
                .get_type
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_file<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_file
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_bytes_count<'a>(&self) -> usize {
        unsafe {
            self.0
                .get_bytes_count
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_bytes<'a>(&self, size: usize, bytes: *mut ::std::os::raw::c_void) -> usize {
        unsafe {
            self.0
                .get_bytes
                .map(|f| {
                    let (arg_size, arg_bytes) = (size, bytes);
                    let arg_self_ = self.as_raw();
                    let arg_size = arg_size;
                    let arg_bytes = arg_bytes as *mut _;
                    let result = f(arg_self_, arg_size, arg_bytes);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_post_data_element_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for PostDataElement {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_post_data_element_t> for &PostDataElement {
    fn as_raw(self) -> *mut _cef_post_data_element_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_post_data_element_t> for &mut PostDataElement {
    fn as_raw(self) -> *mut _cef_post_data_element_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<PostDataElement> for *mut _cef_post_data_element_t {
    fn as_wrapper(self) -> PostDataElement {
        PostDataElement(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_post_data_element_t> for PostDataElement {
    fn into(self) -> *mut _cef_post_data_element_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for PostDataElement {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplCefStringVisitor: Sized {
    fn visit<'a>(&self, string: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_string_visitor_t {
        let mut object: _cef_string_visitor_t = unsafe { std::mem::zeroed() };
        impl_cef_string_visitor_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_string_visitor_t {
    use super::*;
    pub fn init_methods<I: ImplCefStringVisitor>(object: &mut _cef_string_visitor_t) {
        object.visit = Some(visit::<I>);
    }
    extern "C" fn visit<I: ImplCefStringVisitor>(
        self_: *mut _cef_string_visitor_t,
        string: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_string) = (self_, string);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_string = WrapParamRef::<CefStringUtf16>::from(arg_string);
        let arg_string = arg_string.as_ref();
        arg_self_.interface.visit(arg_string)
    }
}
#[doc = "See [_cef_string_visitor_t] for more documentation."]
#[derive(Clone)]
pub struct CefStringVisitor(RefGuard<_cef_string_visitor_t>);
impl ImplCefStringVisitor for CefStringVisitor {
    fn visit<'a>(&self, string: &'a CefStringUtf16) {
        unsafe {
            self.0
                .visit
                .map(|f| {
                    let arg_string = string;
                    let arg_self_ = self.as_raw();
                    let arg_string = arg_string.as_raw();
                    let result = f(arg_self_, arg_string);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_string_visitor_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for CefStringVisitor {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_string_visitor_t> for &CefStringVisitor {
    fn as_raw(self) -> *mut _cef_string_visitor_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_string_visitor_t> for &mut CefStringVisitor {
    fn as_raw(self) -> *mut _cef_string_visitor_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<CefStringVisitor> for *mut _cef_string_visitor_t {
    fn as_wrapper(self) -> CefStringVisitor {
        CefStringVisitor(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_string_visitor_t> for CefStringVisitor {
    fn into(self) -> *mut _cef_string_visitor_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for CefStringVisitor {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplFrame: Sized {
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn undo<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn redo<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn cut<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn copy<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn paste<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn paste_and_match_style<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn del<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn select_all<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn view_source<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn get_source<'a>(&self, visitor: &'a mut CefStringVisitor) {
        unsafe { std::mem::zeroed() }
    }
    fn get_text<'a>(&self, visitor: &'a mut CefStringVisitor) {
        unsafe { std::mem::zeroed() }
    }
    fn load_request<'a>(&self, request: &'a mut Request) {
        unsafe { std::mem::zeroed() }
    }
    fn load_url<'a>(&self, url: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn execute_java_script<'a>(
        &self,
        code: &'a CefStringUtf16,
        script_url: &'a CefStringUtf16,
        start_line: ::std::os::raw::c_int,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn is_main<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_focused<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_name<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_identifier<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_parent<'a>(&self) -> Frame {
        unsafe { std::mem::zeroed() }
    }
    fn get_url<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_browser<'a>(&self) -> Browser {
        unsafe { std::mem::zeroed() }
    }
    fn get_v8context<'a>(&self) -> V8context {
        unsafe { std::mem::zeroed() }
    }
    fn visit_dom<'a>(&self, visitor: &'a mut Domvisitor) {
        unsafe { std::mem::zeroed() }
    }
    fn create_urlrequest<'a>(
        &self,
        request: &'a mut Request,
        client: &'a mut UrlrequestClient,
    ) -> Urlrequest {
        unsafe { std::mem::zeroed() }
    }
    fn send_process_message<'a>(&self, target_process: ProcessId, message: &'a mut ProcessMessage) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_frame_t {
        let mut object: _cef_frame_t = unsafe { std::mem::zeroed() };
        impl_cef_frame_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_frame_t {
    use super::*;
    pub fn init_methods<I: ImplFrame>(object: &mut _cef_frame_t) {
        object.is_valid = Some(is_valid::<I>);
        object.undo = Some(undo::<I>);
        object.redo = Some(redo::<I>);
        object.cut = Some(cut::<I>);
        object.copy = Some(copy::<I>);
        object.paste = Some(paste::<I>);
        object.paste_and_match_style = Some(paste_and_match_style::<I>);
        object.del = Some(del::<I>);
        object.select_all = Some(select_all::<I>);
        object.view_source = Some(view_source::<I>);
        object.get_source = Some(get_source::<I>);
        object.get_text = Some(get_text::<I>);
        object.load_request = Some(load_request::<I>);
        object.load_url = Some(load_url::<I>);
        object.execute_java_script = Some(execute_java_script::<I>);
        object.is_main = Some(is_main::<I>);
        object.is_focused = Some(is_focused::<I>);
        object.get_name = Some(get_name::<I>);
        object.get_identifier = Some(get_identifier::<I>);
        object.get_parent = Some(get_parent::<I>);
        object.get_url = Some(get_url::<I>);
        object.get_browser = Some(get_browser::<I>);
        object.get_v8context = Some(get_v8context::<I>);
        object.visit_dom = Some(visit_dom::<I>);
        object.create_urlrequest = Some(create_urlrequest::<I>);
        object.send_process_message = Some(send_process_message::<I>);
    }
    extern "C" fn is_valid<I: ImplFrame>(self_: *mut _cef_frame_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_valid().into()
    }
    extern "C" fn undo<I: ImplFrame>(self_: *mut _cef_frame_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.undo()
    }
    extern "C" fn redo<I: ImplFrame>(self_: *mut _cef_frame_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.redo()
    }
    extern "C" fn cut<I: ImplFrame>(self_: *mut _cef_frame_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.cut()
    }
    extern "C" fn copy<I: ImplFrame>(self_: *mut _cef_frame_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.copy()
    }
    extern "C" fn paste<I: ImplFrame>(self_: *mut _cef_frame_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.paste()
    }
    extern "C" fn paste_and_match_style<I: ImplFrame>(self_: *mut _cef_frame_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.paste_and_match_style()
    }
    extern "C" fn del<I: ImplFrame>(self_: *mut _cef_frame_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.del()
    }
    extern "C" fn select_all<I: ImplFrame>(self_: *mut _cef_frame_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.select_all()
    }
    extern "C" fn view_source<I: ImplFrame>(self_: *mut _cef_frame_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.view_source()
    }
    extern "C" fn get_source<I: ImplFrame>(
        self_: *mut _cef_frame_t,
        visitor: *mut _cef_string_visitor_t,
    ) {
        let (arg_self_, arg_visitor) = (self_, visitor);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_visitor = &mut CefStringVisitor(unsafe { RefGuard::from_raw_add_ref(arg_visitor) });
        arg_self_.interface.get_source(arg_visitor)
    }
    extern "C" fn get_text<I: ImplFrame>(
        self_: *mut _cef_frame_t,
        visitor: *mut _cef_string_visitor_t,
    ) {
        let (arg_self_, arg_visitor) = (self_, visitor);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_visitor = &mut CefStringVisitor(unsafe { RefGuard::from_raw_add_ref(arg_visitor) });
        arg_self_.interface.get_text(arg_visitor)
    }
    extern "C" fn load_request<I: ImplFrame>(
        self_: *mut _cef_frame_t,
        request: *mut _cef_request_t,
    ) {
        let (arg_self_, arg_request) = (self_, request);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_request = &mut Request(unsafe { RefGuard::from_raw_add_ref(arg_request) });
        arg_self_.interface.load_request(arg_request)
    }
    extern "C" fn load_url<I: ImplFrame>(
        self_: *mut _cef_frame_t,
        url: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_url) = (self_, url);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_url = WrapParamRef::<CefStringUtf16>::from(arg_url);
        let arg_url = arg_url.as_ref();
        arg_self_.interface.load_url(arg_url)
    }
    extern "C" fn execute_java_script<I: ImplFrame>(
        self_: *mut _cef_frame_t,
        code: *const _cef_string_utf16_t,
        script_url: *const _cef_string_utf16_t,
        start_line: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_code, arg_script_url, arg_start_line) =
            (self_, code, script_url, start_line);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_code = WrapParamRef::<CefStringUtf16>::from(arg_code);
        let arg_code = arg_code.as_ref();
        let arg_script_url = WrapParamRef::<CefStringUtf16>::from(arg_script_url);
        let arg_script_url = arg_script_url.as_ref();
        let arg_start_line = arg_start_line.as_raw();
        arg_self_
            .interface
            .execute_java_script(arg_code, arg_script_url, arg_start_line)
    }
    extern "C" fn is_main<I: ImplFrame>(self_: *mut _cef_frame_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_main().into()
    }
    extern "C" fn is_focused<I: ImplFrame>(self_: *mut _cef_frame_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_focused().into()
    }
    extern "C" fn get_name<I: ImplFrame>(self_: *mut _cef_frame_t) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_name().into()
    }
    extern "C" fn get_identifier<I: ImplFrame>(
        self_: *mut _cef_frame_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_identifier().into()
    }
    extern "C" fn get_parent<I: ImplFrame>(self_: *mut _cef_frame_t) -> *mut _cef_frame_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_parent().into()
    }
    extern "C" fn get_url<I: ImplFrame>(self_: *mut _cef_frame_t) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_url().into()
    }
    extern "C" fn get_browser<I: ImplFrame>(self_: *mut _cef_frame_t) -> *mut _cef_browser_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_browser().into()
    }
    extern "C" fn get_v8context<I: ImplFrame>(self_: *mut _cef_frame_t) -> *mut _cef_v8context_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_v8context().into()
    }
    extern "C" fn visit_dom<I: ImplFrame>(
        self_: *mut _cef_frame_t,
        visitor: *mut _cef_domvisitor_t,
    ) {
        let (arg_self_, arg_visitor) = (self_, visitor);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_visitor = &mut Domvisitor(unsafe { RefGuard::from_raw_add_ref(arg_visitor) });
        arg_self_.interface.visit_dom(arg_visitor)
    }
    extern "C" fn create_urlrequest<I: ImplFrame>(
        self_: *mut _cef_frame_t,
        request: *mut _cef_request_t,
        client: *mut _cef_urlrequest_client_t,
    ) -> *mut _cef_urlrequest_t {
        let (arg_self_, arg_request, arg_client) = (self_, request, client);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_request = &mut Request(unsafe { RefGuard::from_raw_add_ref(arg_request) });
        let arg_client = &mut UrlrequestClient(unsafe { RefGuard::from_raw_add_ref(arg_client) });
        arg_self_
            .interface
            .create_urlrequest(arg_request, arg_client)
            .into()
    }
    extern "C" fn send_process_message<I: ImplFrame>(
        self_: *mut _cef_frame_t,
        target_process: cef_process_id_t,
        message: *mut _cef_process_message_t,
    ) {
        let (arg_self_, arg_target_process, arg_message) = (self_, target_process, message);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_target_process = arg_target_process.as_raw();
        let arg_message = &mut ProcessMessage(unsafe { RefGuard::from_raw_add_ref(arg_message) });
        arg_self_
            .interface
            .send_process_message(arg_target_process, arg_message)
    }
}
#[doc = "See [_cef_frame_t] for more documentation."]
#[derive(Clone)]
pub struct Frame(RefGuard<_cef_frame_t>);
impl ImplFrame for Frame {
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn undo<'a>(&self) {
        unsafe {
            self.0
                .undo
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn redo<'a>(&self) {
        unsafe {
            self.0
                .redo
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn cut<'a>(&self) {
        unsafe {
            self.0
                .cut
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn copy<'a>(&self) {
        unsafe {
            self.0
                .copy
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn paste<'a>(&self) {
        unsafe {
            self.0
                .paste
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn paste_and_match_style<'a>(&self) {
        unsafe {
            self.0
                .paste_and_match_style
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn del<'a>(&self) {
        unsafe {
            self.0
                .del
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn select_all<'a>(&self) {
        unsafe {
            self.0
                .select_all
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn view_source<'a>(&self) {
        unsafe {
            self.0
                .view_source
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_source<'a>(&self, visitor: &'a mut CefStringVisitor) {
        unsafe {
            self.0
                .get_source
                .map(|f| {
                    let arg_visitor = visitor;
                    let arg_self_ = self.as_raw();
                    let arg_visitor = arg_visitor.as_raw();
                    let result = f(arg_self_, arg_visitor);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_text<'a>(&self, visitor: &'a mut CefStringVisitor) {
        unsafe {
            self.0
                .get_text
                .map(|f| {
                    let arg_visitor = visitor;
                    let arg_self_ = self.as_raw();
                    let arg_visitor = arg_visitor.as_raw();
                    let result = f(arg_self_, arg_visitor);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn load_request<'a>(&self, request: &'a mut Request) {
        unsafe {
            self.0
                .load_request
                .map(|f| {
                    let arg_request = request;
                    let arg_self_ = self.as_raw();
                    let arg_request = arg_request.as_raw();
                    let result = f(arg_self_, arg_request);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn load_url<'a>(&self, url: &'a CefStringUtf16) {
        unsafe {
            self.0
                .load_url
                .map(|f| {
                    let arg_url = url;
                    let arg_self_ = self.as_raw();
                    let arg_url = arg_url.as_raw();
                    let result = f(arg_self_, arg_url);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn execute_java_script<'a>(
        &self,
        code: &'a CefStringUtf16,
        script_url: &'a CefStringUtf16,
        start_line: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .execute_java_script
                .map(|f| {
                    let (arg_code, arg_script_url, arg_start_line) = (code, script_url, start_line);
                    let arg_self_ = self.as_raw();
                    let arg_code = arg_code.as_raw();
                    let arg_script_url = arg_script_url.as_raw();
                    let arg_start_line = arg_start_line;
                    let result = f(arg_self_, arg_code, arg_script_url, arg_start_line);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_main<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_main
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_focused<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_focused
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_name<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_name
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_identifier<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_identifier
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_parent<'a>(&self) -> Frame {
        unsafe {
            self.0
                .get_parent
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_url<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_url
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_browser<'a>(&self) -> Browser {
        unsafe {
            self.0
                .get_browser
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_v8context<'a>(&self) -> V8context {
        unsafe {
            self.0
                .get_v8context
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn visit_dom<'a>(&self, visitor: &'a mut Domvisitor) {
        unsafe {
            self.0
                .visit_dom
                .map(|f| {
                    let arg_visitor = visitor;
                    let arg_self_ = self.as_raw();
                    let arg_visitor = arg_visitor.as_raw();
                    let result = f(arg_self_, arg_visitor);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn create_urlrequest<'a>(
        &self,
        request: &'a mut Request,
        client: &'a mut UrlrequestClient,
    ) -> Urlrequest {
        unsafe {
            self.0
                .create_urlrequest
                .map(|f| {
                    let (arg_request, arg_client) = (request, client);
                    let arg_self_ = self.as_raw();
                    let arg_request = arg_request.as_raw();
                    let arg_client = arg_client.as_raw();
                    let result = f(arg_self_, arg_request, arg_client);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn send_process_message<'a>(&self, target_process: ProcessId, message: &'a mut ProcessMessage) {
        unsafe {
            self.0
                .send_process_message
                .map(|f| {
                    let (arg_target_process, arg_message) = (target_process, message);
                    let arg_self_ = self.as_raw();
                    let arg_target_process = arg_target_process.as_raw();
                    let arg_message = arg_message.as_raw();
                    let result = f(arg_self_, arg_target_process, arg_message);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_frame_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Frame {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_frame_t> for &Frame {
    fn as_raw(self) -> *mut _cef_frame_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_frame_t> for &mut Frame {
    fn as_raw(self) -> *mut _cef_frame_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<Frame> for *mut _cef_frame_t {
    fn as_wrapper(self) -> Frame {
        Frame(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_frame_t> for Frame {
    fn into(self) -> *mut _cef_frame_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for Frame {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplX509certPrincipal: Sized {
    fn get_display_name<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_common_name<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_locality_name<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_state_or_province_name<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_country_name<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_organization_names<'a>(&self, names: &'a mut CefStringList) {
        unsafe { std::mem::zeroed() }
    }
    fn get_organization_unit_names<'a>(&self, names: &'a mut CefStringList) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_x509cert_principal_t {
        let mut object: _cef_x509cert_principal_t = unsafe { std::mem::zeroed() };
        impl_cef_x509cert_principal_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_x509cert_principal_t {
    use super::*;
    pub fn init_methods<I: ImplX509certPrincipal>(object: &mut _cef_x509cert_principal_t) {
        object.get_display_name = Some(get_display_name::<I>);
        object.get_common_name = Some(get_common_name::<I>);
        object.get_locality_name = Some(get_locality_name::<I>);
        object.get_state_or_province_name = Some(get_state_or_province_name::<I>);
        object.get_country_name = Some(get_country_name::<I>);
        object.get_organization_names = Some(get_organization_names::<I>);
        object.get_organization_unit_names = Some(get_organization_unit_names::<I>);
    }
    extern "C" fn get_display_name<I: ImplX509certPrincipal>(
        self_: *mut _cef_x509cert_principal_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_display_name().into()
    }
    extern "C" fn get_common_name<I: ImplX509certPrincipal>(
        self_: *mut _cef_x509cert_principal_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_common_name().into()
    }
    extern "C" fn get_locality_name<I: ImplX509certPrincipal>(
        self_: *mut _cef_x509cert_principal_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_locality_name().into()
    }
    extern "C" fn get_state_or_province_name<I: ImplX509certPrincipal>(
        self_: *mut _cef_x509cert_principal_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_state_or_province_name().into()
    }
    extern "C" fn get_country_name<I: ImplX509certPrincipal>(
        self_: *mut _cef_x509cert_principal_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_country_name().into()
    }
    extern "C" fn get_organization_names<I: ImplX509certPrincipal>(
        self_: *mut _cef_x509cert_principal_t,
        names: *mut _cef_string_list_t,
    ) {
        let (arg_self_, arg_names) = (self_, names);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_names = WrapParamRef::<CefStringList>::from(arg_names);
        let arg_names = arg_names.as_mut();
        arg_self_.interface.get_organization_names(arg_names)
    }
    extern "C" fn get_organization_unit_names<I: ImplX509certPrincipal>(
        self_: *mut _cef_x509cert_principal_t,
        names: *mut _cef_string_list_t,
    ) {
        let (arg_self_, arg_names) = (self_, names);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_names = WrapParamRef::<CefStringList>::from(arg_names);
        let arg_names = arg_names.as_mut();
        arg_self_.interface.get_organization_unit_names(arg_names)
    }
}
#[doc = "See [_cef_x509cert_principal_t] for more documentation."]
#[derive(Clone)]
pub struct X509certPrincipal(RefGuard<_cef_x509cert_principal_t>);
impl ImplX509certPrincipal for X509certPrincipal {
    fn get_display_name<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_display_name
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_common_name<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_common_name
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_locality_name<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_locality_name
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_state_or_province_name<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_state_or_province_name
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_country_name<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_country_name
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_organization_names<'a>(&self, names: &'a mut CefStringList) {
        unsafe {
            self.0
                .get_organization_names
                .map(|f| {
                    let arg_names = names;
                    let arg_self_ = self.as_raw();
                    let arg_names = arg_names.as_raw();
                    let result = f(arg_self_, arg_names);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_organization_unit_names<'a>(&self, names: &'a mut CefStringList) {
        unsafe {
            self.0
                .get_organization_unit_names
                .map(|f| {
                    let arg_names = names;
                    let arg_self_ = self.as_raw();
                    let arg_names = arg_names.as_raw();
                    let result = f(arg_self_, arg_names);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_x509cert_principal_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for X509certPrincipal {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_x509cert_principal_t> for &X509certPrincipal {
    fn as_raw(self) -> *mut _cef_x509cert_principal_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_x509cert_principal_t> for &mut X509certPrincipal {
    fn as_raw(self) -> *mut _cef_x509cert_principal_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<X509certPrincipal> for *mut _cef_x509cert_principal_t {
    fn as_wrapper(self) -> X509certPrincipal {
        X509certPrincipal(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_x509cert_principal_t> for X509certPrincipal {
    fn into(self) -> *mut _cef_x509cert_principal_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for X509certPrincipal {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplX509certificate: Sized {
    fn get_subject<'a>(&self) -> X509certPrincipal {
        unsafe { std::mem::zeroed() }
    }
    fn get_issuer<'a>(&self) -> X509certPrincipal {
        unsafe { std::mem::zeroed() }
    }
    fn get_serial_number<'a>(&self) -> BinaryValue {
        unsafe { std::mem::zeroed() }
    }
    fn get_valid_start<'a>(&self) -> Basetime {
        unsafe { std::mem::zeroed() }
    }
    fn get_valid_expiry<'a>(&self) -> Basetime {
        unsafe { std::mem::zeroed() }
    }
    fn get_derencoded<'a>(&self) -> BinaryValue {
        unsafe { std::mem::zeroed() }
    }
    fn get_pemencoded<'a>(&self) -> BinaryValue {
        unsafe { std::mem::zeroed() }
    }
    fn get_issuer_chain_size<'a>(&self) -> usize {
        unsafe { std::mem::zeroed() }
    }
    fn get_derencoded_issuer_chain<'a>(
        &self,
        chain: Option<&'a mut &'a mut [Option<BinaryValue>]>,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn get_pemencoded_issuer_chain<'a>(
        &self,
        chain: Option<&'a mut &'a mut [Option<BinaryValue>]>,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_x509certificate_t {
        let mut object: _cef_x509certificate_t = unsafe { std::mem::zeroed() };
        impl_cef_x509certificate_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_x509certificate_t {
    use super::*;
    pub fn init_methods<I: ImplX509certificate>(object: &mut _cef_x509certificate_t) {
        object.get_subject = Some(get_subject::<I>);
        object.get_issuer = Some(get_issuer::<I>);
        object.get_serial_number = Some(get_serial_number::<I>);
        object.get_valid_start = Some(get_valid_start::<I>);
        object.get_valid_expiry = Some(get_valid_expiry::<I>);
        object.get_derencoded = Some(get_derencoded::<I>);
        object.get_pemencoded = Some(get_pemencoded::<I>);
        object.get_issuer_chain_size = Some(get_issuer_chain_size::<I>);
        object.get_derencoded_issuer_chain = Some(get_derencoded_issuer_chain::<I>);
        object.get_pemencoded_issuer_chain = Some(get_pemencoded_issuer_chain::<I>);
    }
    extern "C" fn get_subject<I: ImplX509certificate>(
        self_: *mut _cef_x509certificate_t,
    ) -> *mut _cef_x509cert_principal_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_subject().into()
    }
    extern "C" fn get_issuer<I: ImplX509certificate>(
        self_: *mut _cef_x509certificate_t,
    ) -> *mut _cef_x509cert_principal_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_issuer().into()
    }
    extern "C" fn get_serial_number<I: ImplX509certificate>(
        self_: *mut _cef_x509certificate_t,
    ) -> *mut _cef_binary_value_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_serial_number().into()
    }
    extern "C" fn get_valid_start<I: ImplX509certificate>(
        self_: *mut _cef_x509certificate_t,
    ) -> _cef_basetime_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_valid_start().into()
    }
    extern "C" fn get_valid_expiry<I: ImplX509certificate>(
        self_: *mut _cef_x509certificate_t,
    ) -> _cef_basetime_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_valid_expiry().into()
    }
    extern "C" fn get_derencoded<I: ImplX509certificate>(
        self_: *mut _cef_x509certificate_t,
    ) -> *mut _cef_binary_value_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_derencoded().into()
    }
    extern "C" fn get_pemencoded<I: ImplX509certificate>(
        self_: *mut _cef_x509certificate_t,
    ) -> *mut _cef_binary_value_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_pemencoded().into()
    }
    extern "C" fn get_issuer_chain_size<I: ImplX509certificate>(
        self_: *mut _cef_x509certificate_t,
    ) -> usize {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_issuer_chain_size().into()
    }
    extern "C" fn get_derencoded_issuer_chain<I: ImplX509certificate>(
        self_: *mut _cef_x509certificate_t,
        chain_count: *mut usize,
        chain: *mut *mut _cef_binary_value_t,
    ) {
        let (arg_self_, arg_chain_count, arg_chain) = (self_, chain_count, chain);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut out_chain_count = unsafe { arg_chain_count.as_mut() };
        let arg_chain_count = out_chain_count.map(|count| *count).unwrap_or_default();
        let mut vec_chain = unsafe { arg_chain.as_mut() }.map(|arg| {
            let arg =
                unsafe { std::slice::from_raw_parts_mut(std::ptr::from_mut(arg), arg_chain_count) };
            arg.iter_mut()
                .map(|arg| {
                    if arg.is_null() {
                        None
                    } else {
                        Some(BinaryValue(unsafe { RefGuard::from_raw_add_ref(*arg) }))
                    }
                })
                .collect::<Vec<_>>()
        });
        let mut arg_chain = vec_chain.as_mut().map(|arg| arg.as_mut_slice());
        let arg_chain = arg_chain.as_mut();
        arg_self_.interface.get_derencoded_issuer_chain(arg_chain)
    }
    extern "C" fn get_pemencoded_issuer_chain<I: ImplX509certificate>(
        self_: *mut _cef_x509certificate_t,
        chain_count: *mut usize,
        chain: *mut *mut _cef_binary_value_t,
    ) {
        let (arg_self_, arg_chain_count, arg_chain) = (self_, chain_count, chain);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut out_chain_count = unsafe { arg_chain_count.as_mut() };
        let arg_chain_count = out_chain_count.map(|count| *count).unwrap_or_default();
        let mut vec_chain = unsafe { arg_chain.as_mut() }.map(|arg| {
            let arg =
                unsafe { std::slice::from_raw_parts_mut(std::ptr::from_mut(arg), arg_chain_count) };
            arg.iter_mut()
                .map(|arg| {
                    if arg.is_null() {
                        None
                    } else {
                        Some(BinaryValue(unsafe { RefGuard::from_raw_add_ref(*arg) }))
                    }
                })
                .collect::<Vec<_>>()
        });
        let mut arg_chain = vec_chain.as_mut().map(|arg| arg.as_mut_slice());
        let arg_chain = arg_chain.as_mut();
        arg_self_.interface.get_pemencoded_issuer_chain(arg_chain)
    }
}
#[doc = "See [_cef_x509certificate_t] for more documentation."]
#[derive(Clone)]
pub struct X509certificate(RefGuard<_cef_x509certificate_t>);
impl ImplX509certificate for X509certificate {
    fn get_subject<'a>(&self) -> X509certPrincipal {
        unsafe {
            self.0
                .get_subject
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_issuer<'a>(&self) -> X509certPrincipal {
        unsafe {
            self.0
                .get_issuer
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_serial_number<'a>(&self) -> BinaryValue {
        unsafe {
            self.0
                .get_serial_number
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_valid_start<'a>(&self) -> Basetime {
        unsafe {
            self.0
                .get_valid_start
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_valid_expiry<'a>(&self) -> Basetime {
        unsafe {
            self.0
                .get_valid_expiry
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_derencoded<'a>(&self) -> BinaryValue {
        unsafe {
            self.0
                .get_derencoded
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_pemencoded<'a>(&self) -> BinaryValue {
        unsafe {
            self.0
                .get_pemencoded
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_issuer_chain_size<'a>(&self) -> usize {
        unsafe {
            self.0
                .get_issuer_chain_size
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_derencoded_issuer_chain<'a>(
        &self,
        chain: Option<&'a mut &'a mut [Option<BinaryValue>]>,
    ) {
        unsafe {
            self.0
                .get_derencoded_issuer_chain
                .map(|f| {
                    let arg_chain = chain;
                    let arg_self_ = self.as_raw();
                    let mut out_chain_count = arg_chain
                        .as_ref()
                        .map(|slice| slice.len())
                        .unwrap_or_default();
                    let arg_chain_count = &mut out_chain_count;
                    let mut out_chain = arg_chain;
                    let arg_chain = &mut out_chain;
                    let mut vec_chain = arg_chain
                        .as_mut()
                        .map(|slice| {
                            slice
                                .iter_mut()
                                .map(|elem| {
                                    elem.as_mut()
                                        .map(|elem| std::mem::take(elem).into_raw())
                                        .unwrap_or(std::ptr::null_mut())
                                })
                                .collect::<Vec<_>>()
                        })
                        .unwrap_or_default();
                    let arg_chain = if vec_chain.is_empty() {
                        std::ptr::null_mut()
                    } else {
                        vec_chain.as_mut_ptr()
                    };
                    let result = f(arg_self_, arg_chain_count, arg_chain);
                    if let Some(out_chain) = out_chain {
                        for i in 0..out_chain_count {
                            out_chain[i] = if vec_chain[i].is_null() {
                                None
                            } else {
                                Some(vec_chain[i].as_wrapper())
                            };
                        }
                        *out_chain = &mut (*out_chain)[..out_chain_count];
                    }
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_pemencoded_issuer_chain<'a>(
        &self,
        chain: Option<&'a mut &'a mut [Option<BinaryValue>]>,
    ) {
        unsafe {
            self.0
                .get_pemencoded_issuer_chain
                .map(|f| {
                    let arg_chain = chain;
                    let arg_self_ = self.as_raw();
                    let mut out_chain_count = arg_chain
                        .as_ref()
                        .map(|slice| slice.len())
                        .unwrap_or_default();
                    let arg_chain_count = &mut out_chain_count;
                    let mut out_chain = arg_chain;
                    let arg_chain = &mut out_chain;
                    let mut vec_chain = arg_chain
                        .as_mut()
                        .map(|slice| {
                            slice
                                .iter_mut()
                                .map(|elem| {
                                    elem.as_mut()
                                        .map(|elem| std::mem::take(elem).into_raw())
                                        .unwrap_or(std::ptr::null_mut())
                                })
                                .collect::<Vec<_>>()
                        })
                        .unwrap_or_default();
                    let arg_chain = if vec_chain.is_empty() {
                        std::ptr::null_mut()
                    } else {
                        vec_chain.as_mut_ptr()
                    };
                    let result = f(arg_self_, arg_chain_count, arg_chain);
                    if let Some(out_chain) = out_chain {
                        for i in 0..out_chain_count {
                            out_chain[i] = if vec_chain[i].is_null() {
                                None
                            } else {
                                Some(vec_chain[i].as_wrapper())
                            };
                        }
                        *out_chain = &mut (*out_chain)[..out_chain_count];
                    }
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_x509certificate_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for X509certificate {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_x509certificate_t> for &X509certificate {
    fn as_raw(self) -> *mut _cef_x509certificate_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_x509certificate_t> for &mut X509certificate {
    fn as_raw(self) -> *mut _cef_x509certificate_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<X509certificate> for *mut _cef_x509certificate_t {
    fn as_wrapper(self) -> X509certificate {
        X509certificate(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_x509certificate_t> for X509certificate {
    fn into(self) -> *mut _cef_x509certificate_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for X509certificate {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplSslstatus: Sized {
    fn is_secure_connection<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_cert_status<'a>(&self) -> CertStatus {
        unsafe { std::mem::zeroed() }
    }
    fn get_sslversion<'a>(&self) -> SslVersion {
        unsafe { std::mem::zeroed() }
    }
    fn get_content_status<'a>(&self) -> SslContentStatus {
        unsafe { std::mem::zeroed() }
    }
    fn get_x509certificate<'a>(&self) -> X509certificate {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_sslstatus_t {
        let mut object: _cef_sslstatus_t = unsafe { std::mem::zeroed() };
        impl_cef_sslstatus_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_sslstatus_t {
    use super::*;
    pub fn init_methods<I: ImplSslstatus>(object: &mut _cef_sslstatus_t) {
        object.is_secure_connection = Some(is_secure_connection::<I>);
        object.get_cert_status = Some(get_cert_status::<I>);
        object.get_sslversion = Some(get_sslversion::<I>);
        object.get_content_status = Some(get_content_status::<I>);
        object.get_x509certificate = Some(get_x509certificate::<I>);
    }
    extern "C" fn is_secure_connection<I: ImplSslstatus>(
        self_: *mut _cef_sslstatus_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_secure_connection().into()
    }
    extern "C" fn get_cert_status<I: ImplSslstatus>(
        self_: *mut _cef_sslstatus_t,
    ) -> cef_cert_status_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_cert_status().into()
    }
    extern "C" fn get_sslversion<I: ImplSslstatus>(
        self_: *mut _cef_sslstatus_t,
    ) -> cef_ssl_version_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_sslversion().into()
    }
    extern "C" fn get_content_status<I: ImplSslstatus>(
        self_: *mut _cef_sslstatus_t,
    ) -> cef_ssl_content_status_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_content_status().into()
    }
    extern "C" fn get_x509certificate<I: ImplSslstatus>(
        self_: *mut _cef_sslstatus_t,
    ) -> *mut _cef_x509certificate_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_x509certificate().into()
    }
}
#[doc = "See [_cef_sslstatus_t] for more documentation."]
#[derive(Clone)]
pub struct Sslstatus(RefGuard<_cef_sslstatus_t>);
impl ImplSslstatus for Sslstatus {
    fn is_secure_connection<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_secure_connection
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_cert_status<'a>(&self) -> CertStatus {
        unsafe {
            self.0
                .get_cert_status
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_sslversion<'a>(&self) -> SslVersion {
        unsafe {
            self.0
                .get_sslversion
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_content_status<'a>(&self) -> SslContentStatus {
        unsafe {
            self.0
                .get_content_status
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_x509certificate<'a>(&self) -> X509certificate {
        unsafe {
            self.0
                .get_x509certificate
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_sslstatus_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Sslstatus {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_sslstatus_t> for &Sslstatus {
    fn as_raw(self) -> *mut _cef_sslstatus_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_sslstatus_t> for &mut Sslstatus {
    fn as_raw(self) -> *mut _cef_sslstatus_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<Sslstatus> for *mut _cef_sslstatus_t {
    fn as_wrapper(self) -> Sslstatus {
        Sslstatus(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_sslstatus_t> for Sslstatus {
    fn into(self) -> *mut _cef_sslstatus_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for Sslstatus {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplNavigationEntry: Sized {
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_url<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_display_url<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_original_url<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_title<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_transition_type<'a>(&self) -> TransitionType {
        unsafe { std::mem::zeroed() }
    }
    fn has_post_data<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_completion_time<'a>(&self) -> Basetime {
        unsafe { std::mem::zeroed() }
    }
    fn get_http_status_code<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_sslstatus<'a>(&self) -> Sslstatus {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_navigation_entry_t {
        let mut object: _cef_navigation_entry_t = unsafe { std::mem::zeroed() };
        impl_cef_navigation_entry_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_navigation_entry_t {
    use super::*;
    pub fn init_methods<I: ImplNavigationEntry>(object: &mut _cef_navigation_entry_t) {
        object.is_valid = Some(is_valid::<I>);
        object.get_url = Some(get_url::<I>);
        object.get_display_url = Some(get_display_url::<I>);
        object.get_original_url = Some(get_original_url::<I>);
        object.get_title = Some(get_title::<I>);
        object.get_transition_type = Some(get_transition_type::<I>);
        object.has_post_data = Some(has_post_data::<I>);
        object.get_completion_time = Some(get_completion_time::<I>);
        object.get_http_status_code = Some(get_http_status_code::<I>);
        object.get_sslstatus = Some(get_sslstatus::<I>);
    }
    extern "C" fn is_valid<I: ImplNavigationEntry>(
        self_: *mut _cef_navigation_entry_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_valid().into()
    }
    extern "C" fn get_url<I: ImplNavigationEntry>(
        self_: *mut _cef_navigation_entry_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_url().into()
    }
    extern "C" fn get_display_url<I: ImplNavigationEntry>(
        self_: *mut _cef_navigation_entry_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_display_url().into()
    }
    extern "C" fn get_original_url<I: ImplNavigationEntry>(
        self_: *mut _cef_navigation_entry_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_original_url().into()
    }
    extern "C" fn get_title<I: ImplNavigationEntry>(
        self_: *mut _cef_navigation_entry_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_title().into()
    }
    extern "C" fn get_transition_type<I: ImplNavigationEntry>(
        self_: *mut _cef_navigation_entry_t,
    ) -> cef_transition_type_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_transition_type().into()
    }
    extern "C" fn has_post_data<I: ImplNavigationEntry>(
        self_: *mut _cef_navigation_entry_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.has_post_data().into()
    }
    extern "C" fn get_completion_time<I: ImplNavigationEntry>(
        self_: *mut _cef_navigation_entry_t,
    ) -> _cef_basetime_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_completion_time().into()
    }
    extern "C" fn get_http_status_code<I: ImplNavigationEntry>(
        self_: *mut _cef_navigation_entry_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_http_status_code().into()
    }
    extern "C" fn get_sslstatus<I: ImplNavigationEntry>(
        self_: *mut _cef_navigation_entry_t,
    ) -> *mut _cef_sslstatus_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_sslstatus().into()
    }
}
#[doc = "See [_cef_navigation_entry_t] for more documentation."]
#[derive(Clone)]
pub struct NavigationEntry(RefGuard<_cef_navigation_entry_t>);
impl ImplNavigationEntry for NavigationEntry {
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_url<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_url
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_display_url<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_display_url
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_original_url<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_original_url
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_title<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_title
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_transition_type<'a>(&self) -> TransitionType {
        unsafe {
            self.0
                .get_transition_type
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn has_post_data<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_post_data
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_completion_time<'a>(&self) -> Basetime {
        unsafe {
            self.0
                .get_completion_time
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_http_status_code<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_http_status_code
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_sslstatus<'a>(&self) -> Sslstatus {
        unsafe {
            self.0
                .get_sslstatus
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_navigation_entry_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for NavigationEntry {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_navigation_entry_t> for &NavigationEntry {
    fn as_raw(self) -> *mut _cef_navigation_entry_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_navigation_entry_t> for &mut NavigationEntry {
    fn as_raw(self) -> *mut _cef_navigation_entry_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<NavigationEntry> for *mut _cef_navigation_entry_t {
    fn as_wrapper(self) -> NavigationEntry {
        NavigationEntry(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_navigation_entry_t> for NavigationEntry {
    fn into(self) -> *mut _cef_navigation_entry_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for NavigationEntry {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplRegistration: Sized {
    fn into_raw(self) -> *mut _cef_registration_t {
        let mut object: _cef_registration_t = unsafe { std::mem::zeroed() };
        impl_cef_registration_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_registration_t {
    use super::*;
    pub fn init_methods<I: ImplRegistration>(object: &mut _cef_registration_t) {}
}
#[doc = "See [_cef_registration_t] for more documentation."]
#[derive(Clone)]
pub struct Registration(RefGuard<_cef_registration_t>);
impl ImplRegistration for Registration {}
impl Rc for _cef_registration_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Registration {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_registration_t> for &Registration {
    fn as_raw(self) -> *mut _cef_registration_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_registration_t> for &mut Registration {
    fn as_raw(self) -> *mut _cef_registration_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<Registration> for *mut _cef_registration_t {
    fn as_wrapper(self) -> Registration {
        Registration(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_registration_t> for Registration {
    fn into(self) -> *mut _cef_registration_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for Registration {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplCallback: Sized {
    fn cont<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn cancel<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_callback_t {
        let mut object: _cef_callback_t = unsafe { std::mem::zeroed() };
        impl_cef_callback_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_callback_t {
    use super::*;
    pub fn init_methods<I: ImplCallback>(object: &mut _cef_callback_t) {
        object.cont = Some(cont::<I>);
        object.cancel = Some(cancel::<I>);
    }
    extern "C" fn cont<I: ImplCallback>(self_: *mut _cef_callback_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.cont()
    }
    extern "C" fn cancel<I: ImplCallback>(self_: *mut _cef_callback_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.cancel()
    }
}
#[doc = "See [_cef_callback_t] for more documentation."]
#[derive(Clone)]
pub struct Callback(RefGuard<_cef_callback_t>);
impl ImplCallback for Callback {
    fn cont<'a>(&self) {
        unsafe {
            self.0
                .cont
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn cancel<'a>(&self) {
        unsafe {
            self.0
                .cancel
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Callback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_callback_t> for &Callback {
    fn as_raw(self) -> *mut _cef_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_callback_t> for &mut Callback {
    fn as_raw(self) -> *mut _cef_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<Callback> for *mut _cef_callback_t {
    fn as_wrapper(self) -> Callback {
        Callback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_callback_t> for Callback {
    fn into(self) -> *mut _cef_callback_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for Callback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplCompletionCallback: Sized {
    fn on_complete<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_completion_callback_t {
        let mut object: _cef_completion_callback_t = unsafe { std::mem::zeroed() };
        impl_cef_completion_callback_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_completion_callback_t {
    use super::*;
    pub fn init_methods<I: ImplCompletionCallback>(object: &mut _cef_completion_callback_t) {
        object.on_complete = Some(on_complete::<I>);
    }
    extern "C" fn on_complete<I: ImplCompletionCallback>(self_: *mut _cef_completion_callback_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.on_complete()
    }
}
#[doc = "See [_cef_completion_callback_t] for more documentation."]
#[derive(Clone)]
pub struct CompletionCallback(RefGuard<_cef_completion_callback_t>);
impl ImplCompletionCallback for CompletionCallback {
    fn on_complete<'a>(&self) {
        unsafe {
            self.0
                .on_complete
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_completion_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for CompletionCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_completion_callback_t> for &CompletionCallback {
    fn as_raw(self) -> *mut _cef_completion_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_completion_callback_t> for &mut CompletionCallback {
    fn as_raw(self) -> *mut _cef_completion_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<CompletionCallback> for *mut _cef_completion_callback_t {
    fn as_wrapper(self) -> CompletionCallback {
        CompletionCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_completion_callback_t> for CompletionCallback {
    fn into(self) -> *mut _cef_completion_callback_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for CompletionCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplCookieManager: Sized {
    fn visit_all_cookies<'a>(&self, visitor: &'a mut CookieVisitor) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn visit_url_cookies<'a>(
        &self,
        url: &'a CefStringUtf16,
        include_http_only: ::std::os::raw::c_int,
        visitor: &'a mut CookieVisitor,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_cookie<'a>(
        &self,
        url: &'a CefStringUtf16,
        cookie: &'a Cookie,
        callback: &'a mut SetCookieCallback,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn delete_cookies<'a>(
        &self,
        url: &'a CefStringUtf16,
        cookie_name: &'a CefStringUtf16,
        callback: &'a mut DeleteCookiesCallback,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn flush_store<'a>(&self, callback: &'a mut CompletionCallback) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_cookie_manager_t {
        let mut object: _cef_cookie_manager_t = unsafe { std::mem::zeroed() };
        impl_cef_cookie_manager_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_cookie_manager_t {
    use super::*;
    pub fn init_methods<I: ImplCookieManager>(object: &mut _cef_cookie_manager_t) {
        object.visit_all_cookies = Some(visit_all_cookies::<I>);
        object.visit_url_cookies = Some(visit_url_cookies::<I>);
        object.set_cookie = Some(set_cookie::<I>);
        object.delete_cookies = Some(delete_cookies::<I>);
        object.flush_store = Some(flush_store::<I>);
    }
    extern "C" fn visit_all_cookies<I: ImplCookieManager>(
        self_: *mut _cef_cookie_manager_t,
        visitor: *mut _cef_cookie_visitor_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_visitor) = (self_, visitor);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_visitor = &mut CookieVisitor(unsafe { RefGuard::from_raw_add_ref(arg_visitor) });
        arg_self_.interface.visit_all_cookies(arg_visitor).into()
    }
    extern "C" fn visit_url_cookies<I: ImplCookieManager>(
        self_: *mut _cef_cookie_manager_t,
        url: *const _cef_string_utf16_t,
        include_http_only: ::std::os::raw::c_int,
        visitor: *mut _cef_cookie_visitor_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_url, arg_include_http_only, arg_visitor) =
            (self_, url, include_http_only, visitor);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_url = WrapParamRef::<CefStringUtf16>::from(arg_url);
        let arg_url = arg_url.as_ref();
        let arg_include_http_only = arg_include_http_only.as_raw();
        let arg_visitor = &mut CookieVisitor(unsafe { RefGuard::from_raw_add_ref(arg_visitor) });
        arg_self_
            .interface
            .visit_url_cookies(arg_url, arg_include_http_only, arg_visitor)
            .into()
    }
    extern "C" fn set_cookie<I: ImplCookieManager>(
        self_: *mut _cef_cookie_manager_t,
        url: *const _cef_string_utf16_t,
        cookie: *const _cef_cookie_t,
        callback: *mut _cef_set_cookie_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_url, arg_cookie, arg_callback) = (self_, url, cookie, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_url = WrapParamRef::<CefStringUtf16>::from(arg_url);
        let arg_url = arg_url.as_ref();
        let arg_cookie = WrapParamRef::<Cookie>::from(arg_cookie);
        let arg_cookie = arg_cookie.as_ref();
        let arg_callback =
            &mut SetCookieCallback(unsafe { RefGuard::from_raw_add_ref(arg_callback) });
        arg_self_
            .interface
            .set_cookie(arg_url, arg_cookie, arg_callback)
            .into()
    }
    extern "C" fn delete_cookies<I: ImplCookieManager>(
        self_: *mut _cef_cookie_manager_t,
        url: *const _cef_string_utf16_t,
        cookie_name: *const _cef_string_utf16_t,
        callback: *mut _cef_delete_cookies_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_url, arg_cookie_name, arg_callback) =
            (self_, url, cookie_name, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_url = WrapParamRef::<CefStringUtf16>::from(arg_url);
        let arg_url = arg_url.as_ref();
        let arg_cookie_name = WrapParamRef::<CefStringUtf16>::from(arg_cookie_name);
        let arg_cookie_name = arg_cookie_name.as_ref();
        let arg_callback =
            &mut DeleteCookiesCallback(unsafe { RefGuard::from_raw_add_ref(arg_callback) });
        arg_self_
            .interface
            .delete_cookies(arg_url, arg_cookie_name, arg_callback)
            .into()
    }
    extern "C" fn flush_store<I: ImplCookieManager>(
        self_: *mut _cef_cookie_manager_t,
        callback: *mut _cef_completion_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_callback) = (self_, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_callback =
            &mut CompletionCallback(unsafe { RefGuard::from_raw_add_ref(arg_callback) });
        arg_self_.interface.flush_store(arg_callback).into()
    }
}
#[doc = "See [_cef_cookie_manager_t] for more documentation."]
#[derive(Clone)]
pub struct CookieManager(RefGuard<_cef_cookie_manager_t>);
impl ImplCookieManager for CookieManager {
    fn visit_all_cookies<'a>(&self, visitor: &'a mut CookieVisitor) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .visit_all_cookies
                .map(|f| {
                    let arg_visitor = visitor;
                    let arg_self_ = self.as_raw();
                    let arg_visitor = arg_visitor.as_raw();
                    let result = f(arg_self_, arg_visitor);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn visit_url_cookies<'a>(
        &self,
        url: &'a CefStringUtf16,
        include_http_only: ::std::os::raw::c_int,
        visitor: &'a mut CookieVisitor,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .visit_url_cookies
                .map(|f| {
                    let (arg_url, arg_include_http_only, arg_visitor) =
                        (url, include_http_only, visitor);
                    let arg_self_ = self.as_raw();
                    let arg_url = arg_url.as_raw();
                    let arg_include_http_only = arg_include_http_only;
                    let arg_visitor = arg_visitor.as_raw();
                    let result = f(arg_self_, arg_url, arg_include_http_only, arg_visitor);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_cookie<'a>(
        &self,
        url: &'a CefStringUtf16,
        cookie: &'a Cookie,
        callback: &'a mut SetCookieCallback,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_cookie
                .map(|f| {
                    let (arg_url, arg_cookie, arg_callback) = (url, cookie, callback);
                    let arg_self_ = self.as_raw();
                    let arg_url = arg_url.as_raw();
                    let mut arg_cookie: _cef_cookie_t = arg_cookie.clone().into();
                    let arg_cookie = &mut arg_cookie;
                    let arg_callback = arg_callback.as_raw();
                    let result = f(arg_self_, arg_url, arg_cookie, arg_callback);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn delete_cookies<'a>(
        &self,
        url: &'a CefStringUtf16,
        cookie_name: &'a CefStringUtf16,
        callback: &'a mut DeleteCookiesCallback,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .delete_cookies
                .map(|f| {
                    let (arg_url, arg_cookie_name, arg_callback) = (url, cookie_name, callback);
                    let arg_self_ = self.as_raw();
                    let arg_url = arg_url.as_raw();
                    let arg_cookie_name = arg_cookie_name.as_raw();
                    let arg_callback = arg_callback.as_raw();
                    let result = f(arg_self_, arg_url, arg_cookie_name, arg_callback);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn flush_store<'a>(&self, callback: &'a mut CompletionCallback) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .flush_store
                .map(|f| {
                    let arg_callback = callback;
                    let arg_self_ = self.as_raw();
                    let arg_callback = arg_callback.as_raw();
                    let result = f(arg_self_, arg_callback);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_cookie_manager_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for CookieManager {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_cookie_manager_t> for &CookieManager {
    fn as_raw(self) -> *mut _cef_cookie_manager_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_cookie_manager_t> for &mut CookieManager {
    fn as_raw(self) -> *mut _cef_cookie_manager_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<CookieManager> for *mut _cef_cookie_manager_t {
    fn as_wrapper(self) -> CookieManager {
        CookieManager(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_cookie_manager_t> for CookieManager {
    fn into(self) -> *mut _cef_cookie_manager_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for CookieManager {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplCookieVisitor: Sized {
    fn visit<'a>(
        &self,
        cookie: &'a Cookie,
        count: ::std::os::raw::c_int,
        total: ::std::os::raw::c_int,
        delete_cookie: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_cookie_visitor_t {
        let mut object: _cef_cookie_visitor_t = unsafe { std::mem::zeroed() };
        impl_cef_cookie_visitor_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_cookie_visitor_t {
    use super::*;
    pub fn init_methods<I: ImplCookieVisitor>(object: &mut _cef_cookie_visitor_t) {
        object.visit = Some(visit::<I>);
    }
    extern "C" fn visit<I: ImplCookieVisitor>(
        self_: *mut _cef_cookie_visitor_t,
        cookie: *const _cef_cookie_t,
        count: ::std::os::raw::c_int,
        total: ::std::os::raw::c_int,
        delete_cookie: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_cookie, arg_count, arg_total, arg_delete_cookie) =
            (self_, cookie, count, total, delete_cookie);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_cookie = WrapParamRef::<Cookie>::from(arg_cookie);
        let arg_cookie = arg_cookie.as_ref();
        let arg_count = arg_count.as_raw();
        let arg_total = arg_total.as_raw();
        let mut arg_delete_cookie = WrapParamRef::<::std::os::raw::c_int>::from(arg_delete_cookie);
        let arg_delete_cookie = arg_delete_cookie.as_mut();
        arg_self_
            .interface
            .visit(arg_cookie, arg_count, arg_total, arg_delete_cookie)
            .into()
    }
}
#[doc = "See [_cef_cookie_visitor_t] for more documentation."]
#[derive(Clone)]
pub struct CookieVisitor(RefGuard<_cef_cookie_visitor_t>);
impl ImplCookieVisitor for CookieVisitor {
    fn visit<'a>(
        &self,
        cookie: &'a Cookie,
        count: ::std::os::raw::c_int,
        total: ::std::os::raw::c_int,
        delete_cookie: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .visit
                .map(|f| {
                    let (arg_cookie, arg_count, arg_total, arg_delete_cookie) =
                        (cookie, count, total, delete_cookie);
                    let arg_self_ = self.as_raw();
                    let mut arg_cookie: _cef_cookie_t = arg_cookie.clone().into();
                    let arg_cookie = &mut arg_cookie;
                    let arg_count = arg_count;
                    let arg_total = arg_total;
                    let arg_delete_cookie = arg_delete_cookie as *mut _;
                    let result = f(
                        arg_self_,
                        arg_cookie,
                        arg_count,
                        arg_total,
                        arg_delete_cookie,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_cookie_visitor_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for CookieVisitor {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_cookie_visitor_t> for &CookieVisitor {
    fn as_raw(self) -> *mut _cef_cookie_visitor_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_cookie_visitor_t> for &mut CookieVisitor {
    fn as_raw(self) -> *mut _cef_cookie_visitor_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<CookieVisitor> for *mut _cef_cookie_visitor_t {
    fn as_wrapper(self) -> CookieVisitor {
        CookieVisitor(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_cookie_visitor_t> for CookieVisitor {
    fn into(self) -> *mut _cef_cookie_visitor_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for CookieVisitor {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplSetCookieCallback: Sized {
    fn on_complete<'a>(&self, success: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_set_cookie_callback_t {
        let mut object: _cef_set_cookie_callback_t = unsafe { std::mem::zeroed() };
        impl_cef_set_cookie_callback_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_set_cookie_callback_t {
    use super::*;
    pub fn init_methods<I: ImplSetCookieCallback>(object: &mut _cef_set_cookie_callback_t) {
        object.on_complete = Some(on_complete::<I>);
    }
    extern "C" fn on_complete<I: ImplSetCookieCallback>(
        self_: *mut _cef_set_cookie_callback_t,
        success: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_success) = (self_, success);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_success = arg_success.as_raw();
        arg_self_.interface.on_complete(arg_success)
    }
}
#[doc = "See [_cef_set_cookie_callback_t] for more documentation."]
#[derive(Clone)]
pub struct SetCookieCallback(RefGuard<_cef_set_cookie_callback_t>);
impl ImplSetCookieCallback for SetCookieCallback {
    fn on_complete<'a>(&self, success: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .on_complete
                .map(|f| {
                    let arg_success = success;
                    let arg_self_ = self.as_raw();
                    let arg_success = arg_success;
                    let result = f(arg_self_, arg_success);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_set_cookie_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for SetCookieCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_set_cookie_callback_t> for &SetCookieCallback {
    fn as_raw(self) -> *mut _cef_set_cookie_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_set_cookie_callback_t> for &mut SetCookieCallback {
    fn as_raw(self) -> *mut _cef_set_cookie_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<SetCookieCallback> for *mut _cef_set_cookie_callback_t {
    fn as_wrapper(self) -> SetCookieCallback {
        SetCookieCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_set_cookie_callback_t> for SetCookieCallback {
    fn into(self) -> *mut _cef_set_cookie_callback_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for SetCookieCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplDeleteCookiesCallback: Sized {
    fn on_complete<'a>(&self, num_deleted: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_delete_cookies_callback_t {
        let mut object: _cef_delete_cookies_callback_t = unsafe { std::mem::zeroed() };
        impl_cef_delete_cookies_callback_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_delete_cookies_callback_t {
    use super::*;
    pub fn init_methods<I: ImplDeleteCookiesCallback>(object: &mut _cef_delete_cookies_callback_t) {
        object.on_complete = Some(on_complete::<I>);
    }
    extern "C" fn on_complete<I: ImplDeleteCookiesCallback>(
        self_: *mut _cef_delete_cookies_callback_t,
        num_deleted: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_num_deleted) = (self_, num_deleted);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_num_deleted = arg_num_deleted.as_raw();
        arg_self_.interface.on_complete(arg_num_deleted)
    }
}
#[doc = "See [_cef_delete_cookies_callback_t] for more documentation."]
#[derive(Clone)]
pub struct DeleteCookiesCallback(RefGuard<_cef_delete_cookies_callback_t>);
impl ImplDeleteCookiesCallback for DeleteCookiesCallback {
    fn on_complete<'a>(&self, num_deleted: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .on_complete
                .map(|f| {
                    let arg_num_deleted = num_deleted;
                    let arg_self_ = self.as_raw();
                    let arg_num_deleted = arg_num_deleted;
                    let result = f(arg_self_, arg_num_deleted);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_delete_cookies_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for DeleteCookiesCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_delete_cookies_callback_t> for &DeleteCookiesCallback {
    fn as_raw(self) -> *mut _cef_delete_cookies_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_delete_cookies_callback_t> for &mut DeleteCookiesCallback {
    fn as_raw(self) -> *mut _cef_delete_cookies_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<DeleteCookiesCallback> for *mut _cef_delete_cookies_callback_t {
    fn as_wrapper(self) -> DeleteCookiesCallback {
        DeleteCookiesCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_delete_cookies_callback_t> for DeleteCookiesCallback {
    fn into(self) -> *mut _cef_delete_cookies_callback_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for DeleteCookiesCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplMediaRouter: Sized {
    fn add_observer<'a>(&self, observer: &'a mut MediaObserver) -> Registration {
        unsafe { std::mem::zeroed() }
    }
    fn get_source<'a>(&self, urn: &'a CefStringUtf16) -> MediaSource {
        unsafe { std::mem::zeroed() }
    }
    fn notify_current_sinks<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn create_route<'a>(
        &self,
        source: &'a mut MediaSource,
        sink: &'a mut MediaSink,
        callback: &'a mut MediaRouteCreateCallback,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn notify_current_routes<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_media_router_t {
        let mut object: _cef_media_router_t = unsafe { std::mem::zeroed() };
        impl_cef_media_router_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_media_router_t {
    use super::*;
    pub fn init_methods<I: ImplMediaRouter>(object: &mut _cef_media_router_t) {
        object.add_observer = Some(add_observer::<I>);
        object.get_source = Some(get_source::<I>);
        object.notify_current_sinks = Some(notify_current_sinks::<I>);
        object.create_route = Some(create_route::<I>);
        object.notify_current_routes = Some(notify_current_routes::<I>);
    }
    extern "C" fn add_observer<I: ImplMediaRouter>(
        self_: *mut _cef_media_router_t,
        observer: *mut _cef_media_observer_t,
    ) -> *mut _cef_registration_t {
        let (arg_self_, arg_observer) = (self_, observer);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_observer = &mut MediaObserver(unsafe { RefGuard::from_raw_add_ref(arg_observer) });
        arg_self_.interface.add_observer(arg_observer).into()
    }
    extern "C" fn get_source<I: ImplMediaRouter>(
        self_: *mut _cef_media_router_t,
        urn: *const _cef_string_utf16_t,
    ) -> *mut _cef_media_source_t {
        let (arg_self_, arg_urn) = (self_, urn);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_urn = WrapParamRef::<CefStringUtf16>::from(arg_urn);
        let arg_urn = arg_urn.as_ref();
        arg_self_.interface.get_source(arg_urn).into()
    }
    extern "C" fn notify_current_sinks<I: ImplMediaRouter>(self_: *mut _cef_media_router_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.notify_current_sinks()
    }
    extern "C" fn create_route<I: ImplMediaRouter>(
        self_: *mut _cef_media_router_t,
        source: *mut _cef_media_source_t,
        sink: *mut _cef_media_sink_t,
        callback: *mut _cef_media_route_create_callback_t,
    ) {
        let (arg_self_, arg_source, arg_sink, arg_callback) = (self_, source, sink, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_source = &mut MediaSource(unsafe { RefGuard::from_raw_add_ref(arg_source) });
        let arg_sink = &mut MediaSink(unsafe { RefGuard::from_raw_add_ref(arg_sink) });
        let arg_callback =
            &mut MediaRouteCreateCallback(unsafe { RefGuard::from_raw_add_ref(arg_callback) });
        arg_self_
            .interface
            .create_route(arg_source, arg_sink, arg_callback)
    }
    extern "C" fn notify_current_routes<I: ImplMediaRouter>(self_: *mut _cef_media_router_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.notify_current_routes()
    }
}
#[doc = "See [_cef_media_router_t] for more documentation."]
#[derive(Clone)]
pub struct MediaRouter(RefGuard<_cef_media_router_t>);
impl ImplMediaRouter for MediaRouter {
    fn add_observer<'a>(&self, observer: &'a mut MediaObserver) -> Registration {
        unsafe {
            self.0
                .add_observer
                .map(|f| {
                    let arg_observer = observer;
                    let arg_self_ = self.as_raw();
                    let arg_observer = arg_observer.as_raw();
                    let result = f(arg_self_, arg_observer);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_source<'a>(&self, urn: &'a CefStringUtf16) -> MediaSource {
        unsafe {
            self.0
                .get_source
                .map(|f| {
                    let arg_urn = urn;
                    let arg_self_ = self.as_raw();
                    let arg_urn = arg_urn.as_raw();
                    let result = f(arg_self_, arg_urn);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn notify_current_sinks<'a>(&self) {
        unsafe {
            self.0
                .notify_current_sinks
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn create_route<'a>(
        &self,
        source: &'a mut MediaSource,
        sink: &'a mut MediaSink,
        callback: &'a mut MediaRouteCreateCallback,
    ) {
        unsafe {
            self.0
                .create_route
                .map(|f| {
                    let (arg_source, arg_sink, arg_callback) = (source, sink, callback);
                    let arg_self_ = self.as_raw();
                    let arg_source = arg_source.as_raw();
                    let arg_sink = arg_sink.as_raw();
                    let arg_callback = arg_callback.as_raw();
                    let result = f(arg_self_, arg_source, arg_sink, arg_callback);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn notify_current_routes<'a>(&self) {
        unsafe {
            self.0
                .notify_current_routes
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_media_router_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for MediaRouter {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_media_router_t> for &MediaRouter {
    fn as_raw(self) -> *mut _cef_media_router_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_media_router_t> for &mut MediaRouter {
    fn as_raw(self) -> *mut _cef_media_router_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<MediaRouter> for *mut _cef_media_router_t {
    fn as_wrapper(self) -> MediaRouter {
        MediaRouter(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_media_router_t> for MediaRouter {
    fn into(self) -> *mut _cef_media_router_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for MediaRouter {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplMediaObserver: Sized {
    fn on_sinks<'a>(&self, sinks: Option<&'a [Option<MediaSink>]>) {
        unsafe { std::mem::zeroed() }
    }
    fn on_routes<'a>(&self, routes: Option<&'a [Option<MediaRoute>]>) {
        unsafe { std::mem::zeroed() }
    }
    fn on_route_state_changed<'a>(
        &self,
        route: &'a mut MediaRoute,
        state: MediaRouteConnectionState,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn on_route_message_received<'a>(&self, route: &'a mut MediaRoute, message: Option<&'a [u8]>) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_media_observer_t {
        let mut object: _cef_media_observer_t = unsafe { std::mem::zeroed() };
        impl_cef_media_observer_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_media_observer_t {
    use super::*;
    pub fn init_methods<I: ImplMediaObserver>(object: &mut _cef_media_observer_t) {
        object.on_sinks = Some(on_sinks::<I>);
        object.on_routes = Some(on_routes::<I>);
        object.on_route_state_changed = Some(on_route_state_changed::<I>);
        object.on_route_message_received = Some(on_route_message_received::<I>);
    }
    extern "C" fn on_sinks<I: ImplMediaObserver>(
        self_: *mut _cef_media_observer_t,
        sinks_count: usize,
        sinks: *const *mut _cef_media_sink_t,
    ) {
        let (arg_self_, arg_sinks_count, arg_sinks) = (self_, sinks_count, sinks);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let vec_sinks = unsafe { arg_sinks.as_ref() }.map(|arg| {
            let arg =
                unsafe { std::slice::from_raw_parts(std::ptr::from_ref(arg), arg_sinks_count) };
            arg.iter()
                .map(|arg| {
                    if arg.is_null() {
                        None
                    } else {
                        Some(MediaSink(unsafe { RefGuard::from_raw_add_ref(*arg) }))
                    }
                })
                .collect::<Vec<_>>()
        });
        let arg_sinks = vec_sinks.as_ref().map(|arg| arg.as_slice());
        arg_self_.interface.on_sinks(arg_sinks)
    }
    extern "C" fn on_routes<I: ImplMediaObserver>(
        self_: *mut _cef_media_observer_t,
        routes_count: usize,
        routes: *const *mut _cef_media_route_t,
    ) {
        let (arg_self_, arg_routes_count, arg_routes) = (self_, routes_count, routes);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let vec_routes = unsafe { arg_routes.as_ref() }.map(|arg| {
            let arg =
                unsafe { std::slice::from_raw_parts(std::ptr::from_ref(arg), arg_routes_count) };
            arg.iter()
                .map(|arg| {
                    if arg.is_null() {
                        None
                    } else {
                        Some(MediaRoute(unsafe { RefGuard::from_raw_add_ref(*arg) }))
                    }
                })
                .collect::<Vec<_>>()
        });
        let arg_routes = vec_routes.as_ref().map(|arg| arg.as_slice());
        arg_self_.interface.on_routes(arg_routes)
    }
    extern "C" fn on_route_state_changed<I: ImplMediaObserver>(
        self_: *mut _cef_media_observer_t,
        route: *mut _cef_media_route_t,
        state: cef_media_route_connection_state_t,
    ) {
        let (arg_self_, arg_route, arg_state) = (self_, route, state);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_route = &mut MediaRoute(unsafe { RefGuard::from_raw_add_ref(arg_route) });
        let arg_state = arg_state.as_raw();
        arg_self_
            .interface
            .on_route_state_changed(arg_route, arg_state)
    }
    extern "C" fn on_route_message_received<I: ImplMediaObserver>(
        self_: *mut _cef_media_observer_t,
        route: *mut _cef_media_route_t,
        message: *const ::std::os::raw::c_void,
        message_size: usize,
    ) {
        let (arg_self_, arg_route, arg_message, arg_message_size) =
            (self_, route, message, message_size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_route = &mut MediaRoute(unsafe { RefGuard::from_raw_add_ref(arg_route) });
        let arg_message = (!arg_message.is_null() && arg_message_size > 0).then(|| unsafe {
            std::slice::from_raw_parts(arg_message as *const _, arg_message_size)
        });
        arg_self_
            .interface
            .on_route_message_received(arg_route, arg_message)
    }
}
#[doc = "See [_cef_media_observer_t] for more documentation."]
#[derive(Clone)]
pub struct MediaObserver(RefGuard<_cef_media_observer_t>);
impl ImplMediaObserver for MediaObserver {
    fn on_sinks<'a>(&self, sinks: Option<&'a [Option<MediaSink>]>) {
        unsafe {
            self.0
                .on_sinks
                .map(|f| {
                    let arg_sinks = sinks;
                    let arg_self_ = self.as_raw();
                    let mut arg_sinks_count =
                        arg_sinks.map(|slice| slice.len()).unwrap_or_default();
                    let vec_sinks = arg_sinks
                        .as_ref()
                        .map(|slice| {
                            slice
                                .iter()
                                .map(|elem| {
                                    elem.as_ref()
                                        .map(|elem| elem.as_raw())
                                        .unwrap_or(std::ptr::null_mut())
                                })
                                .collect::<Vec<_>>()
                        })
                        .unwrap_or_default();
                    let arg_sinks = if vec_sinks.is_empty() {
                        std::ptr::null()
                    } else {
                        vec_sinks.as_ptr()
                    };
                    let result = f(arg_self_, arg_sinks_count, arg_sinks);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_routes<'a>(&self, routes: Option<&'a [Option<MediaRoute>]>) {
        unsafe {
            self.0
                .on_routes
                .map(|f| {
                    let arg_routes = routes;
                    let arg_self_ = self.as_raw();
                    let mut arg_routes_count =
                        arg_routes.map(|slice| slice.len()).unwrap_or_default();
                    let vec_routes = arg_routes
                        .as_ref()
                        .map(|slice| {
                            slice
                                .iter()
                                .map(|elem| {
                                    elem.as_ref()
                                        .map(|elem| elem.as_raw())
                                        .unwrap_or(std::ptr::null_mut())
                                })
                                .collect::<Vec<_>>()
                        })
                        .unwrap_or_default();
                    let arg_routes = if vec_routes.is_empty() {
                        std::ptr::null()
                    } else {
                        vec_routes.as_ptr()
                    };
                    let result = f(arg_self_, arg_routes_count, arg_routes);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_route_state_changed<'a>(
        &self,
        route: &'a mut MediaRoute,
        state: MediaRouteConnectionState,
    ) {
        unsafe {
            self.0
                .on_route_state_changed
                .map(|f| {
                    let (arg_route, arg_state) = (route, state);
                    let arg_self_ = self.as_raw();
                    let arg_route = arg_route.as_raw();
                    let arg_state = arg_state.as_raw();
                    let result = f(arg_self_, arg_route, arg_state);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_route_message_received<'a>(&self, route: &'a mut MediaRoute, message: Option<&'a [u8]>) {
        unsafe {
            self.0
                .on_route_message_received
                .map(|f| {
                    let (arg_route, arg_message) = (route, message);
                    let arg_self_ = self.as_raw();
                    let arg_route = arg_route.as_raw();
                    let arg_message_size = arg_message.map(|slice| slice.len()).unwrap_or_default();
                    let out_message = arg_message;
                    let arg_message = arg_message
                        .and_then(|slice| {
                            if slice.is_empty() {
                                None
                            } else {
                                Some(slice.as_ptr() as *const _)
                            }
                        })
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_route, arg_message, arg_message_size);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_media_observer_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for MediaObserver {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_media_observer_t> for &MediaObserver {
    fn as_raw(self) -> *mut _cef_media_observer_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_media_observer_t> for &mut MediaObserver {
    fn as_raw(self) -> *mut _cef_media_observer_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<MediaObserver> for *mut _cef_media_observer_t {
    fn as_wrapper(self) -> MediaObserver {
        MediaObserver(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_media_observer_t> for MediaObserver {
    fn into(self) -> *mut _cef_media_observer_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for MediaObserver {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplMediaRoute: Sized {
    fn get_id<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_source<'a>(&self) -> MediaSource {
        unsafe { std::mem::zeroed() }
    }
    fn get_sink<'a>(&self) -> MediaSink {
        unsafe { std::mem::zeroed() }
    }
    fn send_route_message<'a>(&self, message: Option<&'a [u8]>) {
        unsafe { std::mem::zeroed() }
    }
    fn terminate<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_media_route_t {
        let mut object: _cef_media_route_t = unsafe { std::mem::zeroed() };
        impl_cef_media_route_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_media_route_t {
    use super::*;
    pub fn init_methods<I: ImplMediaRoute>(object: &mut _cef_media_route_t) {
        object.get_id = Some(get_id::<I>);
        object.get_source = Some(get_source::<I>);
        object.get_sink = Some(get_sink::<I>);
        object.send_route_message = Some(send_route_message::<I>);
        object.terminate = Some(terminate::<I>);
    }
    extern "C" fn get_id<I: ImplMediaRoute>(
        self_: *mut _cef_media_route_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_id().into()
    }
    extern "C" fn get_source<I: ImplMediaRoute>(
        self_: *mut _cef_media_route_t,
    ) -> *mut _cef_media_source_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_source().into()
    }
    extern "C" fn get_sink<I: ImplMediaRoute>(
        self_: *mut _cef_media_route_t,
    ) -> *mut _cef_media_sink_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_sink().into()
    }
    extern "C" fn send_route_message<I: ImplMediaRoute>(
        self_: *mut _cef_media_route_t,
        message: *const ::std::os::raw::c_void,
        message_size: usize,
    ) {
        let (arg_self_, arg_message, arg_message_size) = (self_, message, message_size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_message = (!arg_message.is_null() && arg_message_size > 0).then(|| unsafe {
            std::slice::from_raw_parts(arg_message as *const _, arg_message_size)
        });
        arg_self_.interface.send_route_message(arg_message)
    }
    extern "C" fn terminate<I: ImplMediaRoute>(self_: *mut _cef_media_route_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.terminate()
    }
}
#[doc = "See [_cef_media_route_t] for more documentation."]
#[derive(Clone)]
pub struct MediaRoute(RefGuard<_cef_media_route_t>);
impl ImplMediaRoute for MediaRoute {
    fn get_id<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_id
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_source<'a>(&self) -> MediaSource {
        unsafe {
            self.0
                .get_source
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_sink<'a>(&self) -> MediaSink {
        unsafe {
            self.0
                .get_sink
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn send_route_message<'a>(&self, message: Option<&'a [u8]>) {
        unsafe {
            self.0
                .send_route_message
                .map(|f| {
                    let arg_message = message;
                    let arg_self_ = self.as_raw();
                    let arg_message_size = arg_message.map(|slice| slice.len()).unwrap_or_default();
                    let out_message = arg_message;
                    let arg_message = arg_message
                        .and_then(|slice| {
                            if slice.is_empty() {
                                None
                            } else {
                                Some(slice.as_ptr() as *const _)
                            }
                        })
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_message, arg_message_size);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn terminate<'a>(&self) {
        unsafe {
            self.0
                .terminate
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_media_route_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for MediaRoute {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_media_route_t> for &MediaRoute {
    fn as_raw(self) -> *mut _cef_media_route_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_media_route_t> for &mut MediaRoute {
    fn as_raw(self) -> *mut _cef_media_route_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<MediaRoute> for *mut _cef_media_route_t {
    fn as_wrapper(self) -> MediaRoute {
        MediaRoute(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_media_route_t> for MediaRoute {
    fn into(self) -> *mut _cef_media_route_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for MediaRoute {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplMediaRouteCreateCallback: Sized {
    fn on_media_route_create_finished<'a>(
        &self,
        result: MediaRouteCreateResult,
        error: &'a CefStringUtf16,
        route: &'a mut MediaRoute,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_media_route_create_callback_t {
        let mut object: _cef_media_route_create_callback_t = unsafe { std::mem::zeroed() };
        impl_cef_media_route_create_callback_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_media_route_create_callback_t {
    use super::*;
    pub fn init_methods<I: ImplMediaRouteCreateCallback>(
        object: &mut _cef_media_route_create_callback_t,
    ) {
        object.on_media_route_create_finished = Some(on_media_route_create_finished::<I>);
    }
    extern "C" fn on_media_route_create_finished<I: ImplMediaRouteCreateCallback>(
        self_: *mut _cef_media_route_create_callback_t,
        result: cef_media_route_create_result_t,
        error: *const _cef_string_utf16_t,
        route: *mut _cef_media_route_t,
    ) {
        let (arg_self_, arg_result, arg_error, arg_route) = (self_, result, error, route);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_result = arg_result.as_raw();
        let arg_error = WrapParamRef::<CefStringUtf16>::from(arg_error);
        let arg_error = arg_error.as_ref();
        let arg_route = &mut MediaRoute(unsafe { RefGuard::from_raw_add_ref(arg_route) });
        arg_self_
            .interface
            .on_media_route_create_finished(arg_result, arg_error, arg_route)
    }
}
#[doc = "See [_cef_media_route_create_callback_t] for more documentation."]
#[derive(Clone)]
pub struct MediaRouteCreateCallback(RefGuard<_cef_media_route_create_callback_t>);
impl ImplMediaRouteCreateCallback for MediaRouteCreateCallback {
    fn on_media_route_create_finished<'a>(
        &self,
        result: MediaRouteCreateResult,
        error: &'a CefStringUtf16,
        route: &'a mut MediaRoute,
    ) {
        unsafe {
            self.0
                .on_media_route_create_finished
                .map(|f| {
                    let (arg_result, arg_error, arg_route) = (result, error, route);
                    let arg_self_ = self.as_raw();
                    let arg_result = arg_result.as_raw();
                    let arg_error = arg_error.as_raw();
                    let arg_route = arg_route.as_raw();
                    let result = f(arg_self_, arg_result, arg_error, arg_route);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_media_route_create_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for MediaRouteCreateCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_media_route_create_callback_t> for &MediaRouteCreateCallback {
    fn as_raw(self) -> *mut _cef_media_route_create_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_media_route_create_callback_t> for &mut MediaRouteCreateCallback {
    fn as_raw(self) -> *mut _cef_media_route_create_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<MediaRouteCreateCallback> for *mut _cef_media_route_create_callback_t {
    fn as_wrapper(self) -> MediaRouteCreateCallback {
        MediaRouteCreateCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_media_route_create_callback_t> for MediaRouteCreateCallback {
    fn into(self) -> *mut _cef_media_route_create_callback_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for MediaRouteCreateCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplMediaSink: Sized {
    fn get_id<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_name<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_icon_type<'a>(&self) -> MediaSinkIconType {
        unsafe { std::mem::zeroed() }
    }
    fn get_device_info<'a>(&self, callback: &'a mut MediaSinkDeviceInfoCallback) {
        unsafe { std::mem::zeroed() }
    }
    fn is_cast_sink<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_dial_sink<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_compatible_with<'a>(&self, source: &'a mut MediaSource) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_media_sink_t {
        let mut object: _cef_media_sink_t = unsafe { std::mem::zeroed() };
        impl_cef_media_sink_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_media_sink_t {
    use super::*;
    pub fn init_methods<I: ImplMediaSink>(object: &mut _cef_media_sink_t) {
        object.get_id = Some(get_id::<I>);
        object.get_name = Some(get_name::<I>);
        object.get_icon_type = Some(get_icon_type::<I>);
        object.get_device_info = Some(get_device_info::<I>);
        object.is_cast_sink = Some(is_cast_sink::<I>);
        object.is_dial_sink = Some(is_dial_sink::<I>);
        object.is_compatible_with = Some(is_compatible_with::<I>);
    }
    extern "C" fn get_id<I: ImplMediaSink>(
        self_: *mut _cef_media_sink_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_id().into()
    }
    extern "C" fn get_name<I: ImplMediaSink>(
        self_: *mut _cef_media_sink_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_name().into()
    }
    extern "C" fn get_icon_type<I: ImplMediaSink>(
        self_: *mut _cef_media_sink_t,
    ) -> cef_media_sink_icon_type_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_icon_type().into()
    }
    extern "C" fn get_device_info<I: ImplMediaSink>(
        self_: *mut _cef_media_sink_t,
        callback: *mut _cef_media_sink_device_info_callback_t,
    ) {
        let (arg_self_, arg_callback) = (self_, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_callback =
            &mut MediaSinkDeviceInfoCallback(unsafe { RefGuard::from_raw_add_ref(arg_callback) });
        arg_self_.interface.get_device_info(arg_callback)
    }
    extern "C" fn is_cast_sink<I: ImplMediaSink>(
        self_: *mut _cef_media_sink_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_cast_sink().into()
    }
    extern "C" fn is_dial_sink<I: ImplMediaSink>(
        self_: *mut _cef_media_sink_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_dial_sink().into()
    }
    extern "C" fn is_compatible_with<I: ImplMediaSink>(
        self_: *mut _cef_media_sink_t,
        source: *mut _cef_media_source_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_source) = (self_, source);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_source = &mut MediaSource(unsafe { RefGuard::from_raw_add_ref(arg_source) });
        arg_self_.interface.is_compatible_with(arg_source).into()
    }
}
#[doc = "See [_cef_media_sink_t] for more documentation."]
#[derive(Clone)]
pub struct MediaSink(RefGuard<_cef_media_sink_t>);
impl ImplMediaSink for MediaSink {
    fn get_id<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_id
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_name<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_name
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_icon_type<'a>(&self) -> MediaSinkIconType {
        unsafe {
            self.0
                .get_icon_type
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_device_info<'a>(&self, callback: &'a mut MediaSinkDeviceInfoCallback) {
        unsafe {
            self.0
                .get_device_info
                .map(|f| {
                    let arg_callback = callback;
                    let arg_self_ = self.as_raw();
                    let arg_callback = arg_callback.as_raw();
                    let result = f(arg_self_, arg_callback);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_cast_sink<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_cast_sink
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_dial_sink<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_dial_sink
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_compatible_with<'a>(&self, source: &'a mut MediaSource) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_compatible_with
                .map(|f| {
                    let arg_source = source;
                    let arg_self_ = self.as_raw();
                    let arg_source = arg_source.as_raw();
                    let result = f(arg_self_, arg_source);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_media_sink_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for MediaSink {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_media_sink_t> for &MediaSink {
    fn as_raw(self) -> *mut _cef_media_sink_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_media_sink_t> for &mut MediaSink {
    fn as_raw(self) -> *mut _cef_media_sink_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<MediaSink> for *mut _cef_media_sink_t {
    fn as_wrapper(self) -> MediaSink {
        MediaSink(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_media_sink_t> for MediaSink {
    fn into(self) -> *mut _cef_media_sink_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for MediaSink {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplMediaSinkDeviceInfoCallback: Sized {
    fn on_media_sink_device_info<'a>(&self, device_info: &'a MediaSinkDeviceInfo) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_media_sink_device_info_callback_t {
        let mut object: _cef_media_sink_device_info_callback_t = unsafe { std::mem::zeroed() };
        impl_cef_media_sink_device_info_callback_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_media_sink_device_info_callback_t {
    use super::*;
    pub fn init_methods<I: ImplMediaSinkDeviceInfoCallback>(
        object: &mut _cef_media_sink_device_info_callback_t,
    ) {
        object.on_media_sink_device_info = Some(on_media_sink_device_info::<I>);
    }
    extern "C" fn on_media_sink_device_info<I: ImplMediaSinkDeviceInfoCallback>(
        self_: *mut _cef_media_sink_device_info_callback_t,
        device_info: *const _cef_media_sink_device_info_t,
    ) {
        let (arg_self_, arg_device_info) = (self_, device_info);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_device_info = WrapParamRef::<MediaSinkDeviceInfo>::from(arg_device_info);
        let arg_device_info = arg_device_info.as_ref();
        arg_self_
            .interface
            .on_media_sink_device_info(arg_device_info)
    }
}
#[doc = "See [_cef_media_sink_device_info_callback_t] for more documentation."]
#[derive(Clone)]
pub struct MediaSinkDeviceInfoCallback(RefGuard<_cef_media_sink_device_info_callback_t>);
impl ImplMediaSinkDeviceInfoCallback for MediaSinkDeviceInfoCallback {
    fn on_media_sink_device_info<'a>(&self, device_info: &'a MediaSinkDeviceInfo) {
        unsafe {
            self.0
                .on_media_sink_device_info
                .map(|f| {
                    let arg_device_info = device_info;
                    let arg_self_ = self.as_raw();
                    let mut arg_device_info: _cef_media_sink_device_info_t =
                        arg_device_info.clone().into();
                    let arg_device_info = &mut arg_device_info;
                    let result = f(arg_self_, arg_device_info);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_media_sink_device_info_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for MediaSinkDeviceInfoCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_media_sink_device_info_callback_t> for &MediaSinkDeviceInfoCallback {
    fn as_raw(self) -> *mut _cef_media_sink_device_info_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_media_sink_device_info_callback_t>
    for &mut MediaSinkDeviceInfoCallback
{
    fn as_raw(self) -> *mut _cef_media_sink_device_info_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<MediaSinkDeviceInfoCallback>
    for *mut _cef_media_sink_device_info_callback_t
{
    fn as_wrapper(self) -> MediaSinkDeviceInfoCallback {
        MediaSinkDeviceInfoCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_media_sink_device_info_callback_t> for MediaSinkDeviceInfoCallback {
    fn into(self) -> *mut _cef_media_sink_device_info_callback_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for MediaSinkDeviceInfoCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplMediaSource: Sized {
    fn get_id<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn is_cast_source<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_dial_source<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_media_source_t {
        let mut object: _cef_media_source_t = unsafe { std::mem::zeroed() };
        impl_cef_media_source_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_media_source_t {
    use super::*;
    pub fn init_methods<I: ImplMediaSource>(object: &mut _cef_media_source_t) {
        object.get_id = Some(get_id::<I>);
        object.is_cast_source = Some(is_cast_source::<I>);
        object.is_dial_source = Some(is_dial_source::<I>);
    }
    extern "C" fn get_id<I: ImplMediaSource>(
        self_: *mut _cef_media_source_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_id().into()
    }
    extern "C" fn is_cast_source<I: ImplMediaSource>(
        self_: *mut _cef_media_source_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_cast_source().into()
    }
    extern "C" fn is_dial_source<I: ImplMediaSource>(
        self_: *mut _cef_media_source_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_dial_source().into()
    }
}
#[doc = "See [_cef_media_source_t] for more documentation."]
#[derive(Clone)]
pub struct MediaSource(RefGuard<_cef_media_source_t>);
impl ImplMediaSource for MediaSource {
    fn get_id<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_id
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_cast_source<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_cast_source
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_dial_source<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_dial_source
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_media_source_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for MediaSource {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_media_source_t> for &MediaSource {
    fn as_raw(self) -> *mut _cef_media_source_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_media_source_t> for &mut MediaSource {
    fn as_raw(self) -> *mut _cef_media_source_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<MediaSource> for *mut _cef_media_source_t {
    fn as_wrapper(self) -> MediaSource {
        MediaSource(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_media_source_t> for MediaSource {
    fn into(self) -> *mut _cef_media_source_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for MediaSource {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [_cef_preference_registrar_t] for more documentation."]
#[repr(transparent)]
pub struct PreferenceRegistrar(_cef_preference_registrar_t);
impl From<_cef_preference_registrar_t> for PreferenceRegistrar {
    fn from(value: _cef_preference_registrar_t) -> Self {
        Self(value)
    }
}
impl Into<*const _cef_preference_registrar_t> for &PreferenceRegistrar {
    fn into(self) -> *const _cef_preference_registrar_t {
        self.as_ref() as *const _cef_preference_registrar_t
    }
}
impl Into<*mut _cef_preference_registrar_t> for &mut PreferenceRegistrar {
    fn into(self) -> *mut _cef_preference_registrar_t {
        self.as_mut() as *mut _cef_preference_registrar_t
    }
}
impl Into<_cef_preference_registrar_t> for PreferenceRegistrar {
    fn into(self) -> _cef_preference_registrar_t {
        self.0
    }
}
impl AsRef<_cef_preference_registrar_t> for PreferenceRegistrar {
    fn as_ref(&self) -> &_cef_preference_registrar_t {
        &self.0
    }
}
impl AsMut<_cef_preference_registrar_t> for PreferenceRegistrar {
    fn as_mut(&mut self) -> &mut _cef_preference_registrar_t {
        &mut self.0
    }
}
impl Default for PreferenceRegistrar {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplPreferenceManager: Sized {
    fn has_preference<'a>(&self, name: &'a CefStringUtf16) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_preference<'a>(&self, name: &'a CefStringUtf16) -> Value {
        unsafe { std::mem::zeroed() }
    }
    fn get_all_preferences<'a>(&self, include_defaults: ::std::os::raw::c_int) -> DictionaryValue {
        unsafe { std::mem::zeroed() }
    }
    fn can_set_preference<'a>(&self, name: &'a CefStringUtf16) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_preference<'a>(
        &self,
        name: &'a CefStringUtf16,
        value: &'a mut Value,
        error: &'a mut CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_preference_manager_t {
        let mut object: _cef_preference_manager_t = unsafe { std::mem::zeroed() };
        impl_cef_preference_manager_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_preference_manager_t {
    use super::*;
    pub fn init_methods<I: ImplPreferenceManager>(object: &mut _cef_preference_manager_t) {
        object.has_preference = Some(has_preference::<I>);
        object.get_preference = Some(get_preference::<I>);
        object.get_all_preferences = Some(get_all_preferences::<I>);
        object.can_set_preference = Some(can_set_preference::<I>);
        object.set_preference = Some(set_preference::<I>);
    }
    extern "C" fn has_preference<I: ImplPreferenceManager>(
        self_: *mut _cef_preference_manager_t,
        name: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_name) = (self_, name);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = WrapParamRef::<CefStringUtf16>::from(arg_name);
        let arg_name = arg_name.as_ref();
        arg_self_.interface.has_preference(arg_name).into()
    }
    extern "C" fn get_preference<I: ImplPreferenceManager>(
        self_: *mut _cef_preference_manager_t,
        name: *const _cef_string_utf16_t,
    ) -> *mut _cef_value_t {
        let (arg_self_, arg_name) = (self_, name);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = WrapParamRef::<CefStringUtf16>::from(arg_name);
        let arg_name = arg_name.as_ref();
        arg_self_.interface.get_preference(arg_name).into()
    }
    extern "C" fn get_all_preferences<I: ImplPreferenceManager>(
        self_: *mut _cef_preference_manager_t,
        include_defaults: ::std::os::raw::c_int,
    ) -> *mut _cef_dictionary_value_t {
        let (arg_self_, arg_include_defaults) = (self_, include_defaults);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_include_defaults = arg_include_defaults.as_raw();
        arg_self_
            .interface
            .get_all_preferences(arg_include_defaults)
            .into()
    }
    extern "C" fn can_set_preference<I: ImplPreferenceManager>(
        self_: *mut _cef_preference_manager_t,
        name: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_name) = (self_, name);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = WrapParamRef::<CefStringUtf16>::from(arg_name);
        let arg_name = arg_name.as_ref();
        arg_self_.interface.can_set_preference(arg_name).into()
    }
    extern "C" fn set_preference<I: ImplPreferenceManager>(
        self_: *mut _cef_preference_manager_t,
        name: *const _cef_string_utf16_t,
        value: *mut _cef_value_t,
        error: *mut _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_name, arg_value, arg_error) = (self_, name, value, error);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = WrapParamRef::<CefStringUtf16>::from(arg_name);
        let arg_name = arg_name.as_ref();
        let arg_value = &mut Value(unsafe { RefGuard::from_raw_add_ref(arg_value) });
        let mut arg_error = WrapParamRef::<CefStringUtf16>::from(arg_error);
        let arg_error = arg_error.as_mut();
        arg_self_
            .interface
            .set_preference(arg_name, arg_value, arg_error)
            .into()
    }
}
#[doc = "See [_cef_preference_manager_t] for more documentation."]
#[derive(Clone)]
pub struct PreferenceManager(RefGuard<_cef_preference_manager_t>);
impl ImplPreferenceManager for PreferenceManager {
    fn has_preference<'a>(&self, name: &'a CefStringUtf16) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_preference
                .map(|f| {
                    let arg_name = name;
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.as_raw();
                    let result = f(arg_self_, arg_name);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_preference<'a>(&self, name: &'a CefStringUtf16) -> Value {
        unsafe {
            self.0
                .get_preference
                .map(|f| {
                    let arg_name = name;
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.as_raw();
                    let result = f(arg_self_, arg_name);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_all_preferences<'a>(&self, include_defaults: ::std::os::raw::c_int) -> DictionaryValue {
        unsafe {
            self.0
                .get_all_preferences
                .map(|f| {
                    let arg_include_defaults = include_defaults;
                    let arg_self_ = self.as_raw();
                    let arg_include_defaults = arg_include_defaults;
                    let result = f(arg_self_, arg_include_defaults);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn can_set_preference<'a>(&self, name: &'a CefStringUtf16) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .can_set_preference
                .map(|f| {
                    let arg_name = name;
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.as_raw();
                    let result = f(arg_self_, arg_name);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_preference<'a>(
        &self,
        name: &'a CefStringUtf16,
        value: &'a mut Value,
        error: &'a mut CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_preference
                .map(|f| {
                    let (arg_name, arg_value, arg_error) = (name, value, error);
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.as_raw();
                    let arg_value = arg_value.as_raw();
                    let arg_error = arg_error.as_raw();
                    let result = f(arg_self_, arg_name, arg_value, arg_error);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_preference_manager_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for PreferenceManager {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_preference_manager_t> for &PreferenceManager {
    fn as_raw(self) -> *mut _cef_preference_manager_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_preference_manager_t> for &mut PreferenceManager {
    fn as_raw(self) -> *mut _cef_preference_manager_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<PreferenceManager> for *mut _cef_preference_manager_t {
    fn as_wrapper(self) -> PreferenceManager {
        PreferenceManager(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_preference_manager_t> for PreferenceManager {
    fn into(self) -> *mut _cef_preference_manager_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for PreferenceManager {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplResolveCallback: Sized {
    fn on_resolve_completed<'a>(&self, result: Errorcode, resolved_ips: &'a mut CefStringList) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_resolve_callback_t {
        let mut object: _cef_resolve_callback_t = unsafe { std::mem::zeroed() };
        impl_cef_resolve_callback_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_resolve_callback_t {
    use super::*;
    pub fn init_methods<I: ImplResolveCallback>(object: &mut _cef_resolve_callback_t) {
        object.on_resolve_completed = Some(on_resolve_completed::<I>);
    }
    extern "C" fn on_resolve_completed<I: ImplResolveCallback>(
        self_: *mut _cef_resolve_callback_t,
        result: cef_errorcode_t,
        resolved_ips: *mut _cef_string_list_t,
    ) {
        let (arg_self_, arg_result, arg_resolved_ips) = (self_, result, resolved_ips);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_result = arg_result.as_raw();
        let mut arg_resolved_ips = WrapParamRef::<CefStringList>::from(arg_resolved_ips);
        let arg_resolved_ips = arg_resolved_ips.as_mut();
        arg_self_
            .interface
            .on_resolve_completed(arg_result, arg_resolved_ips)
    }
}
#[doc = "See [_cef_resolve_callback_t] for more documentation."]
#[derive(Clone)]
pub struct ResolveCallback(RefGuard<_cef_resolve_callback_t>);
impl ImplResolveCallback for ResolveCallback {
    fn on_resolve_completed<'a>(&self, result: Errorcode, resolved_ips: &'a mut CefStringList) {
        unsafe {
            self.0
                .on_resolve_completed
                .map(|f| {
                    let (arg_result, arg_resolved_ips) = (result, resolved_ips);
                    let arg_self_ = self.as_raw();
                    let arg_result = arg_result.as_raw();
                    let arg_resolved_ips = arg_resolved_ips.as_raw();
                    let result = f(arg_self_, arg_result, arg_resolved_ips);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_resolve_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ResolveCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_resolve_callback_t> for &ResolveCallback {
    fn as_raw(self) -> *mut _cef_resolve_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_resolve_callback_t> for &mut ResolveCallback {
    fn as_raw(self) -> *mut _cef_resolve_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<ResolveCallback> for *mut _cef_resolve_callback_t {
    fn as_wrapper(self) -> ResolveCallback {
        ResolveCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_resolve_callback_t> for ResolveCallback {
    fn into(self) -> *mut _cef_resolve_callback_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for ResolveCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplRequestContext: ImplPreferenceManager {
    fn is_same<'a>(&self, other: &'a mut RequestContext) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_sharing_with<'a>(&self, other: &'a mut RequestContext) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_global<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_handler<'a>(&self) -> RequestContextHandler {
        unsafe { std::mem::zeroed() }
    }
    fn get_cache_path<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_cookie_manager<'a>(&self, callback: &'a mut CompletionCallback) -> CookieManager {
        unsafe { std::mem::zeroed() }
    }
    fn register_scheme_handler_factory<'a>(
        &self,
        scheme_name: &'a CefStringUtf16,
        domain_name: &'a CefStringUtf16,
        factory: &'a mut SchemeHandlerFactory,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn clear_scheme_handler_factories<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn clear_certificate_exceptions<'a>(&self, callback: &'a mut CompletionCallback) {
        unsafe { std::mem::zeroed() }
    }
    fn clear_http_auth_credentials<'a>(&self, callback: &'a mut CompletionCallback) {
        unsafe { std::mem::zeroed() }
    }
    fn close_all_connections<'a>(&self, callback: &'a mut CompletionCallback) {
        unsafe { std::mem::zeroed() }
    }
    fn resolve_host<'a>(&self, origin: &'a CefStringUtf16, callback: &'a mut ResolveCallback) {
        unsafe { std::mem::zeroed() }
    }
    fn get_media_router<'a>(&self, callback: &'a mut CompletionCallback) -> MediaRouter {
        unsafe { std::mem::zeroed() }
    }
    fn get_website_setting<'a>(
        &self,
        requesting_url: &'a CefStringUtf16,
        top_level_url: &'a CefStringUtf16,
        content_type: ContentSettingTypes,
    ) -> Value {
        unsafe { std::mem::zeroed() }
    }
    fn set_website_setting<'a>(
        &self,
        requesting_url: &'a CefStringUtf16,
        top_level_url: &'a CefStringUtf16,
        content_type: ContentSettingTypes,
        value: &'a mut Value,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn get_content_setting<'a>(
        &self,
        requesting_url: &'a CefStringUtf16,
        top_level_url: &'a CefStringUtf16,
        content_type: ContentSettingTypes,
    ) -> ContentSettingValues {
        unsafe { std::mem::zeroed() }
    }
    fn set_content_setting<'a>(
        &self,
        requesting_url: &'a CefStringUtf16,
        top_level_url: &'a CefStringUtf16,
        content_type: ContentSettingTypes,
        value: ContentSettingValues,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn set_chrome_color_scheme<'a>(&self, variant: ColorVariant, user_color: u32) {
        unsafe { std::mem::zeroed() }
    }
    fn get_chrome_color_scheme_mode<'a>(&self) -> ColorVariant {
        unsafe { std::mem::zeroed() }
    }
    fn get_chrome_color_scheme_color<'a>(&self) -> cef_color_t {
        unsafe { std::mem::zeroed() }
    }
    fn get_chrome_color_scheme_variant<'a>(&self) -> ColorVariant {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_request_context_t {
        let mut object: _cef_request_context_t = unsafe { std::mem::zeroed() };
        impl_cef_preference_manager_t::init_methods::<Self>(&mut object.base);
        impl_cef_request_context_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_request_context_t {
    use super::*;
    pub fn init_methods<I: ImplRequestContext>(object: &mut _cef_request_context_t) {
        object.is_same = Some(is_same::<I>);
        object.is_sharing_with = Some(is_sharing_with::<I>);
        object.is_global = Some(is_global::<I>);
        object.get_handler = Some(get_handler::<I>);
        object.get_cache_path = Some(get_cache_path::<I>);
        object.get_cookie_manager = Some(get_cookie_manager::<I>);
        object.register_scheme_handler_factory = Some(register_scheme_handler_factory::<I>);
        object.clear_scheme_handler_factories = Some(clear_scheme_handler_factories::<I>);
        object.clear_certificate_exceptions = Some(clear_certificate_exceptions::<I>);
        object.clear_http_auth_credentials = Some(clear_http_auth_credentials::<I>);
        object.close_all_connections = Some(close_all_connections::<I>);
        object.resolve_host = Some(resolve_host::<I>);
        object.get_media_router = Some(get_media_router::<I>);
        object.get_website_setting = Some(get_website_setting::<I>);
        object.set_website_setting = Some(set_website_setting::<I>);
        object.get_content_setting = Some(get_content_setting::<I>);
        object.set_content_setting = Some(set_content_setting::<I>);
        object.set_chrome_color_scheme = Some(set_chrome_color_scheme::<I>);
        object.get_chrome_color_scheme_mode = Some(get_chrome_color_scheme_mode::<I>);
        object.get_chrome_color_scheme_color = Some(get_chrome_color_scheme_color::<I>);
        object.get_chrome_color_scheme_variant = Some(get_chrome_color_scheme_variant::<I>);
    }
    extern "C" fn is_same<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
        other: *mut _cef_request_context_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_other) = (self_, other);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_other = &mut RequestContext(unsafe { RefGuard::from_raw_add_ref(arg_other) });
        arg_self_.interface.is_same(arg_other).into()
    }
    extern "C" fn is_sharing_with<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
        other: *mut _cef_request_context_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_other) = (self_, other);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_other = &mut RequestContext(unsafe { RefGuard::from_raw_add_ref(arg_other) });
        arg_self_.interface.is_sharing_with(arg_other).into()
    }
    extern "C" fn is_global<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_global().into()
    }
    extern "C" fn get_handler<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
    ) -> *mut _cef_request_context_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_handler().into()
    }
    extern "C" fn get_cache_path<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_cache_path().into()
    }
    extern "C" fn get_cookie_manager<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
        callback: *mut _cef_completion_callback_t,
    ) -> *mut _cef_cookie_manager_t {
        let (arg_self_, arg_callback) = (self_, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_callback =
            &mut CompletionCallback(unsafe { RefGuard::from_raw_add_ref(arg_callback) });
        arg_self_.interface.get_cookie_manager(arg_callback).into()
    }
    extern "C" fn register_scheme_handler_factory<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
        scheme_name: *const _cef_string_utf16_t,
        domain_name: *const _cef_string_utf16_t,
        factory: *mut _cef_scheme_handler_factory_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_scheme_name, arg_domain_name, arg_factory) =
            (self_, scheme_name, domain_name, factory);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_scheme_name = WrapParamRef::<CefStringUtf16>::from(arg_scheme_name);
        let arg_scheme_name = arg_scheme_name.as_ref();
        let arg_domain_name = WrapParamRef::<CefStringUtf16>::from(arg_domain_name);
        let arg_domain_name = arg_domain_name.as_ref();
        let arg_factory =
            &mut SchemeHandlerFactory(unsafe { RefGuard::from_raw_add_ref(arg_factory) });
        arg_self_
            .interface
            .register_scheme_handler_factory(arg_scheme_name, arg_domain_name, arg_factory)
            .into()
    }
    extern "C" fn clear_scheme_handler_factories<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.clear_scheme_handler_factories().into()
    }
    extern "C" fn clear_certificate_exceptions<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
        callback: *mut _cef_completion_callback_t,
    ) {
        let (arg_self_, arg_callback) = (self_, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_callback =
            &mut CompletionCallback(unsafe { RefGuard::from_raw_add_ref(arg_callback) });
        arg_self_
            .interface
            .clear_certificate_exceptions(arg_callback)
    }
    extern "C" fn clear_http_auth_credentials<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
        callback: *mut _cef_completion_callback_t,
    ) {
        let (arg_self_, arg_callback) = (self_, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_callback =
            &mut CompletionCallback(unsafe { RefGuard::from_raw_add_ref(arg_callback) });
        arg_self_
            .interface
            .clear_http_auth_credentials(arg_callback)
    }
    extern "C" fn close_all_connections<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
        callback: *mut _cef_completion_callback_t,
    ) {
        let (arg_self_, arg_callback) = (self_, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_callback =
            &mut CompletionCallback(unsafe { RefGuard::from_raw_add_ref(arg_callback) });
        arg_self_.interface.close_all_connections(arg_callback)
    }
    extern "C" fn resolve_host<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
        origin: *const _cef_string_utf16_t,
        callback: *mut _cef_resolve_callback_t,
    ) {
        let (arg_self_, arg_origin, arg_callback) = (self_, origin, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_origin = WrapParamRef::<CefStringUtf16>::from(arg_origin);
        let arg_origin = arg_origin.as_ref();
        let arg_callback =
            &mut ResolveCallback(unsafe { RefGuard::from_raw_add_ref(arg_callback) });
        arg_self_.interface.resolve_host(arg_origin, arg_callback)
    }
    extern "C" fn get_media_router<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
        callback: *mut _cef_completion_callback_t,
    ) -> *mut _cef_media_router_t {
        let (arg_self_, arg_callback) = (self_, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_callback =
            &mut CompletionCallback(unsafe { RefGuard::from_raw_add_ref(arg_callback) });
        arg_self_.interface.get_media_router(arg_callback).into()
    }
    extern "C" fn get_website_setting<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
        requesting_url: *const _cef_string_utf16_t,
        top_level_url: *const _cef_string_utf16_t,
        content_type: cef_content_setting_types_t,
    ) -> *mut _cef_value_t {
        let (arg_self_, arg_requesting_url, arg_top_level_url, arg_content_type) =
            (self_, requesting_url, top_level_url, content_type);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_requesting_url = WrapParamRef::<CefStringUtf16>::from(arg_requesting_url);
        let arg_requesting_url = arg_requesting_url.as_ref();
        let arg_top_level_url = WrapParamRef::<CefStringUtf16>::from(arg_top_level_url);
        let arg_top_level_url = arg_top_level_url.as_ref();
        let arg_content_type = arg_content_type.as_raw();
        arg_self_
            .interface
            .get_website_setting(arg_requesting_url, arg_top_level_url, arg_content_type)
            .into()
    }
    extern "C" fn set_website_setting<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
        requesting_url: *const _cef_string_utf16_t,
        top_level_url: *const _cef_string_utf16_t,
        content_type: cef_content_setting_types_t,
        value: *mut _cef_value_t,
    ) {
        let (arg_self_, arg_requesting_url, arg_top_level_url, arg_content_type, arg_value) =
            (self_, requesting_url, top_level_url, content_type, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_requesting_url = WrapParamRef::<CefStringUtf16>::from(arg_requesting_url);
        let arg_requesting_url = arg_requesting_url.as_ref();
        let arg_top_level_url = WrapParamRef::<CefStringUtf16>::from(arg_top_level_url);
        let arg_top_level_url = arg_top_level_url.as_ref();
        let arg_content_type = arg_content_type.as_raw();
        let arg_value = &mut Value(unsafe { RefGuard::from_raw_add_ref(arg_value) });
        arg_self_.interface.set_website_setting(
            arg_requesting_url,
            arg_top_level_url,
            arg_content_type,
            arg_value,
        )
    }
    extern "C" fn get_content_setting<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
        requesting_url: *const _cef_string_utf16_t,
        top_level_url: *const _cef_string_utf16_t,
        content_type: cef_content_setting_types_t,
    ) -> cef_content_setting_values_t {
        let (arg_self_, arg_requesting_url, arg_top_level_url, arg_content_type) =
            (self_, requesting_url, top_level_url, content_type);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_requesting_url = WrapParamRef::<CefStringUtf16>::from(arg_requesting_url);
        let arg_requesting_url = arg_requesting_url.as_ref();
        let arg_top_level_url = WrapParamRef::<CefStringUtf16>::from(arg_top_level_url);
        let arg_top_level_url = arg_top_level_url.as_ref();
        let arg_content_type = arg_content_type.as_raw();
        arg_self_
            .interface
            .get_content_setting(arg_requesting_url, arg_top_level_url, arg_content_type)
            .into()
    }
    extern "C" fn set_content_setting<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
        requesting_url: *const _cef_string_utf16_t,
        top_level_url: *const _cef_string_utf16_t,
        content_type: cef_content_setting_types_t,
        value: cef_content_setting_values_t,
    ) {
        let (arg_self_, arg_requesting_url, arg_top_level_url, arg_content_type, arg_value) =
            (self_, requesting_url, top_level_url, content_type, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_requesting_url = WrapParamRef::<CefStringUtf16>::from(arg_requesting_url);
        let arg_requesting_url = arg_requesting_url.as_ref();
        let arg_top_level_url = WrapParamRef::<CefStringUtf16>::from(arg_top_level_url);
        let arg_top_level_url = arg_top_level_url.as_ref();
        let arg_content_type = arg_content_type.as_raw();
        let arg_value = arg_value.as_raw();
        arg_self_.interface.set_content_setting(
            arg_requesting_url,
            arg_top_level_url,
            arg_content_type,
            arg_value,
        )
    }
    extern "C" fn set_chrome_color_scheme<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
        variant: cef_color_variant_t,
        user_color: u32,
    ) {
        let (arg_self_, arg_variant, arg_user_color) = (self_, variant, user_color);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_variant = arg_variant.as_raw();
        let arg_user_color = arg_user_color.as_raw();
        arg_self_
            .interface
            .set_chrome_color_scheme(arg_variant, arg_user_color)
    }
    extern "C" fn get_chrome_color_scheme_mode<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
    ) -> cef_color_variant_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_chrome_color_scheme_mode().into()
    }
    extern "C" fn get_chrome_color_scheme_color<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
    ) -> u32 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_chrome_color_scheme_color().into()
    }
    extern "C" fn get_chrome_color_scheme_variant<I: ImplRequestContext>(
        self_: *mut _cef_request_context_t,
    ) -> cef_color_variant_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_chrome_color_scheme_variant().into()
    }
}
#[doc = "See [_cef_request_context_t] for more documentation."]
#[derive(Clone)]
pub struct RequestContext(RefGuard<_cef_request_context_t>);
impl ImplPreferenceManager for RequestContext {
    fn has_preference<'a>(&self, name: &'a CefStringUtf16) -> ::std::os::raw::c_int {
        PreferenceManager(unsafe {
            RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _)
        })
        .has_preference(name)
    }
    fn get_preference<'a>(&self, name: &'a CefStringUtf16) -> Value {
        PreferenceManager(unsafe {
            RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _)
        })
        .get_preference(name)
    }
    fn get_all_preferences<'a>(&self, include_defaults: ::std::os::raw::c_int) -> DictionaryValue {
        PreferenceManager(unsafe {
            RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _)
        })
        .get_all_preferences(include_defaults)
    }
    fn can_set_preference<'a>(&self, name: &'a CefStringUtf16) -> ::std::os::raw::c_int {
        PreferenceManager(unsafe {
            RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _)
        })
        .can_set_preference(name)
    }
    fn set_preference<'a>(
        &self,
        name: &'a CefStringUtf16,
        value: &'a mut Value,
        error: &'a mut CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        PreferenceManager(unsafe {
            RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _)
        })
        .set_preference(name, value, error)
    }
}
impl ImplRequestContext for RequestContext {
    fn is_same<'a>(&self, other: &'a mut RequestContext) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_same
                .map(|f| {
                    let arg_other = other;
                    let arg_self_ = self.as_raw();
                    let arg_other = arg_other.as_raw();
                    let result = f(arg_self_, arg_other);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_sharing_with<'a>(&self, other: &'a mut RequestContext) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_sharing_with
                .map(|f| {
                    let arg_other = other;
                    let arg_self_ = self.as_raw();
                    let arg_other = arg_other.as_raw();
                    let result = f(arg_self_, arg_other);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_global<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_global
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_handler<'a>(&self) -> RequestContextHandler {
        unsafe {
            self.0
                .get_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_cache_path<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_cache_path
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_cookie_manager<'a>(&self, callback: &'a mut CompletionCallback) -> CookieManager {
        unsafe {
            self.0
                .get_cookie_manager
                .map(|f| {
                    let arg_callback = callback;
                    let arg_self_ = self.as_raw();
                    let arg_callback = arg_callback.as_raw();
                    let result = f(arg_self_, arg_callback);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn register_scheme_handler_factory<'a>(
        &self,
        scheme_name: &'a CefStringUtf16,
        domain_name: &'a CefStringUtf16,
        factory: &'a mut SchemeHandlerFactory,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .register_scheme_handler_factory
                .map(|f| {
                    let (arg_scheme_name, arg_domain_name, arg_factory) =
                        (scheme_name, domain_name, factory);
                    let arg_self_ = self.as_raw();
                    let arg_scheme_name = arg_scheme_name.as_raw();
                    let arg_domain_name = arg_domain_name.as_raw();
                    let arg_factory = arg_factory.as_raw();
                    let result = f(arg_self_, arg_scheme_name, arg_domain_name, arg_factory);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn clear_scheme_handler_factories<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .clear_scheme_handler_factories
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn clear_certificate_exceptions<'a>(&self, callback: &'a mut CompletionCallback) {
        unsafe {
            self.0
                .clear_certificate_exceptions
                .map(|f| {
                    let arg_callback = callback;
                    let arg_self_ = self.as_raw();
                    let arg_callback = arg_callback.as_raw();
                    let result = f(arg_self_, arg_callback);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn clear_http_auth_credentials<'a>(&self, callback: &'a mut CompletionCallback) {
        unsafe {
            self.0
                .clear_http_auth_credentials
                .map(|f| {
                    let arg_callback = callback;
                    let arg_self_ = self.as_raw();
                    let arg_callback = arg_callback.as_raw();
                    let result = f(arg_self_, arg_callback);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn close_all_connections<'a>(&self, callback: &'a mut CompletionCallback) {
        unsafe {
            self.0
                .close_all_connections
                .map(|f| {
                    let arg_callback = callback;
                    let arg_self_ = self.as_raw();
                    let arg_callback = arg_callback.as_raw();
                    let result = f(arg_self_, arg_callback);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn resolve_host<'a>(&self, origin: &'a CefStringUtf16, callback: &'a mut ResolveCallback) {
        unsafe {
            self.0
                .resolve_host
                .map(|f| {
                    let (arg_origin, arg_callback) = (origin, callback);
                    let arg_self_ = self.as_raw();
                    let arg_origin = arg_origin.as_raw();
                    let arg_callback = arg_callback.as_raw();
                    let result = f(arg_self_, arg_origin, arg_callback);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_media_router<'a>(&self, callback: &'a mut CompletionCallback) -> MediaRouter {
        unsafe {
            self.0
                .get_media_router
                .map(|f| {
                    let arg_callback = callback;
                    let arg_self_ = self.as_raw();
                    let arg_callback = arg_callback.as_raw();
                    let result = f(arg_self_, arg_callback);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_website_setting<'a>(
        &self,
        requesting_url: &'a CefStringUtf16,
        top_level_url: &'a CefStringUtf16,
        content_type: ContentSettingTypes,
    ) -> Value {
        unsafe {
            self.0
                .get_website_setting
                .map(|f| {
                    let (arg_requesting_url, arg_top_level_url, arg_content_type) =
                        (requesting_url, top_level_url, content_type);
                    let arg_self_ = self.as_raw();
                    let arg_requesting_url = arg_requesting_url.as_raw();
                    let arg_top_level_url = arg_top_level_url.as_raw();
                    let arg_content_type = arg_content_type.as_raw();
                    let result = f(
                        arg_self_,
                        arg_requesting_url,
                        arg_top_level_url,
                        arg_content_type,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_website_setting<'a>(
        &self,
        requesting_url: &'a CefStringUtf16,
        top_level_url: &'a CefStringUtf16,
        content_type: ContentSettingTypes,
        value: &'a mut Value,
    ) {
        unsafe {
            self.0
                .set_website_setting
                .map(|f| {
                    let (arg_requesting_url, arg_top_level_url, arg_content_type, arg_value) =
                        (requesting_url, top_level_url, content_type, value);
                    let arg_self_ = self.as_raw();
                    let arg_requesting_url = arg_requesting_url.as_raw();
                    let arg_top_level_url = arg_top_level_url.as_raw();
                    let arg_content_type = arg_content_type.as_raw();
                    let arg_value = arg_value.as_raw();
                    let result = f(
                        arg_self_,
                        arg_requesting_url,
                        arg_top_level_url,
                        arg_content_type,
                        arg_value,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_content_setting<'a>(
        &self,
        requesting_url: &'a CefStringUtf16,
        top_level_url: &'a CefStringUtf16,
        content_type: ContentSettingTypes,
    ) -> ContentSettingValues {
        unsafe {
            self.0
                .get_content_setting
                .map(|f| {
                    let (arg_requesting_url, arg_top_level_url, arg_content_type) =
                        (requesting_url, top_level_url, content_type);
                    let arg_self_ = self.as_raw();
                    let arg_requesting_url = arg_requesting_url.as_raw();
                    let arg_top_level_url = arg_top_level_url.as_raw();
                    let arg_content_type = arg_content_type.as_raw();
                    let result = f(
                        arg_self_,
                        arg_requesting_url,
                        arg_top_level_url,
                        arg_content_type,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_content_setting<'a>(
        &self,
        requesting_url: &'a CefStringUtf16,
        top_level_url: &'a CefStringUtf16,
        content_type: ContentSettingTypes,
        value: ContentSettingValues,
    ) {
        unsafe {
            self.0
                .set_content_setting
                .map(|f| {
                    let (arg_requesting_url, arg_top_level_url, arg_content_type, arg_value) =
                        (requesting_url, top_level_url, content_type, value);
                    let arg_self_ = self.as_raw();
                    let arg_requesting_url = arg_requesting_url.as_raw();
                    let arg_top_level_url = arg_top_level_url.as_raw();
                    let arg_content_type = arg_content_type.as_raw();
                    let arg_value = arg_value.as_raw();
                    let result = f(
                        arg_self_,
                        arg_requesting_url,
                        arg_top_level_url,
                        arg_content_type,
                        arg_value,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_chrome_color_scheme<'a>(&self, variant: ColorVariant, user_color: u32) {
        unsafe {
            self.0
                .set_chrome_color_scheme
                .map(|f| {
                    let (arg_variant, arg_user_color) = (variant, user_color);
                    let arg_self_ = self.as_raw();
                    let arg_variant = arg_variant.as_raw();
                    let arg_user_color = arg_user_color;
                    let result = f(arg_self_, arg_variant, arg_user_color);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_chrome_color_scheme_mode<'a>(&self) -> ColorVariant {
        unsafe {
            self.0
                .get_chrome_color_scheme_mode
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_chrome_color_scheme_color<'a>(&self) -> cef_color_t {
        unsafe {
            self.0
                .get_chrome_color_scheme_color
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_chrome_color_scheme_variant<'a>(&self) -> ColorVariant {
        unsafe {
            self.0
                .get_chrome_color_scheme_variant
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_request_context_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for RequestContext {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_request_context_t> for &RequestContext {
    fn as_raw(self) -> *mut _cef_request_context_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_request_context_t> for &mut RequestContext {
    fn as_raw(self) -> *mut _cef_request_context_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<RequestContext> for *mut _cef_request_context_t {
    fn as_wrapper(self) -> RequestContext {
        RequestContext(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_request_context_t> for RequestContext {
    fn into(self) -> *mut _cef_request_context_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for RequestContext {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplBrowser: Sized {
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_host<'a>(&self) -> BrowserHost {
        unsafe { std::mem::zeroed() }
    }
    fn can_go_back<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn go_back<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn can_go_forward<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn go_forward<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn is_loading<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn reload<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn reload_ignore_cache<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn stop_load<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn get_identifier<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_same<'a>(&self, that: &'a mut Browser) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_popup<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn has_document<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_main_frame<'a>(&self) -> Frame {
        unsafe { std::mem::zeroed() }
    }
    fn get_focused_frame<'a>(&self) -> Frame {
        unsafe { std::mem::zeroed() }
    }
    fn get_frame_by_identifier<'a>(&self, identifier: &'a CefStringUtf16) -> Frame {
        unsafe { std::mem::zeroed() }
    }
    fn get_frame_by_name<'a>(&self, name: &'a CefStringUtf16) -> Frame {
        unsafe { std::mem::zeroed() }
    }
    fn get_frame_count<'a>(&self) -> usize {
        unsafe { std::mem::zeroed() }
    }
    fn get_frame_identifiers<'a>(&self, identifiers: &'a mut CefStringList) {
        unsafe { std::mem::zeroed() }
    }
    fn get_frame_names<'a>(&self, names: &'a mut CefStringList) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_browser_t {
        let mut object: _cef_browser_t = unsafe { std::mem::zeroed() };
        impl_cef_browser_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_browser_t {
    use super::*;
    pub fn init_methods<I: ImplBrowser>(object: &mut _cef_browser_t) {
        object.is_valid = Some(is_valid::<I>);
        object.get_host = Some(get_host::<I>);
        object.can_go_back = Some(can_go_back::<I>);
        object.go_back = Some(go_back::<I>);
        object.can_go_forward = Some(can_go_forward::<I>);
        object.go_forward = Some(go_forward::<I>);
        object.is_loading = Some(is_loading::<I>);
        object.reload = Some(reload::<I>);
        object.reload_ignore_cache = Some(reload_ignore_cache::<I>);
        object.stop_load = Some(stop_load::<I>);
        object.get_identifier = Some(get_identifier::<I>);
        object.is_same = Some(is_same::<I>);
        object.is_popup = Some(is_popup::<I>);
        object.has_document = Some(has_document::<I>);
        object.get_main_frame = Some(get_main_frame::<I>);
        object.get_focused_frame = Some(get_focused_frame::<I>);
        object.get_frame_by_identifier = Some(get_frame_by_identifier::<I>);
        object.get_frame_by_name = Some(get_frame_by_name::<I>);
        object.get_frame_count = Some(get_frame_count::<I>);
        object.get_frame_identifiers = Some(get_frame_identifiers::<I>);
        object.get_frame_names = Some(get_frame_names::<I>);
    }
    extern "C" fn is_valid<I: ImplBrowser>(self_: *mut _cef_browser_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_valid().into()
    }
    extern "C" fn get_host<I: ImplBrowser>(self_: *mut _cef_browser_t) -> *mut _cef_browser_host_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_host().into()
    }
    extern "C" fn can_go_back<I: ImplBrowser>(self_: *mut _cef_browser_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.can_go_back().into()
    }
    extern "C" fn go_back<I: ImplBrowser>(self_: *mut _cef_browser_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.go_back()
    }
    extern "C" fn can_go_forward<I: ImplBrowser>(
        self_: *mut _cef_browser_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.can_go_forward().into()
    }
    extern "C" fn go_forward<I: ImplBrowser>(self_: *mut _cef_browser_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.go_forward()
    }
    extern "C" fn is_loading<I: ImplBrowser>(self_: *mut _cef_browser_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_loading().into()
    }
    extern "C" fn reload<I: ImplBrowser>(self_: *mut _cef_browser_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.reload()
    }
    extern "C" fn reload_ignore_cache<I: ImplBrowser>(self_: *mut _cef_browser_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.reload_ignore_cache()
    }
    extern "C" fn stop_load<I: ImplBrowser>(self_: *mut _cef_browser_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.stop_load()
    }
    extern "C" fn get_identifier<I: ImplBrowser>(
        self_: *mut _cef_browser_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_identifier().into()
    }
    extern "C" fn is_same<I: ImplBrowser>(
        self_: *mut _cef_browser_t,
        that: *mut _cef_browser_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_that) = (self_, that);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_that = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_that) });
        arg_self_.interface.is_same(arg_that).into()
    }
    extern "C" fn is_popup<I: ImplBrowser>(self_: *mut _cef_browser_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_popup().into()
    }
    extern "C" fn has_document<I: ImplBrowser>(
        self_: *mut _cef_browser_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.has_document().into()
    }
    extern "C" fn get_main_frame<I: ImplBrowser>(self_: *mut _cef_browser_t) -> *mut _cef_frame_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_main_frame().into()
    }
    extern "C" fn get_focused_frame<I: ImplBrowser>(
        self_: *mut _cef_browser_t,
    ) -> *mut _cef_frame_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_focused_frame().into()
    }
    extern "C" fn get_frame_by_identifier<I: ImplBrowser>(
        self_: *mut _cef_browser_t,
        identifier: *const _cef_string_utf16_t,
    ) -> *mut _cef_frame_t {
        let (arg_self_, arg_identifier) = (self_, identifier);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_identifier = WrapParamRef::<CefStringUtf16>::from(arg_identifier);
        let arg_identifier = arg_identifier.as_ref();
        arg_self_
            .interface
            .get_frame_by_identifier(arg_identifier)
            .into()
    }
    extern "C" fn get_frame_by_name<I: ImplBrowser>(
        self_: *mut _cef_browser_t,
        name: *const _cef_string_utf16_t,
    ) -> *mut _cef_frame_t {
        let (arg_self_, arg_name) = (self_, name);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = WrapParamRef::<CefStringUtf16>::from(arg_name);
        let arg_name = arg_name.as_ref();
        arg_self_.interface.get_frame_by_name(arg_name).into()
    }
    extern "C" fn get_frame_count<I: ImplBrowser>(self_: *mut _cef_browser_t) -> usize {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_frame_count().into()
    }
    extern "C" fn get_frame_identifiers<I: ImplBrowser>(
        self_: *mut _cef_browser_t,
        identifiers: *mut _cef_string_list_t,
    ) {
        let (arg_self_, arg_identifiers) = (self_, identifiers);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_identifiers = WrapParamRef::<CefStringList>::from(arg_identifiers);
        let arg_identifiers = arg_identifiers.as_mut();
        arg_self_.interface.get_frame_identifiers(arg_identifiers)
    }
    extern "C" fn get_frame_names<I: ImplBrowser>(
        self_: *mut _cef_browser_t,
        names: *mut _cef_string_list_t,
    ) {
        let (arg_self_, arg_names) = (self_, names);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_names = WrapParamRef::<CefStringList>::from(arg_names);
        let arg_names = arg_names.as_mut();
        arg_self_.interface.get_frame_names(arg_names)
    }
}
#[doc = "See [_cef_browser_t] for more documentation."]
#[derive(Clone)]
pub struct Browser(RefGuard<_cef_browser_t>);
impl ImplBrowser for Browser {
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_host<'a>(&self) -> BrowserHost {
        unsafe {
            self.0
                .get_host
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn can_go_back<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .can_go_back
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn go_back<'a>(&self) {
        unsafe {
            self.0
                .go_back
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn can_go_forward<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .can_go_forward
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn go_forward<'a>(&self) {
        unsafe {
            self.0
                .go_forward
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_loading<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_loading
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn reload<'a>(&self) {
        unsafe {
            self.0
                .reload
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn reload_ignore_cache<'a>(&self) {
        unsafe {
            self.0
                .reload_ignore_cache
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn stop_load<'a>(&self) {
        unsafe {
            self.0
                .stop_load
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_identifier<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_identifier
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_same<'a>(&self, that: &'a mut Browser) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_same
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.as_raw();
                    let arg_that = arg_that.as_raw();
                    let result = f(arg_self_, arg_that);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_popup<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_popup
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn has_document<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_document
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_main_frame<'a>(&self) -> Frame {
        unsafe {
            self.0
                .get_main_frame
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_focused_frame<'a>(&self) -> Frame {
        unsafe {
            self.0
                .get_focused_frame
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_frame_by_identifier<'a>(&self, identifier: &'a CefStringUtf16) -> Frame {
        unsafe {
            self.0
                .get_frame_by_identifier
                .map(|f| {
                    let arg_identifier = identifier;
                    let arg_self_ = self.as_raw();
                    let arg_identifier = arg_identifier.as_raw();
                    let result = f(arg_self_, arg_identifier);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_frame_by_name<'a>(&self, name: &'a CefStringUtf16) -> Frame {
        unsafe {
            self.0
                .get_frame_by_name
                .map(|f| {
                    let arg_name = name;
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.as_raw();
                    let result = f(arg_self_, arg_name);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_frame_count<'a>(&self) -> usize {
        unsafe {
            self.0
                .get_frame_count
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_frame_identifiers<'a>(&self, identifiers: &'a mut CefStringList) {
        unsafe {
            self.0
                .get_frame_identifiers
                .map(|f| {
                    let arg_identifiers = identifiers;
                    let arg_self_ = self.as_raw();
                    let arg_identifiers = arg_identifiers.as_raw();
                    let result = f(arg_self_, arg_identifiers);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_frame_names<'a>(&self, names: &'a mut CefStringList) {
        unsafe {
            self.0
                .get_frame_names
                .map(|f| {
                    let arg_names = names;
                    let arg_self_ = self.as_raw();
                    let arg_names = arg_names.as_raw();
                    let result = f(arg_self_, arg_names);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_browser_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Browser {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_browser_t> for &Browser {
    fn as_raw(self) -> *mut _cef_browser_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_browser_t> for &mut Browser {
    fn as_raw(self) -> *mut _cef_browser_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<Browser> for *mut _cef_browser_t {
    fn as_wrapper(self) -> Browser {
        Browser(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_browser_t> for Browser {
    fn into(self) -> *mut _cef_browser_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for Browser {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplRunFileDialogCallback: Sized {
    fn on_file_dialog_dismissed<'a>(&self, file_paths: &'a mut CefStringList) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_run_file_dialog_callback_t {
        let mut object: _cef_run_file_dialog_callback_t = unsafe { std::mem::zeroed() };
        impl_cef_run_file_dialog_callback_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_run_file_dialog_callback_t {
    use super::*;
    pub fn init_methods<I: ImplRunFileDialogCallback>(
        object: &mut _cef_run_file_dialog_callback_t,
    ) {
        object.on_file_dialog_dismissed = Some(on_file_dialog_dismissed::<I>);
    }
    extern "C" fn on_file_dialog_dismissed<I: ImplRunFileDialogCallback>(
        self_: *mut _cef_run_file_dialog_callback_t,
        file_paths: *mut _cef_string_list_t,
    ) {
        let (arg_self_, arg_file_paths) = (self_, file_paths);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_file_paths = WrapParamRef::<CefStringList>::from(arg_file_paths);
        let arg_file_paths = arg_file_paths.as_mut();
        arg_self_.interface.on_file_dialog_dismissed(arg_file_paths)
    }
}
#[doc = "See [_cef_run_file_dialog_callback_t] for more documentation."]
#[derive(Clone)]
pub struct RunFileDialogCallback(RefGuard<_cef_run_file_dialog_callback_t>);
impl ImplRunFileDialogCallback for RunFileDialogCallback {
    fn on_file_dialog_dismissed<'a>(&self, file_paths: &'a mut CefStringList) {
        unsafe {
            self.0
                .on_file_dialog_dismissed
                .map(|f| {
                    let arg_file_paths = file_paths;
                    let arg_self_ = self.as_raw();
                    let arg_file_paths = arg_file_paths.as_raw();
                    let result = f(arg_self_, arg_file_paths);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_run_file_dialog_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for RunFileDialogCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_run_file_dialog_callback_t> for &RunFileDialogCallback {
    fn as_raw(self) -> *mut _cef_run_file_dialog_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_run_file_dialog_callback_t> for &mut RunFileDialogCallback {
    fn as_raw(self) -> *mut _cef_run_file_dialog_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<RunFileDialogCallback> for *mut _cef_run_file_dialog_callback_t {
    fn as_wrapper(self) -> RunFileDialogCallback {
        RunFileDialogCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_run_file_dialog_callback_t> for RunFileDialogCallback {
    fn into(self) -> *mut _cef_run_file_dialog_callback_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for RunFileDialogCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplNavigationEntryVisitor: Sized {
    fn visit<'a>(
        &self,
        entry: &'a mut NavigationEntry,
        current: ::std::os::raw::c_int,
        index: ::std::os::raw::c_int,
        total: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_navigation_entry_visitor_t {
        let mut object: _cef_navigation_entry_visitor_t = unsafe { std::mem::zeroed() };
        impl_cef_navigation_entry_visitor_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_navigation_entry_visitor_t {
    use super::*;
    pub fn init_methods<I: ImplNavigationEntryVisitor>(
        object: &mut _cef_navigation_entry_visitor_t,
    ) {
        object.visit = Some(visit::<I>);
    }
    extern "C" fn visit<I: ImplNavigationEntryVisitor>(
        self_: *mut _cef_navigation_entry_visitor_t,
        entry: *mut _cef_navigation_entry_t,
        current: ::std::os::raw::c_int,
        index: ::std::os::raw::c_int,
        total: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_entry, arg_current, arg_index, arg_total) =
            (self_, entry, current, index, total);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_entry = &mut NavigationEntry(unsafe { RefGuard::from_raw_add_ref(arg_entry) });
        let arg_current = arg_current.as_raw();
        let arg_index = arg_index.as_raw();
        let arg_total = arg_total.as_raw();
        arg_self_
            .interface
            .visit(arg_entry, arg_current, arg_index, arg_total)
            .into()
    }
}
#[doc = "See [_cef_navigation_entry_visitor_t] for more documentation."]
#[derive(Clone)]
pub struct NavigationEntryVisitor(RefGuard<_cef_navigation_entry_visitor_t>);
impl ImplNavigationEntryVisitor for NavigationEntryVisitor {
    fn visit<'a>(
        &self,
        entry: &'a mut NavigationEntry,
        current: ::std::os::raw::c_int,
        index: ::std::os::raw::c_int,
        total: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .visit
                .map(|f| {
                    let (arg_entry, arg_current, arg_index, arg_total) =
                        (entry, current, index, total);
                    let arg_self_ = self.as_raw();
                    let arg_entry = arg_entry.as_raw();
                    let arg_current = arg_current;
                    let arg_index = arg_index;
                    let arg_total = arg_total;
                    let result = f(arg_self_, arg_entry, arg_current, arg_index, arg_total);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_navigation_entry_visitor_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for NavigationEntryVisitor {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_navigation_entry_visitor_t> for &NavigationEntryVisitor {
    fn as_raw(self) -> *mut _cef_navigation_entry_visitor_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_navigation_entry_visitor_t> for &mut NavigationEntryVisitor {
    fn as_raw(self) -> *mut _cef_navigation_entry_visitor_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<NavigationEntryVisitor> for *mut _cef_navigation_entry_visitor_t {
    fn as_wrapper(self) -> NavigationEntryVisitor {
        NavigationEntryVisitor(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_navigation_entry_visitor_t> for NavigationEntryVisitor {
    fn into(self) -> *mut _cef_navigation_entry_visitor_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for NavigationEntryVisitor {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplPdfPrintCallback: Sized {
    fn on_pdf_print_finished<'a>(&self, path: &'a CefStringUtf16, ok: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_pdf_print_callback_t {
        let mut object: _cef_pdf_print_callback_t = unsafe { std::mem::zeroed() };
        impl_cef_pdf_print_callback_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_pdf_print_callback_t {
    use super::*;
    pub fn init_methods<I: ImplPdfPrintCallback>(object: &mut _cef_pdf_print_callback_t) {
        object.on_pdf_print_finished = Some(on_pdf_print_finished::<I>);
    }
    extern "C" fn on_pdf_print_finished<I: ImplPdfPrintCallback>(
        self_: *mut _cef_pdf_print_callback_t,
        path: *const _cef_string_utf16_t,
        ok: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_path, arg_ok) = (self_, path, ok);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_path = WrapParamRef::<CefStringUtf16>::from(arg_path);
        let arg_path = arg_path.as_ref();
        let arg_ok = arg_ok.as_raw();
        arg_self_.interface.on_pdf_print_finished(arg_path, arg_ok)
    }
}
#[doc = "See [_cef_pdf_print_callback_t] for more documentation."]
#[derive(Clone)]
pub struct PdfPrintCallback(RefGuard<_cef_pdf_print_callback_t>);
impl ImplPdfPrintCallback for PdfPrintCallback {
    fn on_pdf_print_finished<'a>(&self, path: &'a CefStringUtf16, ok: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .on_pdf_print_finished
                .map(|f| {
                    let (arg_path, arg_ok) = (path, ok);
                    let arg_self_ = self.as_raw();
                    let arg_path = arg_path.as_raw();
                    let arg_ok = arg_ok;
                    let result = f(arg_self_, arg_path, arg_ok);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_pdf_print_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for PdfPrintCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_pdf_print_callback_t> for &PdfPrintCallback {
    fn as_raw(self) -> *mut _cef_pdf_print_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_pdf_print_callback_t> for &mut PdfPrintCallback {
    fn as_raw(self) -> *mut _cef_pdf_print_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<PdfPrintCallback> for *mut _cef_pdf_print_callback_t {
    fn as_wrapper(self) -> PdfPrintCallback {
        PdfPrintCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_pdf_print_callback_t> for PdfPrintCallback {
    fn into(self) -> *mut _cef_pdf_print_callback_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for PdfPrintCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplDownloadImageCallback: Sized {
    fn on_download_image_finished<'a>(
        &self,
        image_url: &'a CefStringUtf16,
        http_status_code: ::std::os::raw::c_int,
        image: &'a mut Image,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_download_image_callback_t {
        let mut object: _cef_download_image_callback_t = unsafe { std::mem::zeroed() };
        impl_cef_download_image_callback_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_download_image_callback_t {
    use super::*;
    pub fn init_methods<I: ImplDownloadImageCallback>(object: &mut _cef_download_image_callback_t) {
        object.on_download_image_finished = Some(on_download_image_finished::<I>);
    }
    extern "C" fn on_download_image_finished<I: ImplDownloadImageCallback>(
        self_: *mut _cef_download_image_callback_t,
        image_url: *const _cef_string_utf16_t,
        http_status_code: ::std::os::raw::c_int,
        image: *mut _cef_image_t,
    ) {
        let (arg_self_, arg_image_url, arg_http_status_code, arg_image) =
            (self_, image_url, http_status_code, image);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_image_url = WrapParamRef::<CefStringUtf16>::from(arg_image_url);
        let arg_image_url = arg_image_url.as_ref();
        let arg_http_status_code = arg_http_status_code.as_raw();
        let arg_image = &mut Image(unsafe { RefGuard::from_raw_add_ref(arg_image) });
        arg_self_.interface.on_download_image_finished(
            arg_image_url,
            arg_http_status_code,
            arg_image,
        )
    }
}
#[doc = "See [_cef_download_image_callback_t] for more documentation."]
#[derive(Clone)]
pub struct DownloadImageCallback(RefGuard<_cef_download_image_callback_t>);
impl ImplDownloadImageCallback for DownloadImageCallback {
    fn on_download_image_finished<'a>(
        &self,
        image_url: &'a CefStringUtf16,
        http_status_code: ::std::os::raw::c_int,
        image: &'a mut Image,
    ) {
        unsafe {
            self.0
                .on_download_image_finished
                .map(|f| {
                    let (arg_image_url, arg_http_status_code, arg_image) =
                        (image_url, http_status_code, image);
                    let arg_self_ = self.as_raw();
                    let arg_image_url = arg_image_url.as_raw();
                    let arg_http_status_code = arg_http_status_code;
                    let arg_image = arg_image.as_raw();
                    let result = f(arg_self_, arg_image_url, arg_http_status_code, arg_image);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_download_image_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for DownloadImageCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_download_image_callback_t> for &DownloadImageCallback {
    fn as_raw(self) -> *mut _cef_download_image_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_download_image_callback_t> for &mut DownloadImageCallback {
    fn as_raw(self) -> *mut _cef_download_image_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<DownloadImageCallback> for *mut _cef_download_image_callback_t {
    fn as_wrapper(self) -> DownloadImageCallback {
        DownloadImageCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_download_image_callback_t> for DownloadImageCallback {
    fn into(self) -> *mut _cef_download_image_callback_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for DownloadImageCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplBrowserHost: Sized {
    fn get_browser<'a>(&self) -> Browser {
        unsafe { std::mem::zeroed() }
    }
    fn close_browser<'a>(&self, force_close: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn try_close_browser<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_ready_to_be_closed<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_focus<'a>(&self, focus: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn get_window_handle<'a>(&self) -> ::std::os::raw::c_ulong {
        unsafe { std::mem::zeroed() }
    }
    fn get_opener_window_handle<'a>(&self) -> ::std::os::raw::c_ulong {
        unsafe { std::mem::zeroed() }
    }
    fn get_opener_identifier<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn has_view<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_client<'a>(&self) -> Client {
        unsafe { std::mem::zeroed() }
    }
    fn get_request_context<'a>(&self) -> RequestContext {
        unsafe { std::mem::zeroed() }
    }
    fn can_zoom<'a>(&self, command: ZoomCommand) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn zoom<'a>(&self, command: ZoomCommand) {
        unsafe { std::mem::zeroed() }
    }
    fn get_default_zoom_level<'a>(&self) -> f64 {
        unsafe { std::mem::zeroed() }
    }
    fn get_zoom_level<'a>(&self) -> f64 {
        unsafe { std::mem::zeroed() }
    }
    fn set_zoom_level<'a>(&self, zoom_level: f64) {
        unsafe { std::mem::zeroed() }
    }
    fn run_file_dialog<'a>(
        &self,
        mode: FileDialogMode,
        title: &'a CefStringUtf16,
        default_file_path: &'a CefStringUtf16,
        accept_filters: &'a mut CefStringList,
        callback: &'a mut RunFileDialogCallback,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn start_download<'a>(&self, url: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn download_image<'a>(
        &self,
        image_url: &'a CefStringUtf16,
        is_favicon: ::std::os::raw::c_int,
        max_image_size: u32,
        bypass_cache: ::std::os::raw::c_int,
        callback: &'a mut DownloadImageCallback,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn print<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn print_to_pdf<'a>(
        &self,
        path: &'a CefStringUtf16,
        settings: &'a PdfPrintSettings,
        callback: &'a mut PdfPrintCallback,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn find<'a>(
        &self,
        search_text: &'a CefStringUtf16,
        forward: ::std::os::raw::c_int,
        match_case: ::std::os::raw::c_int,
        find_next: ::std::os::raw::c_int,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn stop_finding<'a>(&self, clear_selection: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn show_dev_tools<'a>(
        &self,
        window_info: &'a WindowInfo,
        client: &'a mut Client,
        settings: &'a BrowserSettings,
        inspect_element_at: &'a Point,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn close_dev_tools<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn has_dev_tools<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn send_dev_tools_message<'a>(&self, message: Option<&'a [u8]>) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn execute_dev_tools_method<'a>(
        &self,
        message_id: ::std::os::raw::c_int,
        method: &'a CefStringUtf16,
        params: &'a mut DictionaryValue,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn add_dev_tools_message_observer<'a>(
        &self,
        observer: &'a mut DevToolsMessageObserver,
    ) -> Registration {
        unsafe { std::mem::zeroed() }
    }
    fn get_navigation_entries<'a>(
        &self,
        visitor: &'a mut NavigationEntryVisitor,
        current_only: ::std::os::raw::c_int,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn replace_misspelling<'a>(&self, word: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn add_word_to_dictionary<'a>(&self, word: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn is_window_rendering_disabled<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn was_resized<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn was_hidden<'a>(&self, hidden: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn notify_screen_info_changed<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn invalidate<'a>(&self, type_: PaintElementType) {
        unsafe { std::mem::zeroed() }
    }
    fn send_external_begin_frame<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn send_key_event<'a>(&self, event: &'a KeyEvent) {
        unsafe { std::mem::zeroed() }
    }
    fn send_mouse_click_event<'a>(
        &self,
        event: &'a MouseEvent,
        type_: MouseButtonType,
        mouse_up: ::std::os::raw::c_int,
        click_count: ::std::os::raw::c_int,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn send_mouse_move_event<'a>(&self, event: &'a MouseEvent, mouse_leave: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn send_mouse_wheel_event<'a>(
        &self,
        event: &'a MouseEvent,
        delta_x: ::std::os::raw::c_int,
        delta_y: ::std::os::raw::c_int,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn send_touch_event<'a>(&self, event: &'a TouchEvent) {
        unsafe { std::mem::zeroed() }
    }
    fn send_capture_lost_event<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn notify_move_or_resize_started<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn get_windowless_frame_rate<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_windowless_frame_rate<'a>(&self, frame_rate: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn ime_set_composition<'a>(
        &self,
        text: &'a CefStringUtf16,
        underlines_count: usize,
        underlines: &'a CompositionUnderline,
        replacement_range: &'a Range,
        selection_range: &'a Range,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn ime_commit_text<'a>(
        &self,
        text: &'a CefStringUtf16,
        replacement_range: &'a Range,
        relative_cursor_pos: ::std::os::raw::c_int,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn ime_finish_composing_text<'a>(&self, keep_selection: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn ime_cancel_composition<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn drag_target_drag_enter<'a>(
        &self,
        drag_data: &'a mut DragData,
        event: &'a MouseEvent,
        allowed_ops: DragOperationsMask,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn drag_target_drag_over<'a>(&self, event: &'a MouseEvent, allowed_ops: DragOperationsMask) {
        unsafe { std::mem::zeroed() }
    }
    fn drag_target_drag_leave<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn drag_target_drop<'a>(&self, event: &'a MouseEvent) {
        unsafe { std::mem::zeroed() }
    }
    fn drag_source_ended_at<'a>(
        &self,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        op: DragOperationsMask,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn drag_source_system_drag_ended<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn get_visible_navigation_entry<'a>(&self) -> NavigationEntry {
        unsafe { std::mem::zeroed() }
    }
    fn set_accessibility_state<'a>(&self, accessibility_state: State) {
        unsafe { std::mem::zeroed() }
    }
    fn set_auto_resize_enabled<'a>(
        &self,
        enabled: ::std::os::raw::c_int,
        min_size: &'a Size,
        max_size: &'a Size,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn set_audio_muted<'a>(&self, mute: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn is_audio_muted<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_fullscreen<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn exit_fullscreen<'a>(&self, will_cause_resize: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn can_execute_chrome_command<'a>(
        &self,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn execute_chrome_command<'a>(
        &self,
        command_id: ::std::os::raw::c_int,
        disposition: WindowOpenDisposition,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn is_render_process_unresponsive<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_runtime_style<'a>(&self) -> RuntimeStyle {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_browser_host_t {
        let mut object: _cef_browser_host_t = unsafe { std::mem::zeroed() };
        impl_cef_browser_host_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_browser_host_t {
    use super::*;
    pub fn init_methods<I: ImplBrowserHost>(object: &mut _cef_browser_host_t) {
        object.get_browser = Some(get_browser::<I>);
        object.close_browser = Some(close_browser::<I>);
        object.try_close_browser = Some(try_close_browser::<I>);
        object.is_ready_to_be_closed = Some(is_ready_to_be_closed::<I>);
        object.set_focus = Some(set_focus::<I>);
        object.get_window_handle = Some(get_window_handle::<I>);
        object.get_opener_window_handle = Some(get_opener_window_handle::<I>);
        object.get_opener_identifier = Some(get_opener_identifier::<I>);
        object.has_view = Some(has_view::<I>);
        object.get_client = Some(get_client::<I>);
        object.get_request_context = Some(get_request_context::<I>);
        object.can_zoom = Some(can_zoom::<I>);
        object.zoom = Some(zoom::<I>);
        object.get_default_zoom_level = Some(get_default_zoom_level::<I>);
        object.get_zoom_level = Some(get_zoom_level::<I>);
        object.set_zoom_level = Some(set_zoom_level::<I>);
        object.run_file_dialog = Some(run_file_dialog::<I>);
        object.start_download = Some(start_download::<I>);
        object.download_image = Some(download_image::<I>);
        object.print = Some(print::<I>);
        object.print_to_pdf = Some(print_to_pdf::<I>);
        object.find = Some(find::<I>);
        object.stop_finding = Some(stop_finding::<I>);
        object.show_dev_tools = Some(show_dev_tools::<I>);
        object.close_dev_tools = Some(close_dev_tools::<I>);
        object.has_dev_tools = Some(has_dev_tools::<I>);
        object.send_dev_tools_message = Some(send_dev_tools_message::<I>);
        object.execute_dev_tools_method = Some(execute_dev_tools_method::<I>);
        object.add_dev_tools_message_observer = Some(add_dev_tools_message_observer::<I>);
        object.get_navigation_entries = Some(get_navigation_entries::<I>);
        object.replace_misspelling = Some(replace_misspelling::<I>);
        object.add_word_to_dictionary = Some(add_word_to_dictionary::<I>);
        object.is_window_rendering_disabled = Some(is_window_rendering_disabled::<I>);
        object.was_resized = Some(was_resized::<I>);
        object.was_hidden = Some(was_hidden::<I>);
        object.notify_screen_info_changed = Some(notify_screen_info_changed::<I>);
        object.invalidate = Some(invalidate::<I>);
        object.send_external_begin_frame = Some(send_external_begin_frame::<I>);
        object.send_key_event = Some(send_key_event::<I>);
        object.send_mouse_click_event = Some(send_mouse_click_event::<I>);
        object.send_mouse_move_event = Some(send_mouse_move_event::<I>);
        object.send_mouse_wheel_event = Some(send_mouse_wheel_event::<I>);
        object.send_touch_event = Some(send_touch_event::<I>);
        object.send_capture_lost_event = Some(send_capture_lost_event::<I>);
        object.notify_move_or_resize_started = Some(notify_move_or_resize_started::<I>);
        object.get_windowless_frame_rate = Some(get_windowless_frame_rate::<I>);
        object.set_windowless_frame_rate = Some(set_windowless_frame_rate::<I>);
        object.ime_set_composition = Some(ime_set_composition::<I>);
        object.ime_commit_text = Some(ime_commit_text::<I>);
        object.ime_finish_composing_text = Some(ime_finish_composing_text::<I>);
        object.ime_cancel_composition = Some(ime_cancel_composition::<I>);
        object.drag_target_drag_enter = Some(drag_target_drag_enter::<I>);
        object.drag_target_drag_over = Some(drag_target_drag_over::<I>);
        object.drag_target_drag_leave = Some(drag_target_drag_leave::<I>);
        object.drag_target_drop = Some(drag_target_drop::<I>);
        object.drag_source_ended_at = Some(drag_source_ended_at::<I>);
        object.drag_source_system_drag_ended = Some(drag_source_system_drag_ended::<I>);
        object.get_visible_navigation_entry = Some(get_visible_navigation_entry::<I>);
        object.set_accessibility_state = Some(set_accessibility_state::<I>);
        object.set_auto_resize_enabled = Some(set_auto_resize_enabled::<I>);
        object.set_audio_muted = Some(set_audio_muted::<I>);
        object.is_audio_muted = Some(is_audio_muted::<I>);
        object.is_fullscreen = Some(is_fullscreen::<I>);
        object.exit_fullscreen = Some(exit_fullscreen::<I>);
        object.can_execute_chrome_command = Some(can_execute_chrome_command::<I>);
        object.execute_chrome_command = Some(execute_chrome_command::<I>);
        object.is_render_process_unresponsive = Some(is_render_process_unresponsive::<I>);
        object.get_runtime_style = Some(get_runtime_style::<I>);
    }
    extern "C" fn get_browser<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
    ) -> *mut _cef_browser_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_browser().into()
    }
    extern "C" fn close_browser<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        force_close: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_force_close) = (self_, force_close);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_force_close = arg_force_close.as_raw();
        arg_self_.interface.close_browser(arg_force_close)
    }
    extern "C" fn try_close_browser<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.try_close_browser().into()
    }
    extern "C" fn is_ready_to_be_closed<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_ready_to_be_closed().into()
    }
    extern "C" fn set_focus<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        focus: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_focus) = (self_, focus);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_focus = arg_focus.as_raw();
        arg_self_.interface.set_focus(arg_focus)
    }
    extern "C" fn get_window_handle<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
    ) -> ::std::os::raw::c_ulong {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_window_handle().into()
    }
    extern "C" fn get_opener_window_handle<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
    ) -> ::std::os::raw::c_ulong {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_opener_window_handle().into()
    }
    extern "C" fn get_opener_identifier<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_opener_identifier().into()
    }
    extern "C" fn has_view<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.has_view().into()
    }
    extern "C" fn get_client<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
    ) -> *mut _cef_client_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_client().into()
    }
    extern "C" fn get_request_context<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
    ) -> *mut _cef_request_context_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_request_context().into()
    }
    extern "C" fn can_zoom<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        command: cef_zoom_command_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command) = (self_, command);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command = arg_command.as_raw();
        arg_self_.interface.can_zoom(arg_command).into()
    }
    extern "C" fn zoom<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        command: cef_zoom_command_t,
    ) {
        let (arg_self_, arg_command) = (self_, command);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command = arg_command.as_raw();
        arg_self_.interface.zoom(arg_command)
    }
    extern "C" fn get_default_zoom_level<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
    ) -> f64 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_default_zoom_level().into()
    }
    extern "C" fn get_zoom_level<I: ImplBrowserHost>(self_: *mut _cef_browser_host_t) -> f64 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_zoom_level().into()
    }
    extern "C" fn set_zoom_level<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        zoom_level: f64,
    ) {
        let (arg_self_, arg_zoom_level) = (self_, zoom_level);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_zoom_level = arg_zoom_level.as_raw();
        arg_self_.interface.set_zoom_level(arg_zoom_level)
    }
    extern "C" fn run_file_dialog<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        mode: cef_file_dialog_mode_t,
        title: *const _cef_string_utf16_t,
        default_file_path: *const _cef_string_utf16_t,
        accept_filters: *mut _cef_string_list_t,
        callback: *mut _cef_run_file_dialog_callback_t,
    ) {
        let (
            arg_self_,
            arg_mode,
            arg_title,
            arg_default_file_path,
            arg_accept_filters,
            arg_callback,
        ) = (
            self_,
            mode,
            title,
            default_file_path,
            accept_filters,
            callback,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_mode = arg_mode.as_raw();
        let arg_title = WrapParamRef::<CefStringUtf16>::from(arg_title);
        let arg_title = arg_title.as_ref();
        let arg_default_file_path = WrapParamRef::<CefStringUtf16>::from(arg_default_file_path);
        let arg_default_file_path = arg_default_file_path.as_ref();
        let mut arg_accept_filters = WrapParamRef::<CefStringList>::from(arg_accept_filters);
        let arg_accept_filters = arg_accept_filters.as_mut();
        let arg_callback =
            &mut RunFileDialogCallback(unsafe { RefGuard::from_raw_add_ref(arg_callback) });
        arg_self_.interface.run_file_dialog(
            arg_mode,
            arg_title,
            arg_default_file_path,
            arg_accept_filters,
            arg_callback,
        )
    }
    extern "C" fn start_download<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        url: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_url) = (self_, url);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_url = WrapParamRef::<CefStringUtf16>::from(arg_url);
        let arg_url = arg_url.as_ref();
        arg_self_.interface.start_download(arg_url)
    }
    extern "C" fn download_image<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        image_url: *const _cef_string_utf16_t,
        is_favicon: ::std::os::raw::c_int,
        max_image_size: u32,
        bypass_cache: ::std::os::raw::c_int,
        callback: *mut _cef_download_image_callback_t,
    ) {
        let (
            arg_self_,
            arg_image_url,
            arg_is_favicon,
            arg_max_image_size,
            arg_bypass_cache,
            arg_callback,
        ) = (
            self_,
            image_url,
            is_favicon,
            max_image_size,
            bypass_cache,
            callback,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_image_url = WrapParamRef::<CefStringUtf16>::from(arg_image_url);
        let arg_image_url = arg_image_url.as_ref();
        let arg_is_favicon = arg_is_favicon.as_raw();
        let arg_max_image_size = arg_max_image_size.as_raw();
        let arg_bypass_cache = arg_bypass_cache.as_raw();
        let arg_callback =
            &mut DownloadImageCallback(unsafe { RefGuard::from_raw_add_ref(arg_callback) });
        arg_self_.interface.download_image(
            arg_image_url,
            arg_is_favicon,
            arg_max_image_size,
            arg_bypass_cache,
            arg_callback,
        )
    }
    extern "C" fn print<I: ImplBrowserHost>(self_: *mut _cef_browser_host_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.print()
    }
    extern "C" fn print_to_pdf<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        path: *const _cef_string_utf16_t,
        settings: *const _cef_pdf_print_settings_t,
        callback: *mut _cef_pdf_print_callback_t,
    ) {
        let (arg_self_, arg_path, arg_settings, arg_callback) = (self_, path, settings, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_path = WrapParamRef::<CefStringUtf16>::from(arg_path);
        let arg_path = arg_path.as_ref();
        let arg_settings = WrapParamRef::<PdfPrintSettings>::from(arg_settings);
        let arg_settings = arg_settings.as_ref();
        let arg_callback =
            &mut PdfPrintCallback(unsafe { RefGuard::from_raw_add_ref(arg_callback) });
        arg_self_
            .interface
            .print_to_pdf(arg_path, arg_settings, arg_callback)
    }
    extern "C" fn find<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        search_text: *const _cef_string_utf16_t,
        forward: ::std::os::raw::c_int,
        match_case: ::std::os::raw::c_int,
        find_next: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_search_text, arg_forward, arg_match_case, arg_find_next) =
            (self_, search_text, forward, match_case, find_next);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_search_text = WrapParamRef::<CefStringUtf16>::from(arg_search_text);
        let arg_search_text = arg_search_text.as_ref();
        let arg_forward = arg_forward.as_raw();
        let arg_match_case = arg_match_case.as_raw();
        let arg_find_next = arg_find_next.as_raw();
        arg_self_
            .interface
            .find(arg_search_text, arg_forward, arg_match_case, arg_find_next)
    }
    extern "C" fn stop_finding<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        clear_selection: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_clear_selection) = (self_, clear_selection);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_clear_selection = arg_clear_selection.as_raw();
        arg_self_.interface.stop_finding(arg_clear_selection)
    }
    extern "C" fn show_dev_tools<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        window_info: *const _cef_window_info_t,
        client: *mut _cef_client_t,
        settings: *const _cef_browser_settings_t,
        inspect_element_at: *const _cef_point_t,
    ) {
        let (arg_self_, arg_window_info, arg_client, arg_settings, arg_inspect_element_at) =
            (self_, window_info, client, settings, inspect_element_at);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_window_info = WrapParamRef::<WindowInfo>::from(arg_window_info);
        let arg_window_info = arg_window_info.as_ref();
        let arg_client = &mut Client(unsafe { RefGuard::from_raw_add_ref(arg_client) });
        let arg_settings = WrapParamRef::<BrowserSettings>::from(arg_settings);
        let arg_settings = arg_settings.as_ref();
        let arg_inspect_element_at = WrapParamRef::<Point>::from(arg_inspect_element_at);
        let arg_inspect_element_at = arg_inspect_element_at.as_ref();
        arg_self_.interface.show_dev_tools(
            arg_window_info,
            arg_client,
            arg_settings,
            arg_inspect_element_at,
        )
    }
    extern "C" fn close_dev_tools<I: ImplBrowserHost>(self_: *mut _cef_browser_host_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.close_dev_tools()
    }
    extern "C" fn has_dev_tools<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.has_dev_tools().into()
    }
    extern "C" fn send_dev_tools_message<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        message: *const ::std::os::raw::c_void,
        message_size: usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_message, arg_message_size) = (self_, message, message_size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_message = (!arg_message.is_null() && arg_message_size > 0).then(|| unsafe {
            std::slice::from_raw_parts(arg_message as *const _, arg_message_size)
        });
        arg_self_
            .interface
            .send_dev_tools_message(arg_message)
            .into()
    }
    extern "C" fn execute_dev_tools_method<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        message_id: ::std::os::raw::c_int,
        method: *const _cef_string_utf16_t,
        params: *mut _cef_dictionary_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_message_id, arg_method, arg_params) =
            (self_, message_id, method, params);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_message_id = arg_message_id.as_raw();
        let arg_method = WrapParamRef::<CefStringUtf16>::from(arg_method);
        let arg_method = arg_method.as_ref();
        let arg_params = &mut DictionaryValue(unsafe { RefGuard::from_raw_add_ref(arg_params) });
        arg_self_
            .interface
            .execute_dev_tools_method(arg_message_id, arg_method, arg_params)
            .into()
    }
    extern "C" fn add_dev_tools_message_observer<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        observer: *mut _cef_dev_tools_message_observer_t,
    ) -> *mut _cef_registration_t {
        let (arg_self_, arg_observer) = (self_, observer);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_observer =
            &mut DevToolsMessageObserver(unsafe { RefGuard::from_raw_add_ref(arg_observer) });
        arg_self_
            .interface
            .add_dev_tools_message_observer(arg_observer)
            .into()
    }
    extern "C" fn get_navigation_entries<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        visitor: *mut _cef_navigation_entry_visitor_t,
        current_only: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_visitor, arg_current_only) = (self_, visitor, current_only);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_visitor =
            &mut NavigationEntryVisitor(unsafe { RefGuard::from_raw_add_ref(arg_visitor) });
        let arg_current_only = arg_current_only.as_raw();
        arg_self_
            .interface
            .get_navigation_entries(arg_visitor, arg_current_only)
    }
    extern "C" fn replace_misspelling<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        word: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_word) = (self_, word);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_word = WrapParamRef::<CefStringUtf16>::from(arg_word);
        let arg_word = arg_word.as_ref();
        arg_self_.interface.replace_misspelling(arg_word)
    }
    extern "C" fn add_word_to_dictionary<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        word: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_word) = (self_, word);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_word = WrapParamRef::<CefStringUtf16>::from(arg_word);
        let arg_word = arg_word.as_ref();
        arg_self_.interface.add_word_to_dictionary(arg_word)
    }
    extern "C" fn is_window_rendering_disabled<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_window_rendering_disabled().into()
    }
    extern "C" fn was_resized<I: ImplBrowserHost>(self_: *mut _cef_browser_host_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.was_resized()
    }
    extern "C" fn was_hidden<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        hidden: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_hidden) = (self_, hidden);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_hidden = arg_hidden.as_raw();
        arg_self_.interface.was_hidden(arg_hidden)
    }
    extern "C" fn notify_screen_info_changed<I: ImplBrowserHost>(self_: *mut _cef_browser_host_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.notify_screen_info_changed()
    }
    extern "C" fn invalidate<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        type_: cef_paint_element_type_t,
    ) {
        let (arg_self_, arg_type_) = (self_, type_);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_type_ = arg_type_.as_raw();
        arg_self_.interface.invalidate(arg_type_)
    }
    extern "C" fn send_external_begin_frame<I: ImplBrowserHost>(self_: *mut _cef_browser_host_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.send_external_begin_frame()
    }
    extern "C" fn send_key_event<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        event: *const _cef_key_event_t,
    ) {
        let (arg_self_, arg_event) = (self_, event);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_event = WrapParamRef::<KeyEvent>::from(arg_event);
        let arg_event = arg_event.as_ref();
        arg_self_.interface.send_key_event(arg_event)
    }
    extern "C" fn send_mouse_click_event<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        event: *const _cef_mouse_event_t,
        type_: cef_mouse_button_type_t,
        mouse_up: ::std::os::raw::c_int,
        click_count: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_event, arg_type_, arg_mouse_up, arg_click_count) =
            (self_, event, type_, mouse_up, click_count);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_event = WrapParamRef::<MouseEvent>::from(arg_event);
        let arg_event = arg_event.as_ref();
        let arg_type_ = arg_type_.as_raw();
        let arg_mouse_up = arg_mouse_up.as_raw();
        let arg_click_count = arg_click_count.as_raw();
        arg_self_.interface.send_mouse_click_event(
            arg_event,
            arg_type_,
            arg_mouse_up,
            arg_click_count,
        )
    }
    extern "C" fn send_mouse_move_event<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        event: *const _cef_mouse_event_t,
        mouse_leave: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_event, arg_mouse_leave) = (self_, event, mouse_leave);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_event = WrapParamRef::<MouseEvent>::from(arg_event);
        let arg_event = arg_event.as_ref();
        let arg_mouse_leave = arg_mouse_leave.as_raw();
        arg_self_
            .interface
            .send_mouse_move_event(arg_event, arg_mouse_leave)
    }
    extern "C" fn send_mouse_wheel_event<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        event: *const _cef_mouse_event_t,
        delta_x: ::std::os::raw::c_int,
        delta_y: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_event, arg_delta_x, arg_delta_y) = (self_, event, delta_x, delta_y);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_event = WrapParamRef::<MouseEvent>::from(arg_event);
        let arg_event = arg_event.as_ref();
        let arg_delta_x = arg_delta_x.as_raw();
        let arg_delta_y = arg_delta_y.as_raw();
        arg_self_
            .interface
            .send_mouse_wheel_event(arg_event, arg_delta_x, arg_delta_y)
    }
    extern "C" fn send_touch_event<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        event: *const _cef_touch_event_t,
    ) {
        let (arg_self_, arg_event) = (self_, event);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_event = WrapParamRef::<TouchEvent>::from(arg_event);
        let arg_event = arg_event.as_ref();
        arg_self_.interface.send_touch_event(arg_event)
    }
    extern "C" fn send_capture_lost_event<I: ImplBrowserHost>(self_: *mut _cef_browser_host_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.send_capture_lost_event()
    }
    extern "C" fn notify_move_or_resize_started<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
    ) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.notify_move_or_resize_started()
    }
    extern "C" fn get_windowless_frame_rate<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_windowless_frame_rate().into()
    }
    extern "C" fn set_windowless_frame_rate<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        frame_rate: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_frame_rate) = (self_, frame_rate);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_frame_rate = arg_frame_rate.as_raw();
        arg_self_
            .interface
            .set_windowless_frame_rate(arg_frame_rate)
    }
    extern "C" fn ime_set_composition<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        text: *const _cef_string_utf16_t,
        underlines_count: usize,
        underlines: *const _cef_composition_underline_t,
        replacement_range: *const _cef_range_t,
        selection_range: *const _cef_range_t,
    ) {
        let (
            arg_self_,
            arg_text,
            arg_underlines_count,
            arg_underlines,
            arg_replacement_range,
            arg_selection_range,
        ) = (
            self_,
            text,
            underlines_count,
            underlines,
            replacement_range,
            selection_range,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_text = WrapParamRef::<CefStringUtf16>::from(arg_text);
        let arg_text = arg_text.as_ref();
        let arg_underlines_count = arg_underlines_count.as_raw();
        let arg_underlines = WrapParamRef::<CompositionUnderline>::from(arg_underlines);
        let arg_underlines = arg_underlines.as_ref();
        let arg_replacement_range = WrapParamRef::<Range>::from(arg_replacement_range);
        let arg_replacement_range = arg_replacement_range.as_ref();
        let arg_selection_range = WrapParamRef::<Range>::from(arg_selection_range);
        let arg_selection_range = arg_selection_range.as_ref();
        arg_self_.interface.ime_set_composition(
            arg_text,
            arg_underlines_count,
            arg_underlines,
            arg_replacement_range,
            arg_selection_range,
        )
    }
    extern "C" fn ime_commit_text<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        text: *const _cef_string_utf16_t,
        replacement_range: *const _cef_range_t,
        relative_cursor_pos: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_text, arg_replacement_range, arg_relative_cursor_pos) =
            (self_, text, replacement_range, relative_cursor_pos);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_text = WrapParamRef::<CefStringUtf16>::from(arg_text);
        let arg_text = arg_text.as_ref();
        let arg_replacement_range = WrapParamRef::<Range>::from(arg_replacement_range);
        let arg_replacement_range = arg_replacement_range.as_ref();
        let arg_relative_cursor_pos = arg_relative_cursor_pos.as_raw();
        arg_self_.interface.ime_commit_text(
            arg_text,
            arg_replacement_range,
            arg_relative_cursor_pos,
        )
    }
    extern "C" fn ime_finish_composing_text<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        keep_selection: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_keep_selection) = (self_, keep_selection);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_keep_selection = arg_keep_selection.as_raw();
        arg_self_
            .interface
            .ime_finish_composing_text(arg_keep_selection)
    }
    extern "C" fn ime_cancel_composition<I: ImplBrowserHost>(self_: *mut _cef_browser_host_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.ime_cancel_composition()
    }
    extern "C" fn drag_target_drag_enter<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        drag_data: *mut _cef_drag_data_t,
        event: *const _cef_mouse_event_t,
        allowed_ops: cef_drag_operations_mask_t,
    ) {
        let (arg_self_, arg_drag_data, arg_event, arg_allowed_ops) =
            (self_, drag_data, event, allowed_ops);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_drag_data = &mut DragData(unsafe { RefGuard::from_raw_add_ref(arg_drag_data) });
        let arg_event = WrapParamRef::<MouseEvent>::from(arg_event);
        let arg_event = arg_event.as_ref();
        let arg_allowed_ops = arg_allowed_ops.as_raw();
        arg_self_
            .interface
            .drag_target_drag_enter(arg_drag_data, arg_event, arg_allowed_ops)
    }
    extern "C" fn drag_target_drag_over<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        event: *const _cef_mouse_event_t,
        allowed_ops: cef_drag_operations_mask_t,
    ) {
        let (arg_self_, arg_event, arg_allowed_ops) = (self_, event, allowed_ops);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_event = WrapParamRef::<MouseEvent>::from(arg_event);
        let arg_event = arg_event.as_ref();
        let arg_allowed_ops = arg_allowed_ops.as_raw();
        arg_self_
            .interface
            .drag_target_drag_over(arg_event, arg_allowed_ops)
    }
    extern "C" fn drag_target_drag_leave<I: ImplBrowserHost>(self_: *mut _cef_browser_host_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.drag_target_drag_leave()
    }
    extern "C" fn drag_target_drop<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        event: *const _cef_mouse_event_t,
    ) {
        let (arg_self_, arg_event) = (self_, event);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_event = WrapParamRef::<MouseEvent>::from(arg_event);
        let arg_event = arg_event.as_ref();
        arg_self_.interface.drag_target_drop(arg_event)
    }
    extern "C" fn drag_source_ended_at<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        op: cef_drag_operations_mask_t,
    ) {
        let (arg_self_, arg_x, arg_y, arg_op) = (self_, x, y, op);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_x = arg_x.as_raw();
        let arg_y = arg_y.as_raw();
        let arg_op = arg_op.as_raw();
        arg_self_
            .interface
            .drag_source_ended_at(arg_x, arg_y, arg_op)
    }
    extern "C" fn drag_source_system_drag_ended<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
    ) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.drag_source_system_drag_ended()
    }
    extern "C" fn get_visible_navigation_entry<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
    ) -> *mut _cef_navigation_entry_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_visible_navigation_entry().into()
    }
    extern "C" fn set_accessibility_state<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        accessibility_state: cef_state_t,
    ) {
        let (arg_self_, arg_accessibility_state) = (self_, accessibility_state);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_accessibility_state = arg_accessibility_state.as_raw();
        arg_self_
            .interface
            .set_accessibility_state(arg_accessibility_state)
    }
    extern "C" fn set_auto_resize_enabled<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        enabled: ::std::os::raw::c_int,
        min_size: *const _cef_size_t,
        max_size: *const _cef_size_t,
    ) {
        let (arg_self_, arg_enabled, arg_min_size, arg_max_size) =
            (self_, enabled, min_size, max_size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_enabled = arg_enabled.as_raw();
        let arg_min_size = WrapParamRef::<Size>::from(arg_min_size);
        let arg_min_size = arg_min_size.as_ref();
        let arg_max_size = WrapParamRef::<Size>::from(arg_max_size);
        let arg_max_size = arg_max_size.as_ref();
        arg_self_
            .interface
            .set_auto_resize_enabled(arg_enabled, arg_min_size, arg_max_size)
    }
    extern "C" fn set_audio_muted<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        mute: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_mute) = (self_, mute);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_mute = arg_mute.as_raw();
        arg_self_.interface.set_audio_muted(arg_mute)
    }
    extern "C" fn is_audio_muted<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_audio_muted().into()
    }
    extern "C" fn is_fullscreen<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_fullscreen().into()
    }
    extern "C" fn exit_fullscreen<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        will_cause_resize: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_will_cause_resize) = (self_, will_cause_resize);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_will_cause_resize = arg_will_cause_resize.as_raw();
        arg_self_.interface.exit_fullscreen(arg_will_cause_resize)
    }
    extern "C" fn can_execute_chrome_command<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id) = (self_, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        arg_self_
            .interface
            .can_execute_chrome_command(arg_command_id)
            .into()
    }
    extern "C" fn execute_chrome_command<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
        command_id: ::std::os::raw::c_int,
        disposition: cef_window_open_disposition_t,
    ) {
        let (arg_self_, arg_command_id, arg_disposition) = (self_, command_id, disposition);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let arg_disposition = arg_disposition.as_raw();
        arg_self_
            .interface
            .execute_chrome_command(arg_command_id, arg_disposition)
    }
    extern "C" fn is_render_process_unresponsive<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_render_process_unresponsive().into()
    }
    extern "C" fn get_runtime_style<I: ImplBrowserHost>(
        self_: *mut _cef_browser_host_t,
    ) -> cef_runtime_style_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_runtime_style().into()
    }
}
#[doc = "See [_cef_browser_host_t] for more documentation."]
#[derive(Clone)]
pub struct BrowserHost(RefGuard<_cef_browser_host_t>);
impl ImplBrowserHost for BrowserHost {
    fn get_browser<'a>(&self) -> Browser {
        unsafe {
            self.0
                .get_browser
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn close_browser<'a>(&self, force_close: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .close_browser
                .map(|f| {
                    let arg_force_close = force_close;
                    let arg_self_ = self.as_raw();
                    let arg_force_close = arg_force_close;
                    let result = f(arg_self_, arg_force_close);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn try_close_browser<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .try_close_browser
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_ready_to_be_closed<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_ready_to_be_closed
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_focus<'a>(&self, focus: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_focus
                .map(|f| {
                    let arg_focus = focus;
                    let arg_self_ = self.as_raw();
                    let arg_focus = arg_focus;
                    let result = f(arg_self_, arg_focus);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_window_handle<'a>(&self) -> ::std::os::raw::c_ulong {
        unsafe {
            self.0
                .get_window_handle
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_opener_window_handle<'a>(&self) -> ::std::os::raw::c_ulong {
        unsafe {
            self.0
                .get_opener_window_handle
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_opener_identifier<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_opener_identifier
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn has_view<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_view
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_client<'a>(&self) -> Client {
        unsafe {
            self.0
                .get_client
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_request_context<'a>(&self) -> RequestContext {
        unsafe {
            self.0
                .get_request_context
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn can_zoom<'a>(&self, command: ZoomCommand) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .can_zoom
                .map(|f| {
                    let arg_command = command;
                    let arg_self_ = self.as_raw();
                    let arg_command = arg_command.as_raw();
                    let result = f(arg_self_, arg_command);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn zoom<'a>(&self, command: ZoomCommand) {
        unsafe {
            self.0
                .zoom
                .map(|f| {
                    let arg_command = command;
                    let arg_self_ = self.as_raw();
                    let arg_command = arg_command.as_raw();
                    let result = f(arg_self_, arg_command);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_default_zoom_level<'a>(&self) -> f64 {
        unsafe {
            self.0
                .get_default_zoom_level
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_zoom_level<'a>(&self) -> f64 {
        unsafe {
            self.0
                .get_zoom_level
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_zoom_level<'a>(&self, zoom_level: f64) {
        unsafe {
            self.0
                .set_zoom_level
                .map(|f| {
                    let arg_zoom_level = zoom_level;
                    let arg_self_ = self.as_raw();
                    let arg_zoom_level = arg_zoom_level;
                    let result = f(arg_self_, arg_zoom_level);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn run_file_dialog<'a>(
        &self,
        mode: FileDialogMode,
        title: &'a CefStringUtf16,
        default_file_path: &'a CefStringUtf16,
        accept_filters: &'a mut CefStringList,
        callback: &'a mut RunFileDialogCallback,
    ) {
        unsafe {
            self.0
                .run_file_dialog
                .map(|f| {
                    let (
                        arg_mode,
                        arg_title,
                        arg_default_file_path,
                        arg_accept_filters,
                        arg_callback,
                    ) = (mode, title, default_file_path, accept_filters, callback);
                    let arg_self_ = self.as_raw();
                    let arg_mode = arg_mode.as_raw();
                    let arg_title = arg_title.as_raw();
                    let arg_default_file_path = arg_default_file_path.as_raw();
                    let arg_accept_filters = arg_accept_filters.as_raw();
                    let arg_callback = arg_callback.as_raw();
                    let result = f(
                        arg_self_,
                        arg_mode,
                        arg_title,
                        arg_default_file_path,
                        arg_accept_filters,
                        arg_callback,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn start_download<'a>(&self, url: &'a CefStringUtf16) {
        unsafe {
            self.0
                .start_download
                .map(|f| {
                    let arg_url = url;
                    let arg_self_ = self.as_raw();
                    let arg_url = arg_url.as_raw();
                    let result = f(arg_self_, arg_url);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn download_image<'a>(
        &self,
        image_url: &'a CefStringUtf16,
        is_favicon: ::std::os::raw::c_int,
        max_image_size: u32,
        bypass_cache: ::std::os::raw::c_int,
        callback: &'a mut DownloadImageCallback,
    ) {
        unsafe {
            self.0
                .download_image
                .map(|f| {
                    let (
                        arg_image_url,
                        arg_is_favicon,
                        arg_max_image_size,
                        arg_bypass_cache,
                        arg_callback,
                    ) = (
                        image_url,
                        is_favicon,
                        max_image_size,
                        bypass_cache,
                        callback,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_image_url = arg_image_url.as_raw();
                    let arg_is_favicon = arg_is_favicon;
                    let arg_max_image_size = arg_max_image_size;
                    let arg_bypass_cache = arg_bypass_cache;
                    let arg_callback = arg_callback.as_raw();
                    let result = f(
                        arg_self_,
                        arg_image_url,
                        arg_is_favicon,
                        arg_max_image_size,
                        arg_bypass_cache,
                        arg_callback,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn print<'a>(&self) {
        unsafe {
            self.0
                .print
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn print_to_pdf<'a>(
        &self,
        path: &'a CefStringUtf16,
        settings: &'a PdfPrintSettings,
        callback: &'a mut PdfPrintCallback,
    ) {
        unsafe {
            self.0
                .print_to_pdf
                .map(|f| {
                    let (arg_path, arg_settings, arg_callback) = (path, settings, callback);
                    let arg_self_ = self.as_raw();
                    let arg_path = arg_path.as_raw();
                    let mut arg_settings: _cef_pdf_print_settings_t = arg_settings.clone().into();
                    let arg_settings = &mut arg_settings;
                    let arg_callback = arg_callback.as_raw();
                    let result = f(arg_self_, arg_path, arg_settings, arg_callback);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn find<'a>(
        &self,
        search_text: &'a CefStringUtf16,
        forward: ::std::os::raw::c_int,
        match_case: ::std::os::raw::c_int,
        find_next: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .find
                .map(|f| {
                    let (arg_search_text, arg_forward, arg_match_case, arg_find_next) =
                        (search_text, forward, match_case, find_next);
                    let arg_self_ = self.as_raw();
                    let arg_search_text = arg_search_text.as_raw();
                    let arg_forward = arg_forward;
                    let arg_match_case = arg_match_case;
                    let arg_find_next = arg_find_next;
                    let result = f(
                        arg_self_,
                        arg_search_text,
                        arg_forward,
                        arg_match_case,
                        arg_find_next,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn stop_finding<'a>(&self, clear_selection: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .stop_finding
                .map(|f| {
                    let arg_clear_selection = clear_selection;
                    let arg_self_ = self.as_raw();
                    let arg_clear_selection = arg_clear_selection;
                    let result = f(arg_self_, arg_clear_selection);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn show_dev_tools<'a>(
        &self,
        window_info: &'a WindowInfo,
        client: &'a mut Client,
        settings: &'a BrowserSettings,
        inspect_element_at: &'a Point,
    ) {
        unsafe {
            self.0
                .show_dev_tools
                .map(|f| {
                    let (arg_window_info, arg_client, arg_settings, arg_inspect_element_at) =
                        (window_info, client, settings, inspect_element_at);
                    let arg_self_ = self.as_raw();
                    let mut arg_window_info: _cef_window_info_t = arg_window_info.clone().into();
                    let arg_window_info = &mut arg_window_info;
                    let arg_client = arg_client.as_raw();
                    let mut arg_settings: _cef_browser_settings_t = arg_settings.clone().into();
                    let arg_settings = &mut arg_settings;
                    let mut arg_inspect_element_at: _cef_point_t =
                        arg_inspect_element_at.clone().into();
                    let arg_inspect_element_at = &mut arg_inspect_element_at;
                    let result = f(
                        arg_self_,
                        arg_window_info,
                        arg_client,
                        arg_settings,
                        arg_inspect_element_at,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn close_dev_tools<'a>(&self) {
        unsafe {
            self.0
                .close_dev_tools
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn has_dev_tools<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_dev_tools
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn send_dev_tools_message<'a>(&self, message: Option<&'a [u8]>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .send_dev_tools_message
                .map(|f| {
                    let arg_message = message;
                    let arg_self_ = self.as_raw();
                    let arg_message_size = arg_message.map(|slice| slice.len()).unwrap_or_default();
                    let out_message = arg_message;
                    let arg_message = arg_message
                        .and_then(|slice| {
                            if slice.is_empty() {
                                None
                            } else {
                                Some(slice.as_ptr() as *const _)
                            }
                        })
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_message, arg_message_size);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn execute_dev_tools_method<'a>(
        &self,
        message_id: ::std::os::raw::c_int,
        method: &'a CefStringUtf16,
        params: &'a mut DictionaryValue,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .execute_dev_tools_method
                .map(|f| {
                    let (arg_message_id, arg_method, arg_params) = (message_id, method, params);
                    let arg_self_ = self.as_raw();
                    let arg_message_id = arg_message_id;
                    let arg_method = arg_method.as_raw();
                    let arg_params = arg_params.as_raw();
                    let result = f(arg_self_, arg_message_id, arg_method, arg_params);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn add_dev_tools_message_observer<'a>(
        &self,
        observer: &'a mut DevToolsMessageObserver,
    ) -> Registration {
        unsafe {
            self.0
                .add_dev_tools_message_observer
                .map(|f| {
                    let arg_observer = observer;
                    let arg_self_ = self.as_raw();
                    let arg_observer = arg_observer.as_raw();
                    let result = f(arg_self_, arg_observer);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_navigation_entries<'a>(
        &self,
        visitor: &'a mut NavigationEntryVisitor,
        current_only: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .get_navigation_entries
                .map(|f| {
                    let (arg_visitor, arg_current_only) = (visitor, current_only);
                    let arg_self_ = self.as_raw();
                    let arg_visitor = arg_visitor.as_raw();
                    let arg_current_only = arg_current_only;
                    let result = f(arg_self_, arg_visitor, arg_current_only);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn replace_misspelling<'a>(&self, word: &'a CefStringUtf16) {
        unsafe {
            self.0
                .replace_misspelling
                .map(|f| {
                    let arg_word = word;
                    let arg_self_ = self.as_raw();
                    let arg_word = arg_word.as_raw();
                    let result = f(arg_self_, arg_word);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn add_word_to_dictionary<'a>(&self, word: &'a CefStringUtf16) {
        unsafe {
            self.0
                .add_word_to_dictionary
                .map(|f| {
                    let arg_word = word;
                    let arg_self_ = self.as_raw();
                    let arg_word = arg_word.as_raw();
                    let result = f(arg_self_, arg_word);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_window_rendering_disabled<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_window_rendering_disabled
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn was_resized<'a>(&self) {
        unsafe {
            self.0
                .was_resized
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn was_hidden<'a>(&self, hidden: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .was_hidden
                .map(|f| {
                    let arg_hidden = hidden;
                    let arg_self_ = self.as_raw();
                    let arg_hidden = arg_hidden;
                    let result = f(arg_self_, arg_hidden);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn notify_screen_info_changed<'a>(&self) {
        unsafe {
            self.0
                .notify_screen_info_changed
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn invalidate<'a>(&self, type_: PaintElementType) {
        unsafe {
            self.0
                .invalidate
                .map(|f| {
                    let arg_type_ = type_;
                    let arg_self_ = self.as_raw();
                    let arg_type_ = arg_type_.as_raw();
                    let result = f(arg_self_, arg_type_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn send_external_begin_frame<'a>(&self) {
        unsafe {
            self.0
                .send_external_begin_frame
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn send_key_event<'a>(&self, event: &'a KeyEvent) {
        unsafe {
            self.0
                .send_key_event
                .map(|f| {
                    let arg_event = event;
                    let arg_self_ = self.as_raw();
                    let mut arg_event: _cef_key_event_t = arg_event.clone().into();
                    let arg_event = &mut arg_event;
                    let result = f(arg_self_, arg_event);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn send_mouse_click_event<'a>(
        &self,
        event: &'a MouseEvent,
        type_: MouseButtonType,
        mouse_up: ::std::os::raw::c_int,
        click_count: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .send_mouse_click_event
                .map(|f| {
                    let (arg_event, arg_type_, arg_mouse_up, arg_click_count) =
                        (event, type_, mouse_up, click_count);
                    let arg_self_ = self.as_raw();
                    let mut arg_event: _cef_mouse_event_t = arg_event.clone().into();
                    let arg_event = &mut arg_event;
                    let arg_type_ = arg_type_.as_raw();
                    let arg_mouse_up = arg_mouse_up;
                    let arg_click_count = arg_click_count;
                    let result = f(
                        arg_self_,
                        arg_event,
                        arg_type_,
                        arg_mouse_up,
                        arg_click_count,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn send_mouse_move_event<'a>(&self, event: &'a MouseEvent, mouse_leave: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .send_mouse_move_event
                .map(|f| {
                    let (arg_event, arg_mouse_leave) = (event, mouse_leave);
                    let arg_self_ = self.as_raw();
                    let mut arg_event: _cef_mouse_event_t = arg_event.clone().into();
                    let arg_event = &mut arg_event;
                    let arg_mouse_leave = arg_mouse_leave;
                    let result = f(arg_self_, arg_event, arg_mouse_leave);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn send_mouse_wheel_event<'a>(
        &self,
        event: &'a MouseEvent,
        delta_x: ::std::os::raw::c_int,
        delta_y: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .send_mouse_wheel_event
                .map(|f| {
                    let (arg_event, arg_delta_x, arg_delta_y) = (event, delta_x, delta_y);
                    let arg_self_ = self.as_raw();
                    let mut arg_event: _cef_mouse_event_t = arg_event.clone().into();
                    let arg_event = &mut arg_event;
                    let arg_delta_x = arg_delta_x;
                    let arg_delta_y = arg_delta_y;
                    let result = f(arg_self_, arg_event, arg_delta_x, arg_delta_y);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn send_touch_event<'a>(&self, event: &'a TouchEvent) {
        unsafe {
            self.0
                .send_touch_event
                .map(|f| {
                    let arg_event = event;
                    let arg_self_ = self.as_raw();
                    let mut arg_event: _cef_touch_event_t = arg_event.clone().into();
                    let arg_event = &mut arg_event;
                    let result = f(arg_self_, arg_event);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn send_capture_lost_event<'a>(&self) {
        unsafe {
            self.0
                .send_capture_lost_event
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn notify_move_or_resize_started<'a>(&self) {
        unsafe {
            self.0
                .notify_move_or_resize_started
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_windowless_frame_rate<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_windowless_frame_rate
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_windowless_frame_rate<'a>(&self, frame_rate: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_windowless_frame_rate
                .map(|f| {
                    let arg_frame_rate = frame_rate;
                    let arg_self_ = self.as_raw();
                    let arg_frame_rate = arg_frame_rate;
                    let result = f(arg_self_, arg_frame_rate);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn ime_set_composition<'a>(
        &self,
        text: &'a CefStringUtf16,
        underlines_count: usize,
        underlines: &'a CompositionUnderline,
        replacement_range: &'a Range,
        selection_range: &'a Range,
    ) {
        unsafe {
            self.0
                .ime_set_composition
                .map(|f| {
                    let (
                        arg_text,
                        arg_underlines_count,
                        arg_underlines,
                        arg_replacement_range,
                        arg_selection_range,
                    ) = (
                        text,
                        underlines_count,
                        underlines,
                        replacement_range,
                        selection_range,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_text = arg_text.as_raw();
                    let arg_underlines_count = arg_underlines_count;
                    let mut arg_underlines: _cef_composition_underline_t =
                        arg_underlines.clone().into();
                    let arg_underlines = &mut arg_underlines;
                    let mut arg_replacement_range: _cef_range_t =
                        arg_replacement_range.clone().into();
                    let arg_replacement_range = &mut arg_replacement_range;
                    let mut arg_selection_range: _cef_range_t = arg_selection_range.clone().into();
                    let arg_selection_range = &mut arg_selection_range;
                    let result = f(
                        arg_self_,
                        arg_text,
                        arg_underlines_count,
                        arg_underlines,
                        arg_replacement_range,
                        arg_selection_range,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn ime_commit_text<'a>(
        &self,
        text: &'a CefStringUtf16,
        replacement_range: &'a Range,
        relative_cursor_pos: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .ime_commit_text
                .map(|f| {
                    let (arg_text, arg_replacement_range, arg_relative_cursor_pos) =
                        (text, replacement_range, relative_cursor_pos);
                    let arg_self_ = self.as_raw();
                    let arg_text = arg_text.as_raw();
                    let mut arg_replacement_range: _cef_range_t =
                        arg_replacement_range.clone().into();
                    let arg_replacement_range = &mut arg_replacement_range;
                    let arg_relative_cursor_pos = arg_relative_cursor_pos;
                    let result = f(
                        arg_self_,
                        arg_text,
                        arg_replacement_range,
                        arg_relative_cursor_pos,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn ime_finish_composing_text<'a>(&self, keep_selection: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .ime_finish_composing_text
                .map(|f| {
                    let arg_keep_selection = keep_selection;
                    let arg_self_ = self.as_raw();
                    let arg_keep_selection = arg_keep_selection;
                    let result = f(arg_self_, arg_keep_selection);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn ime_cancel_composition<'a>(&self) {
        unsafe {
            self.0
                .ime_cancel_composition
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn drag_target_drag_enter<'a>(
        &self,
        drag_data: &'a mut DragData,
        event: &'a MouseEvent,
        allowed_ops: DragOperationsMask,
    ) {
        unsafe {
            self.0
                .drag_target_drag_enter
                .map(|f| {
                    let (arg_drag_data, arg_event, arg_allowed_ops) =
                        (drag_data, event, allowed_ops);
                    let arg_self_ = self.as_raw();
                    let arg_drag_data = arg_drag_data.as_raw();
                    let mut arg_event: _cef_mouse_event_t = arg_event.clone().into();
                    let arg_event = &mut arg_event;
                    let arg_allowed_ops = arg_allowed_ops.as_raw();
                    let result = f(arg_self_, arg_drag_data, arg_event, arg_allowed_ops);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn drag_target_drag_over<'a>(&self, event: &'a MouseEvent, allowed_ops: DragOperationsMask) {
        unsafe {
            self.0
                .drag_target_drag_over
                .map(|f| {
                    let (arg_event, arg_allowed_ops) = (event, allowed_ops);
                    let arg_self_ = self.as_raw();
                    let mut arg_event: _cef_mouse_event_t = arg_event.clone().into();
                    let arg_event = &mut arg_event;
                    let arg_allowed_ops = arg_allowed_ops.as_raw();
                    let result = f(arg_self_, arg_event, arg_allowed_ops);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn drag_target_drag_leave<'a>(&self) {
        unsafe {
            self.0
                .drag_target_drag_leave
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn drag_target_drop<'a>(&self, event: &'a MouseEvent) {
        unsafe {
            self.0
                .drag_target_drop
                .map(|f| {
                    let arg_event = event;
                    let arg_self_ = self.as_raw();
                    let mut arg_event: _cef_mouse_event_t = arg_event.clone().into();
                    let arg_event = &mut arg_event;
                    let result = f(arg_self_, arg_event);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn drag_source_ended_at<'a>(
        &self,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        op: DragOperationsMask,
    ) {
        unsafe {
            self.0
                .drag_source_ended_at
                .map(|f| {
                    let (arg_x, arg_y, arg_op) = (x, y, op);
                    let arg_self_ = self.as_raw();
                    let arg_x = arg_x;
                    let arg_y = arg_y;
                    let arg_op = arg_op.as_raw();
                    let result = f(arg_self_, arg_x, arg_y, arg_op);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn drag_source_system_drag_ended<'a>(&self) {
        unsafe {
            self.0
                .drag_source_system_drag_ended
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_visible_navigation_entry<'a>(&self) -> NavigationEntry {
        unsafe {
            self.0
                .get_visible_navigation_entry
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_accessibility_state<'a>(&self, accessibility_state: State) {
        unsafe {
            self.0
                .set_accessibility_state
                .map(|f| {
                    let arg_accessibility_state = accessibility_state;
                    let arg_self_ = self.as_raw();
                    let arg_accessibility_state = arg_accessibility_state.as_raw();
                    let result = f(arg_self_, arg_accessibility_state);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_auto_resize_enabled<'a>(
        &self,
        enabled: ::std::os::raw::c_int,
        min_size: &'a Size,
        max_size: &'a Size,
    ) {
        unsafe {
            self.0
                .set_auto_resize_enabled
                .map(|f| {
                    let (arg_enabled, arg_min_size, arg_max_size) = (enabled, min_size, max_size);
                    let arg_self_ = self.as_raw();
                    let arg_enabled = arg_enabled;
                    let mut arg_min_size: _cef_size_t = arg_min_size.clone().into();
                    let arg_min_size = &mut arg_min_size;
                    let mut arg_max_size: _cef_size_t = arg_max_size.clone().into();
                    let arg_max_size = &mut arg_max_size;
                    let result = f(arg_self_, arg_enabled, arg_min_size, arg_max_size);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_audio_muted<'a>(&self, mute: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_audio_muted
                .map(|f| {
                    let arg_mute = mute;
                    let arg_self_ = self.as_raw();
                    let arg_mute = arg_mute;
                    let result = f(arg_self_, arg_mute);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_audio_muted<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_audio_muted
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_fullscreen<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_fullscreen
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn exit_fullscreen<'a>(&self, will_cause_resize: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .exit_fullscreen
                .map(|f| {
                    let arg_will_cause_resize = will_cause_resize;
                    let arg_self_ = self.as_raw();
                    let arg_will_cause_resize = arg_will_cause_resize;
                    let result = f(arg_self_, arg_will_cause_resize);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn can_execute_chrome_command<'a>(
        &self,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .can_execute_chrome_command
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let result = f(arg_self_, arg_command_id);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn execute_chrome_command<'a>(
        &self,
        command_id: ::std::os::raw::c_int,
        disposition: WindowOpenDisposition,
    ) {
        unsafe {
            self.0
                .execute_chrome_command
                .map(|f| {
                    let (arg_command_id, arg_disposition) = (command_id, disposition);
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let arg_disposition = arg_disposition.as_raw();
                    let result = f(arg_self_, arg_command_id, arg_disposition);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_render_process_unresponsive<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_render_process_unresponsive
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_runtime_style<'a>(&self) -> RuntimeStyle {
        unsafe {
            self.0
                .get_runtime_style
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_browser_host_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for BrowserHost {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_browser_host_t> for &BrowserHost {
    fn as_raw(self) -> *mut _cef_browser_host_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_browser_host_t> for &mut BrowserHost {
    fn as_raw(self) -> *mut _cef_browser_host_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<BrowserHost> for *mut _cef_browser_host_t {
    fn as_wrapper(self) -> BrowserHost {
        BrowserHost(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_browser_host_t> for BrowserHost {
    fn into(self) -> *mut _cef_browser_host_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for BrowserHost {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplAudioHandler: Sized {
    fn get_audio_parameters<'a>(
        &self,
        browser: &'a mut Browser,
        params: &'a mut AudioParameters,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn on_audio_stream_started<'a>(
        &self,
        browser: &'a mut Browser,
        params: &'a AudioParameters,
        channels: ::std::os::raw::c_int,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn on_audio_stream_packet<'a>(
        &self,
        browser: &'a mut Browser,
        data: *mut *const f32,
        frames: ::std::os::raw::c_int,
        pts: i64,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn on_audio_stream_stopped<'a>(&self, browser: &'a mut Browser) {
        unsafe { std::mem::zeroed() }
    }
    fn on_audio_stream_error<'a>(&self, browser: &'a mut Browser, message: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_audio_handler_t {
        let mut object: _cef_audio_handler_t = unsafe { std::mem::zeroed() };
        impl_cef_audio_handler_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_audio_handler_t {
    use super::*;
    pub fn init_methods<I: ImplAudioHandler>(object: &mut _cef_audio_handler_t) {
        object.get_audio_parameters = Some(get_audio_parameters::<I>);
        object.on_audio_stream_started = Some(on_audio_stream_started::<I>);
        object.on_audio_stream_packet = Some(on_audio_stream_packet::<I>);
        object.on_audio_stream_stopped = Some(on_audio_stream_stopped::<I>);
        object.on_audio_stream_error = Some(on_audio_stream_error::<I>);
    }
    extern "C" fn get_audio_parameters<I: ImplAudioHandler>(
        self_: *mut _cef_audio_handler_t,
        browser: *mut _cef_browser_t,
        params: *mut _cef_audio_parameters_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_params) = (self_, browser, params);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let mut arg_params = WrapParamRef::<AudioParameters>::from(arg_params);
        let arg_params = arg_params.as_mut();
        arg_self_
            .interface
            .get_audio_parameters(arg_browser, arg_params)
            .into()
    }
    extern "C" fn on_audio_stream_started<I: ImplAudioHandler>(
        self_: *mut _cef_audio_handler_t,
        browser: *mut _cef_browser_t,
        params: *const _cef_audio_parameters_t,
        channels: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_browser, arg_params, arg_channels) = (self_, browser, params, channels);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_params = WrapParamRef::<AudioParameters>::from(arg_params);
        let arg_params = arg_params.as_ref();
        let arg_channels = arg_channels.as_raw();
        arg_self_
            .interface
            .on_audio_stream_started(arg_browser, arg_params, arg_channels)
    }
    extern "C" fn on_audio_stream_packet<I: ImplAudioHandler>(
        self_: *mut _cef_audio_handler_t,
        browser: *mut _cef_browser_t,
        data: *mut *const f32,
        frames: ::std::os::raw::c_int,
        pts: i64,
    ) {
        let (arg_self_, arg_browser, arg_data, arg_frames, arg_pts) =
            (self_, browser, data, frames, pts);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let mut arg_data = WrapParamRef::<f32>::from(arg_data);
        let arg_data = arg_data.as_mut();
        let arg_frames = arg_frames.as_raw();
        let arg_pts = arg_pts.as_raw();
        arg_self_
            .interface
            .on_audio_stream_packet(arg_browser, arg_data, arg_frames, arg_pts)
    }
    extern "C" fn on_audio_stream_stopped<I: ImplAudioHandler>(
        self_: *mut _cef_audio_handler_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        arg_self_.interface.on_audio_stream_stopped(arg_browser)
    }
    extern "C" fn on_audio_stream_error<I: ImplAudioHandler>(
        self_: *mut _cef_audio_handler_t,
        browser: *mut _cef_browser_t,
        message: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_browser, arg_message) = (self_, browser, message);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_message = WrapParamRef::<CefStringUtf16>::from(arg_message);
        let arg_message = arg_message.as_ref();
        arg_self_
            .interface
            .on_audio_stream_error(arg_browser, arg_message)
    }
}
#[doc = "See [_cef_audio_handler_t] for more documentation."]
#[derive(Clone)]
pub struct AudioHandler(RefGuard<_cef_audio_handler_t>);
impl ImplAudioHandler for AudioHandler {
    fn get_audio_parameters<'a>(
        &self,
        browser: &'a mut Browser,
        params: &'a mut AudioParameters,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_audio_parameters
                .map(|f| {
                    let (arg_browser, arg_params) = (browser, params);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let mut arg_params: _cef_audio_parameters_t = arg_params.clone().into();
                    let arg_params = &mut arg_params;
                    let result = f(arg_self_, arg_browser, arg_params);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_audio_stream_started<'a>(
        &self,
        browser: &'a mut Browser,
        params: &'a AudioParameters,
        channels: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .on_audio_stream_started
                .map(|f| {
                    let (arg_browser, arg_params, arg_channels) = (browser, params, channels);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let mut arg_params: _cef_audio_parameters_t = arg_params.clone().into();
                    let arg_params = &mut arg_params;
                    let arg_channels = arg_channels;
                    let result = f(arg_self_, arg_browser, arg_params, arg_channels);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_audio_stream_packet<'a>(
        &self,
        browser: &'a mut Browser,
        data: *mut *const f32,
        frames: ::std::os::raw::c_int,
        pts: i64,
    ) {
        unsafe {
            self.0
                .on_audio_stream_packet
                .map(|f| {
                    let (arg_browser, arg_data, arg_frames, arg_pts) = (browser, data, frames, pts);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_data = arg_data as *mut _;
                    let arg_frames = arg_frames;
                    let arg_pts = arg_pts;
                    let result = f(arg_self_, arg_browser, arg_data, arg_frames, arg_pts);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_audio_stream_stopped<'a>(&self, browser: &'a mut Browser) {
        unsafe {
            self.0
                .on_audio_stream_stopped
                .map(|f| {
                    let arg_browser = browser;
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let result = f(arg_self_, arg_browser);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_audio_stream_error<'a>(&self, browser: &'a mut Browser, message: &'a CefStringUtf16) {
        unsafe {
            self.0
                .on_audio_stream_error
                .map(|f| {
                    let (arg_browser, arg_message) = (browser, message);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_message = arg_message.as_raw();
                    let result = f(arg_self_, arg_browser, arg_message);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_audio_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for AudioHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_audio_handler_t> for &AudioHandler {
    fn as_raw(self) -> *mut _cef_audio_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_audio_handler_t> for &mut AudioHandler {
    fn as_raw(self) -> *mut _cef_audio_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<AudioHandler> for *mut _cef_audio_handler_t {
    fn as_wrapper(self) -> AudioHandler {
        AudioHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_audio_handler_t> for AudioHandler {
    fn into(self) -> *mut _cef_audio_handler_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for AudioHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplCommandHandler: Sized {
    fn on_chrome_command<'a>(
        &self,
        browser: &'a mut Browser,
        command_id: ::std::os::raw::c_int,
        disposition: WindowOpenDisposition,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_chrome_app_menu_item_visible<'a>(
        &self,
        browser: &'a mut Browser,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_chrome_app_menu_item_enabled<'a>(
        &self,
        browser: &'a mut Browser,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_chrome_page_action_icon_visible<'a>(
        &self,
        icon_type: ChromePageActionIconType,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_chrome_toolbar_button_visible<'a>(
        &self,
        button_type: ChromeToolbarButtonType,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_command_handler_t {
        let mut object: _cef_command_handler_t = unsafe { std::mem::zeroed() };
        impl_cef_command_handler_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_command_handler_t {
    use super::*;
    pub fn init_methods<I: ImplCommandHandler>(object: &mut _cef_command_handler_t) {
        object.on_chrome_command = Some(on_chrome_command::<I>);
        object.is_chrome_app_menu_item_visible = Some(is_chrome_app_menu_item_visible::<I>);
        object.is_chrome_app_menu_item_enabled = Some(is_chrome_app_menu_item_enabled::<I>);
        object.is_chrome_page_action_icon_visible = Some(is_chrome_page_action_icon_visible::<I>);
        object.is_chrome_toolbar_button_visible = Some(is_chrome_toolbar_button_visible::<I>);
    }
    extern "C" fn on_chrome_command<I: ImplCommandHandler>(
        self_: *mut _cef_command_handler_t,
        browser: *mut _cef_browser_t,
        command_id: ::std::os::raw::c_int,
        disposition: cef_window_open_disposition_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_command_id, arg_disposition) =
            (self_, browser, command_id, disposition);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_command_id = arg_command_id.as_raw();
        let arg_disposition = arg_disposition.as_raw();
        arg_self_
            .interface
            .on_chrome_command(arg_browser, arg_command_id, arg_disposition)
            .into()
    }
    extern "C" fn is_chrome_app_menu_item_visible<I: ImplCommandHandler>(
        self_: *mut _cef_command_handler_t,
        browser: *mut _cef_browser_t,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_command_id) = (self_, browser, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_command_id = arg_command_id.as_raw();
        arg_self_
            .interface
            .is_chrome_app_menu_item_visible(arg_browser, arg_command_id)
            .into()
    }
    extern "C" fn is_chrome_app_menu_item_enabled<I: ImplCommandHandler>(
        self_: *mut _cef_command_handler_t,
        browser: *mut _cef_browser_t,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_command_id) = (self_, browser, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_command_id = arg_command_id.as_raw();
        arg_self_
            .interface
            .is_chrome_app_menu_item_enabled(arg_browser, arg_command_id)
            .into()
    }
    extern "C" fn is_chrome_page_action_icon_visible<I: ImplCommandHandler>(
        self_: *mut _cef_command_handler_t,
        icon_type: cef_chrome_page_action_icon_type_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_icon_type) = (self_, icon_type);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_icon_type = arg_icon_type.as_raw();
        arg_self_
            .interface
            .is_chrome_page_action_icon_visible(arg_icon_type)
            .into()
    }
    extern "C" fn is_chrome_toolbar_button_visible<I: ImplCommandHandler>(
        self_: *mut _cef_command_handler_t,
        button_type: cef_chrome_toolbar_button_type_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_button_type) = (self_, button_type);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_button_type = arg_button_type.as_raw();
        arg_self_
            .interface
            .is_chrome_toolbar_button_visible(arg_button_type)
            .into()
    }
}
#[doc = "See [_cef_command_handler_t] for more documentation."]
#[derive(Clone)]
pub struct CommandHandler(RefGuard<_cef_command_handler_t>);
impl ImplCommandHandler for CommandHandler {
    fn on_chrome_command<'a>(
        &self,
        browser: &'a mut Browser,
        command_id: ::std::os::raw::c_int,
        disposition: WindowOpenDisposition,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_chrome_command
                .map(|f| {
                    let (arg_browser, arg_command_id, arg_disposition) =
                        (browser, command_id, disposition);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_command_id = arg_command_id;
                    let arg_disposition = arg_disposition.as_raw();
                    let result = f(arg_self_, arg_browser, arg_command_id, arg_disposition);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_chrome_app_menu_item_visible<'a>(
        &self,
        browser: &'a mut Browser,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_chrome_app_menu_item_visible
                .map(|f| {
                    let (arg_browser, arg_command_id) = (browser, command_id);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_command_id = arg_command_id;
                    let result = f(arg_self_, arg_browser, arg_command_id);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_chrome_app_menu_item_enabled<'a>(
        &self,
        browser: &'a mut Browser,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_chrome_app_menu_item_enabled
                .map(|f| {
                    let (arg_browser, arg_command_id) = (browser, command_id);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_command_id = arg_command_id;
                    let result = f(arg_self_, arg_browser, arg_command_id);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_chrome_page_action_icon_visible<'a>(
        &self,
        icon_type: ChromePageActionIconType,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_chrome_page_action_icon_visible
                .map(|f| {
                    let arg_icon_type = icon_type;
                    let arg_self_ = self.as_raw();
                    let arg_icon_type = arg_icon_type.as_raw();
                    let result = f(arg_self_, arg_icon_type);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_chrome_toolbar_button_visible<'a>(
        &self,
        button_type: ChromeToolbarButtonType,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_chrome_toolbar_button_visible
                .map(|f| {
                    let arg_button_type = button_type;
                    let arg_self_ = self.as_raw();
                    let arg_button_type = arg_button_type.as_raw();
                    let result = f(arg_self_, arg_button_type);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_command_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for CommandHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_command_handler_t> for &CommandHandler {
    fn as_raw(self) -> *mut _cef_command_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_command_handler_t> for &mut CommandHandler {
    fn as_raw(self) -> *mut _cef_command_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<CommandHandler> for *mut _cef_command_handler_t {
    fn as_wrapper(self) -> CommandHandler {
        CommandHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_command_handler_t> for CommandHandler {
    fn into(self) -> *mut _cef_command_handler_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for CommandHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplMenuModelDelegate: Sized {
    fn execute_command<'a>(
        &self,
        menu_model: &'a mut MenuModel,
        command_id: ::std::os::raw::c_int,
        event_flags: EventFlags,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn mouse_outside_menu<'a>(&self, menu_model: &'a mut MenuModel, screen_point: &'a Point) {
        unsafe { std::mem::zeroed() }
    }
    fn unhandled_open_submenu<'a>(
        &self,
        menu_model: &'a mut MenuModel,
        is_rtl: ::std::os::raw::c_int,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn unhandled_close_submenu<'a>(
        &self,
        menu_model: &'a mut MenuModel,
        is_rtl: ::std::os::raw::c_int,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn menu_will_show<'a>(&self, menu_model: &'a mut MenuModel) {
        unsafe { std::mem::zeroed() }
    }
    fn menu_closed<'a>(&self, menu_model: &'a mut MenuModel) {
        unsafe { std::mem::zeroed() }
    }
    fn format_label<'a>(
        &self,
        menu_model: &'a mut MenuModel,
        label: &'a mut CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_menu_model_delegate_t {
        let mut object: _cef_menu_model_delegate_t = unsafe { std::mem::zeroed() };
        impl_cef_menu_model_delegate_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_menu_model_delegate_t {
    use super::*;
    pub fn init_methods<I: ImplMenuModelDelegate>(object: &mut _cef_menu_model_delegate_t) {
        object.execute_command = Some(execute_command::<I>);
        object.mouse_outside_menu = Some(mouse_outside_menu::<I>);
        object.unhandled_open_submenu = Some(unhandled_open_submenu::<I>);
        object.unhandled_close_submenu = Some(unhandled_close_submenu::<I>);
        object.menu_will_show = Some(menu_will_show::<I>);
        object.menu_closed = Some(menu_closed::<I>);
        object.format_label = Some(format_label::<I>);
    }
    extern "C" fn execute_command<I: ImplMenuModelDelegate>(
        self_: *mut _cef_menu_model_delegate_t,
        menu_model: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
        event_flags: cef_event_flags_t,
    ) {
        let (arg_self_, arg_menu_model, arg_command_id, arg_event_flags) =
            (self_, menu_model, command_id, event_flags);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_menu_model = &mut MenuModel(unsafe { RefGuard::from_raw_add_ref(arg_menu_model) });
        let arg_command_id = arg_command_id.as_raw();
        let arg_event_flags = arg_event_flags.as_raw();
        arg_self_
            .interface
            .execute_command(arg_menu_model, arg_command_id, arg_event_flags)
    }
    extern "C" fn mouse_outside_menu<I: ImplMenuModelDelegate>(
        self_: *mut _cef_menu_model_delegate_t,
        menu_model: *mut _cef_menu_model_t,
        screen_point: *const _cef_point_t,
    ) {
        let (arg_self_, arg_menu_model, arg_screen_point) = (self_, menu_model, screen_point);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_menu_model = &mut MenuModel(unsafe { RefGuard::from_raw_add_ref(arg_menu_model) });
        let arg_screen_point = WrapParamRef::<Point>::from(arg_screen_point);
        let arg_screen_point = arg_screen_point.as_ref();
        arg_self_
            .interface
            .mouse_outside_menu(arg_menu_model, arg_screen_point)
    }
    extern "C" fn unhandled_open_submenu<I: ImplMenuModelDelegate>(
        self_: *mut _cef_menu_model_delegate_t,
        menu_model: *mut _cef_menu_model_t,
        is_rtl: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_menu_model, arg_is_rtl) = (self_, menu_model, is_rtl);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_menu_model = &mut MenuModel(unsafe { RefGuard::from_raw_add_ref(arg_menu_model) });
        let arg_is_rtl = arg_is_rtl.as_raw();
        arg_self_
            .interface
            .unhandled_open_submenu(arg_menu_model, arg_is_rtl)
    }
    extern "C" fn unhandled_close_submenu<I: ImplMenuModelDelegate>(
        self_: *mut _cef_menu_model_delegate_t,
        menu_model: *mut _cef_menu_model_t,
        is_rtl: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_menu_model, arg_is_rtl) = (self_, menu_model, is_rtl);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_menu_model = &mut MenuModel(unsafe { RefGuard::from_raw_add_ref(arg_menu_model) });
        let arg_is_rtl = arg_is_rtl.as_raw();
        arg_self_
            .interface
            .unhandled_close_submenu(arg_menu_model, arg_is_rtl)
    }
    extern "C" fn menu_will_show<I: ImplMenuModelDelegate>(
        self_: *mut _cef_menu_model_delegate_t,
        menu_model: *mut _cef_menu_model_t,
    ) {
        let (arg_self_, arg_menu_model) = (self_, menu_model);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_menu_model = &mut MenuModel(unsafe { RefGuard::from_raw_add_ref(arg_menu_model) });
        arg_self_.interface.menu_will_show(arg_menu_model)
    }
    extern "C" fn menu_closed<I: ImplMenuModelDelegate>(
        self_: *mut _cef_menu_model_delegate_t,
        menu_model: *mut _cef_menu_model_t,
    ) {
        let (arg_self_, arg_menu_model) = (self_, menu_model);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_menu_model = &mut MenuModel(unsafe { RefGuard::from_raw_add_ref(arg_menu_model) });
        arg_self_.interface.menu_closed(arg_menu_model)
    }
    extern "C" fn format_label<I: ImplMenuModelDelegate>(
        self_: *mut _cef_menu_model_delegate_t,
        menu_model: *mut _cef_menu_model_t,
        label: *mut _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_menu_model, arg_label) = (self_, menu_model, label);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_menu_model = &mut MenuModel(unsafe { RefGuard::from_raw_add_ref(arg_menu_model) });
        let mut arg_label = WrapParamRef::<CefStringUtf16>::from(arg_label);
        let arg_label = arg_label.as_mut();
        arg_self_
            .interface
            .format_label(arg_menu_model, arg_label)
            .into()
    }
}
#[doc = "See [_cef_menu_model_delegate_t] for more documentation."]
#[derive(Clone)]
pub struct MenuModelDelegate(RefGuard<_cef_menu_model_delegate_t>);
impl ImplMenuModelDelegate for MenuModelDelegate {
    fn execute_command<'a>(
        &self,
        menu_model: &'a mut MenuModel,
        command_id: ::std::os::raw::c_int,
        event_flags: EventFlags,
    ) {
        unsafe {
            self.0
                .execute_command
                .map(|f| {
                    let (arg_menu_model, arg_command_id, arg_event_flags) =
                        (menu_model, command_id, event_flags);
                    let arg_self_ = self.as_raw();
                    let arg_menu_model = arg_menu_model.as_raw();
                    let arg_command_id = arg_command_id;
                    let arg_event_flags = arg_event_flags.as_raw();
                    let result = f(arg_self_, arg_menu_model, arg_command_id, arg_event_flags);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn mouse_outside_menu<'a>(&self, menu_model: &'a mut MenuModel, screen_point: &'a Point) {
        unsafe {
            self.0
                .mouse_outside_menu
                .map(|f| {
                    let (arg_menu_model, arg_screen_point) = (menu_model, screen_point);
                    let arg_self_ = self.as_raw();
                    let arg_menu_model = arg_menu_model.as_raw();
                    let mut arg_screen_point: _cef_point_t = arg_screen_point.clone().into();
                    let arg_screen_point = &mut arg_screen_point;
                    let result = f(arg_self_, arg_menu_model, arg_screen_point);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn unhandled_open_submenu<'a>(
        &self,
        menu_model: &'a mut MenuModel,
        is_rtl: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .unhandled_open_submenu
                .map(|f| {
                    let (arg_menu_model, arg_is_rtl) = (menu_model, is_rtl);
                    let arg_self_ = self.as_raw();
                    let arg_menu_model = arg_menu_model.as_raw();
                    let arg_is_rtl = arg_is_rtl;
                    let result = f(arg_self_, arg_menu_model, arg_is_rtl);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn unhandled_close_submenu<'a>(
        &self,
        menu_model: &'a mut MenuModel,
        is_rtl: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .unhandled_close_submenu
                .map(|f| {
                    let (arg_menu_model, arg_is_rtl) = (menu_model, is_rtl);
                    let arg_self_ = self.as_raw();
                    let arg_menu_model = arg_menu_model.as_raw();
                    let arg_is_rtl = arg_is_rtl;
                    let result = f(arg_self_, arg_menu_model, arg_is_rtl);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn menu_will_show<'a>(&self, menu_model: &'a mut MenuModel) {
        unsafe {
            self.0
                .menu_will_show
                .map(|f| {
                    let arg_menu_model = menu_model;
                    let arg_self_ = self.as_raw();
                    let arg_menu_model = arg_menu_model.as_raw();
                    let result = f(arg_self_, arg_menu_model);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn menu_closed<'a>(&self, menu_model: &'a mut MenuModel) {
        unsafe {
            self.0
                .menu_closed
                .map(|f| {
                    let arg_menu_model = menu_model;
                    let arg_self_ = self.as_raw();
                    let arg_menu_model = arg_menu_model.as_raw();
                    let result = f(arg_self_, arg_menu_model);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn format_label<'a>(
        &self,
        menu_model: &'a mut MenuModel,
        label: &'a mut CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .format_label
                .map(|f| {
                    let (arg_menu_model, arg_label) = (menu_model, label);
                    let arg_self_ = self.as_raw();
                    let arg_menu_model = arg_menu_model.as_raw();
                    let arg_label = arg_label.as_raw();
                    let result = f(arg_self_, arg_menu_model, arg_label);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_menu_model_delegate_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for MenuModelDelegate {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_menu_model_delegate_t> for &MenuModelDelegate {
    fn as_raw(self) -> *mut _cef_menu_model_delegate_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_menu_model_delegate_t> for &mut MenuModelDelegate {
    fn as_raw(self) -> *mut _cef_menu_model_delegate_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<MenuModelDelegate> for *mut _cef_menu_model_delegate_t {
    fn as_wrapper(self) -> MenuModelDelegate {
        MenuModelDelegate(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_menu_model_delegate_t> for MenuModelDelegate {
    fn into(self) -> *mut _cef_menu_model_delegate_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for MenuModelDelegate {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplMenuModel: Sized {
    fn is_sub_menu<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn clear<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_count<'a>(&self) -> usize {
        unsafe { std::mem::zeroed() }
    }
    fn add_separator<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn add_item<'a>(
        &self,
        command_id: ::std::os::raw::c_int,
        label: &'a CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn add_check_item<'a>(
        &self,
        command_id: ::std::os::raw::c_int,
        label: &'a CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn add_radio_item<'a>(
        &self,
        command_id: ::std::os::raw::c_int,
        label: &'a CefStringUtf16,
        group_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn add_sub_menu<'a>(
        &self,
        command_id: ::std::os::raw::c_int,
        label: &'a CefStringUtf16,
    ) -> MenuModel {
        unsafe { std::mem::zeroed() }
    }
    fn insert_separator_at<'a>(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn insert_item_at<'a>(
        &self,
        index: usize,
        command_id: ::std::os::raw::c_int,
        label: &'a CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn insert_check_item_at<'a>(
        &self,
        index: usize,
        command_id: ::std::os::raw::c_int,
        label: &'a CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn insert_radio_item_at<'a>(
        &self,
        index: usize,
        command_id: ::std::os::raw::c_int,
        label: &'a CefStringUtf16,
        group_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn insert_sub_menu_at<'a>(
        &self,
        index: usize,
        command_id: ::std::os::raw::c_int,
        label: &'a CefStringUtf16,
    ) -> MenuModel {
        unsafe { std::mem::zeroed() }
    }
    fn remove<'a>(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn remove_at<'a>(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_index_of<'a>(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_command_id_at<'a>(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_command_id_at<'a>(
        &self,
        index: usize,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_label<'a>(&self, command_id: ::std::os::raw::c_int) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_label_at<'a>(&self, index: usize) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn set_label<'a>(
        &self,
        command_id: ::std::os::raw::c_int,
        label: &'a CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_label_at<'a>(&self, index: usize, label: &'a CefStringUtf16) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_type<'a>(&self, command_id: ::std::os::raw::c_int) -> MenuItemType {
        unsafe { std::mem::zeroed() }
    }
    fn get_type_at<'a>(&self, index: usize) -> MenuItemType {
        unsafe { std::mem::zeroed() }
    }
    fn get_group_id<'a>(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_group_id_at<'a>(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_group_id<'a>(
        &self,
        command_id: ::std::os::raw::c_int,
        group_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_group_id_at<'a>(
        &self,
        index: usize,
        group_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_sub_menu<'a>(&self, command_id: ::std::os::raw::c_int) -> MenuModel {
        unsafe { std::mem::zeroed() }
    }
    fn get_sub_menu_at<'a>(&self, index: usize) -> MenuModel {
        unsafe { std::mem::zeroed() }
    }
    fn is_visible<'a>(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_visible_at<'a>(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_visible<'a>(
        &self,
        command_id: ::std::os::raw::c_int,
        visible: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_visible_at<'a>(
        &self,
        index: usize,
        visible: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_enabled<'a>(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_enabled_at<'a>(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_enabled<'a>(
        &self,
        command_id: ::std::os::raw::c_int,
        enabled: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_enabled_at<'a>(
        &self,
        index: usize,
        enabled: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_checked<'a>(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_checked_at<'a>(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_checked<'a>(
        &self,
        command_id: ::std::os::raw::c_int,
        checked: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_checked_at<'a>(
        &self,
        index: usize,
        checked: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn has_accelerator<'a>(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn has_accelerator_at<'a>(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_accelerator<'a>(
        &self,
        command_id: ::std::os::raw::c_int,
        key_code: ::std::os::raw::c_int,
        shift_pressed: ::std::os::raw::c_int,
        ctrl_pressed: ::std::os::raw::c_int,
        alt_pressed: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_accelerator_at<'a>(
        &self,
        index: usize,
        key_code: ::std::os::raw::c_int,
        shift_pressed: ::std::os::raw::c_int,
        ctrl_pressed: ::std::os::raw::c_int,
        alt_pressed: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn remove_accelerator<'a>(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn remove_accelerator_at<'a>(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_accelerator<'a>(
        &self,
        command_id: ::std::os::raw::c_int,
        key_code: *mut ::std::os::raw::c_int,
        shift_pressed: *mut ::std::os::raw::c_int,
        ctrl_pressed: *mut ::std::os::raw::c_int,
        alt_pressed: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_accelerator_at<'a>(
        &self,
        index: usize,
        key_code: *mut ::std::os::raw::c_int,
        shift_pressed: *mut ::std::os::raw::c_int,
        ctrl_pressed: *mut ::std::os::raw::c_int,
        alt_pressed: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_color<'a>(
        &self,
        command_id: ::std::os::raw::c_int,
        color_type: MenuColorType,
        color: u32,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_color_at<'a>(
        &self,
        index: ::std::os::raw::c_int,
        color_type: MenuColorType,
        color: u32,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_color<'a>(
        &self,
        command_id: ::std::os::raw::c_int,
        color_type: MenuColorType,
        color: *mut u32,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_color_at<'a>(
        &self,
        index: ::std::os::raw::c_int,
        color_type: MenuColorType,
        color: *mut u32,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_font_list<'a>(
        &self,
        command_id: ::std::os::raw::c_int,
        font_list: &'a CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_font_list_at<'a>(
        &self,
        index: ::std::os::raw::c_int,
        font_list: &'a CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_menu_model_t {
        let mut object: _cef_menu_model_t = unsafe { std::mem::zeroed() };
        impl_cef_menu_model_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_menu_model_t {
    use super::*;
    pub fn init_methods<I: ImplMenuModel>(object: &mut _cef_menu_model_t) {
        object.is_sub_menu = Some(is_sub_menu::<I>);
        object.clear = Some(clear::<I>);
        object.get_count = Some(get_count::<I>);
        object.add_separator = Some(add_separator::<I>);
        object.add_item = Some(add_item::<I>);
        object.add_check_item = Some(add_check_item::<I>);
        object.add_radio_item = Some(add_radio_item::<I>);
        object.add_sub_menu = Some(add_sub_menu::<I>);
        object.insert_separator_at = Some(insert_separator_at::<I>);
        object.insert_item_at = Some(insert_item_at::<I>);
        object.insert_check_item_at = Some(insert_check_item_at::<I>);
        object.insert_radio_item_at = Some(insert_radio_item_at::<I>);
        object.insert_sub_menu_at = Some(insert_sub_menu_at::<I>);
        object.remove = Some(remove::<I>);
        object.remove_at = Some(remove_at::<I>);
        object.get_index_of = Some(get_index_of::<I>);
        object.get_command_id_at = Some(get_command_id_at::<I>);
        object.set_command_id_at = Some(set_command_id_at::<I>);
        object.get_label = Some(get_label::<I>);
        object.get_label_at = Some(get_label_at::<I>);
        object.set_label = Some(set_label::<I>);
        object.set_label_at = Some(set_label_at::<I>);
        object.get_type = Some(get_type::<I>);
        object.get_type_at = Some(get_type_at::<I>);
        object.get_group_id = Some(get_group_id::<I>);
        object.get_group_id_at = Some(get_group_id_at::<I>);
        object.set_group_id = Some(set_group_id::<I>);
        object.set_group_id_at = Some(set_group_id_at::<I>);
        object.get_sub_menu = Some(get_sub_menu::<I>);
        object.get_sub_menu_at = Some(get_sub_menu_at::<I>);
        object.is_visible = Some(is_visible::<I>);
        object.is_visible_at = Some(is_visible_at::<I>);
        object.set_visible = Some(set_visible::<I>);
        object.set_visible_at = Some(set_visible_at::<I>);
        object.is_enabled = Some(is_enabled::<I>);
        object.is_enabled_at = Some(is_enabled_at::<I>);
        object.set_enabled = Some(set_enabled::<I>);
        object.set_enabled_at = Some(set_enabled_at::<I>);
        object.is_checked = Some(is_checked::<I>);
        object.is_checked_at = Some(is_checked_at::<I>);
        object.set_checked = Some(set_checked::<I>);
        object.set_checked_at = Some(set_checked_at::<I>);
        object.has_accelerator = Some(has_accelerator::<I>);
        object.has_accelerator_at = Some(has_accelerator_at::<I>);
        object.set_accelerator = Some(set_accelerator::<I>);
        object.set_accelerator_at = Some(set_accelerator_at::<I>);
        object.remove_accelerator = Some(remove_accelerator::<I>);
        object.remove_accelerator_at = Some(remove_accelerator_at::<I>);
        object.get_accelerator = Some(get_accelerator::<I>);
        object.get_accelerator_at = Some(get_accelerator_at::<I>);
        object.set_color = Some(set_color::<I>);
        object.set_color_at = Some(set_color_at::<I>);
        object.get_color = Some(get_color::<I>);
        object.get_color_at = Some(get_color_at::<I>);
        object.set_font_list = Some(set_font_list::<I>);
        object.set_font_list_at = Some(set_font_list_at::<I>);
    }
    extern "C" fn is_sub_menu<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_sub_menu().into()
    }
    extern "C" fn clear<I: ImplMenuModel>(self_: *mut _cef_menu_model_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.clear().into()
    }
    extern "C" fn get_count<I: ImplMenuModel>(self_: *mut _cef_menu_model_t) -> usize {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_count().into()
    }
    extern "C" fn add_separator<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.add_separator().into()
    }
    extern "C" fn add_item<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
        label: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id, arg_label) = (self_, command_id, label);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let arg_label = WrapParamRef::<CefStringUtf16>::from(arg_label);
        let arg_label = arg_label.as_ref();
        arg_self_
            .interface
            .add_item(arg_command_id, arg_label)
            .into()
    }
    extern "C" fn add_check_item<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
        label: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id, arg_label) = (self_, command_id, label);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let arg_label = WrapParamRef::<CefStringUtf16>::from(arg_label);
        let arg_label = arg_label.as_ref();
        arg_self_
            .interface
            .add_check_item(arg_command_id, arg_label)
            .into()
    }
    extern "C" fn add_radio_item<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
        label: *const _cef_string_utf16_t,
        group_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id, arg_label, arg_group_id) =
            (self_, command_id, label, group_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let arg_label = WrapParamRef::<CefStringUtf16>::from(arg_label);
        let arg_label = arg_label.as_ref();
        let arg_group_id = arg_group_id.as_raw();
        arg_self_
            .interface
            .add_radio_item(arg_command_id, arg_label, arg_group_id)
            .into()
    }
    extern "C" fn add_sub_menu<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
        label: *const _cef_string_utf16_t,
    ) -> *mut _cef_menu_model_t {
        let (arg_self_, arg_command_id, arg_label) = (self_, command_id, label);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let arg_label = WrapParamRef::<CefStringUtf16>::from(arg_label);
        let arg_label = arg_label.as_ref();
        arg_self_
            .interface
            .add_sub_menu(arg_command_id, arg_label)
            .into()
    }
    extern "C" fn insert_separator_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        arg_self_.interface.insert_separator_at(arg_index).into()
    }
    extern "C" fn insert_item_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
        command_id: ::std::os::raw::c_int,
        label: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_command_id, arg_label) = (self_, index, command_id, label);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_command_id = arg_command_id.as_raw();
        let arg_label = WrapParamRef::<CefStringUtf16>::from(arg_label);
        let arg_label = arg_label.as_ref();
        arg_self_
            .interface
            .insert_item_at(arg_index, arg_command_id, arg_label)
            .into()
    }
    extern "C" fn insert_check_item_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
        command_id: ::std::os::raw::c_int,
        label: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_command_id, arg_label) = (self_, index, command_id, label);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_command_id = arg_command_id.as_raw();
        let arg_label = WrapParamRef::<CefStringUtf16>::from(arg_label);
        let arg_label = arg_label.as_ref();
        arg_self_
            .interface
            .insert_check_item_at(arg_index, arg_command_id, arg_label)
            .into()
    }
    extern "C" fn insert_radio_item_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
        command_id: ::std::os::raw::c_int,
        label: *const _cef_string_utf16_t,
        group_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_command_id, arg_label, arg_group_id) =
            (self_, index, command_id, label, group_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_command_id = arg_command_id.as_raw();
        let arg_label = WrapParamRef::<CefStringUtf16>::from(arg_label);
        let arg_label = arg_label.as_ref();
        let arg_group_id = arg_group_id.as_raw();
        arg_self_
            .interface
            .insert_radio_item_at(arg_index, arg_command_id, arg_label, arg_group_id)
            .into()
    }
    extern "C" fn insert_sub_menu_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
        command_id: ::std::os::raw::c_int,
        label: *const _cef_string_utf16_t,
    ) -> *mut _cef_menu_model_t {
        let (arg_self_, arg_index, arg_command_id, arg_label) = (self_, index, command_id, label);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_command_id = arg_command_id.as_raw();
        let arg_label = WrapParamRef::<CefStringUtf16>::from(arg_label);
        let arg_label = arg_label.as_ref();
        arg_self_
            .interface
            .insert_sub_menu_at(arg_index, arg_command_id, arg_label)
            .into()
    }
    extern "C" fn remove<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id) = (self_, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        arg_self_.interface.remove(arg_command_id).into()
    }
    extern "C" fn remove_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        arg_self_.interface.remove_at(arg_index).into()
    }
    extern "C" fn get_index_of<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id) = (self_, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        arg_self_.interface.get_index_of(arg_command_id).into()
    }
    extern "C" fn get_command_id_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        arg_self_.interface.get_command_id_at(arg_index).into()
    }
    extern "C" fn set_command_id_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_command_id) = (self_, index, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_command_id = arg_command_id.as_raw();
        arg_self_
            .interface
            .set_command_id_at(arg_index, arg_command_id)
            .into()
    }
    extern "C" fn get_label<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
    ) -> *mut _cef_string_utf16_t {
        let (arg_self_, arg_command_id) = (self_, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        arg_self_.interface.get_label(arg_command_id).into()
    }
    extern "C" fn get_label_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
    ) -> *mut _cef_string_utf16_t {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        arg_self_.interface.get_label_at(arg_index).into()
    }
    extern "C" fn set_label<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
        label: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id, arg_label) = (self_, command_id, label);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let arg_label = WrapParamRef::<CefStringUtf16>::from(arg_label);
        let arg_label = arg_label.as_ref();
        arg_self_
            .interface
            .set_label(arg_command_id, arg_label)
            .into()
    }
    extern "C" fn set_label_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
        label: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_label) = (self_, index, label);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_label = WrapParamRef::<CefStringUtf16>::from(arg_label);
        let arg_label = arg_label.as_ref();
        arg_self_
            .interface
            .set_label_at(arg_index, arg_label)
            .into()
    }
    extern "C" fn get_type<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
    ) -> cef_menu_item_type_t {
        let (arg_self_, arg_command_id) = (self_, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        arg_self_.interface.get_type(arg_command_id).into()
    }
    extern "C" fn get_type_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
    ) -> cef_menu_item_type_t {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        arg_self_.interface.get_type_at(arg_index).into()
    }
    extern "C" fn get_group_id<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id) = (self_, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        arg_self_.interface.get_group_id(arg_command_id).into()
    }
    extern "C" fn get_group_id_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        arg_self_.interface.get_group_id_at(arg_index).into()
    }
    extern "C" fn set_group_id<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
        group_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id, arg_group_id) = (self_, command_id, group_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let arg_group_id = arg_group_id.as_raw();
        arg_self_
            .interface
            .set_group_id(arg_command_id, arg_group_id)
            .into()
    }
    extern "C" fn set_group_id_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
        group_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_group_id) = (self_, index, group_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_group_id = arg_group_id.as_raw();
        arg_self_
            .interface
            .set_group_id_at(arg_index, arg_group_id)
            .into()
    }
    extern "C" fn get_sub_menu<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
    ) -> *mut _cef_menu_model_t {
        let (arg_self_, arg_command_id) = (self_, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        arg_self_.interface.get_sub_menu(arg_command_id).into()
    }
    extern "C" fn get_sub_menu_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
    ) -> *mut _cef_menu_model_t {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        arg_self_.interface.get_sub_menu_at(arg_index).into()
    }
    extern "C" fn is_visible<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id) = (self_, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        arg_self_.interface.is_visible(arg_command_id).into()
    }
    extern "C" fn is_visible_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        arg_self_.interface.is_visible_at(arg_index).into()
    }
    extern "C" fn set_visible<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
        visible: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id, arg_visible) = (self_, command_id, visible);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let arg_visible = arg_visible.as_raw();
        arg_self_
            .interface
            .set_visible(arg_command_id, arg_visible)
            .into()
    }
    extern "C" fn set_visible_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
        visible: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_visible) = (self_, index, visible);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_visible = arg_visible.as_raw();
        arg_self_
            .interface
            .set_visible_at(arg_index, arg_visible)
            .into()
    }
    extern "C" fn is_enabled<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id) = (self_, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        arg_self_.interface.is_enabled(arg_command_id).into()
    }
    extern "C" fn is_enabled_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        arg_self_.interface.is_enabled_at(arg_index).into()
    }
    extern "C" fn set_enabled<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
        enabled: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id, arg_enabled) = (self_, command_id, enabled);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let arg_enabled = arg_enabled.as_raw();
        arg_self_
            .interface
            .set_enabled(arg_command_id, arg_enabled)
            .into()
    }
    extern "C" fn set_enabled_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
        enabled: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_enabled) = (self_, index, enabled);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_enabled = arg_enabled.as_raw();
        arg_self_
            .interface
            .set_enabled_at(arg_index, arg_enabled)
            .into()
    }
    extern "C" fn is_checked<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id) = (self_, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        arg_self_.interface.is_checked(arg_command_id).into()
    }
    extern "C" fn is_checked_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        arg_self_.interface.is_checked_at(arg_index).into()
    }
    extern "C" fn set_checked<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
        checked: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id, arg_checked) = (self_, command_id, checked);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let arg_checked = arg_checked.as_raw();
        arg_self_
            .interface
            .set_checked(arg_command_id, arg_checked)
            .into()
    }
    extern "C" fn set_checked_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
        checked: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_checked) = (self_, index, checked);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_checked = arg_checked.as_raw();
        arg_self_
            .interface
            .set_checked_at(arg_index, arg_checked)
            .into()
    }
    extern "C" fn has_accelerator<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id) = (self_, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        arg_self_.interface.has_accelerator(arg_command_id).into()
    }
    extern "C" fn has_accelerator_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        arg_self_.interface.has_accelerator_at(arg_index).into()
    }
    extern "C" fn set_accelerator<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
        key_code: ::std::os::raw::c_int,
        shift_pressed: ::std::os::raw::c_int,
        ctrl_pressed: ::std::os::raw::c_int,
        alt_pressed: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_command_id,
            arg_key_code,
            arg_shift_pressed,
            arg_ctrl_pressed,
            arg_alt_pressed,
        ) = (
            self_,
            command_id,
            key_code,
            shift_pressed,
            ctrl_pressed,
            alt_pressed,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let arg_key_code = arg_key_code.as_raw();
        let arg_shift_pressed = arg_shift_pressed.as_raw();
        let arg_ctrl_pressed = arg_ctrl_pressed.as_raw();
        let arg_alt_pressed = arg_alt_pressed.as_raw();
        arg_self_
            .interface
            .set_accelerator(
                arg_command_id,
                arg_key_code,
                arg_shift_pressed,
                arg_ctrl_pressed,
                arg_alt_pressed,
            )
            .into()
    }
    extern "C" fn set_accelerator_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
        key_code: ::std::os::raw::c_int,
        shift_pressed: ::std::os::raw::c_int,
        ctrl_pressed: ::std::os::raw::c_int,
        alt_pressed: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_index,
            arg_key_code,
            arg_shift_pressed,
            arg_ctrl_pressed,
            arg_alt_pressed,
        ) = (
            self_,
            index,
            key_code,
            shift_pressed,
            ctrl_pressed,
            alt_pressed,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_key_code = arg_key_code.as_raw();
        let arg_shift_pressed = arg_shift_pressed.as_raw();
        let arg_ctrl_pressed = arg_ctrl_pressed.as_raw();
        let arg_alt_pressed = arg_alt_pressed.as_raw();
        arg_self_
            .interface
            .set_accelerator_at(
                arg_index,
                arg_key_code,
                arg_shift_pressed,
                arg_ctrl_pressed,
                arg_alt_pressed,
            )
            .into()
    }
    extern "C" fn remove_accelerator<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id) = (self_, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        arg_self_
            .interface
            .remove_accelerator(arg_command_id)
            .into()
    }
    extern "C" fn remove_accelerator_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        arg_self_.interface.remove_accelerator_at(arg_index).into()
    }
    extern "C" fn get_accelerator<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
        key_code: *mut ::std::os::raw::c_int,
        shift_pressed: *mut ::std::os::raw::c_int,
        ctrl_pressed: *mut ::std::os::raw::c_int,
        alt_pressed: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_command_id,
            arg_key_code,
            arg_shift_pressed,
            arg_ctrl_pressed,
            arg_alt_pressed,
        ) = (
            self_,
            command_id,
            key_code,
            shift_pressed,
            ctrl_pressed,
            alt_pressed,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let mut arg_key_code = WrapParamRef::<::std::os::raw::c_int>::from(arg_key_code);
        let arg_key_code = arg_key_code.as_mut();
        let mut arg_shift_pressed = WrapParamRef::<::std::os::raw::c_int>::from(arg_shift_pressed);
        let arg_shift_pressed = arg_shift_pressed.as_mut();
        let mut arg_ctrl_pressed = WrapParamRef::<::std::os::raw::c_int>::from(arg_ctrl_pressed);
        let arg_ctrl_pressed = arg_ctrl_pressed.as_mut();
        let mut arg_alt_pressed = WrapParamRef::<::std::os::raw::c_int>::from(arg_alt_pressed);
        let arg_alt_pressed = arg_alt_pressed.as_mut();
        arg_self_
            .interface
            .get_accelerator(
                arg_command_id,
                arg_key_code,
                arg_shift_pressed,
                arg_ctrl_pressed,
                arg_alt_pressed,
            )
            .into()
    }
    extern "C" fn get_accelerator_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: usize,
        key_code: *mut ::std::os::raw::c_int,
        shift_pressed: *mut ::std::os::raw::c_int,
        ctrl_pressed: *mut ::std::os::raw::c_int,
        alt_pressed: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_index,
            arg_key_code,
            arg_shift_pressed,
            arg_ctrl_pressed,
            arg_alt_pressed,
        ) = (
            self_,
            index,
            key_code,
            shift_pressed,
            ctrl_pressed,
            alt_pressed,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let mut arg_key_code = WrapParamRef::<::std::os::raw::c_int>::from(arg_key_code);
        let arg_key_code = arg_key_code.as_mut();
        let mut arg_shift_pressed = WrapParamRef::<::std::os::raw::c_int>::from(arg_shift_pressed);
        let arg_shift_pressed = arg_shift_pressed.as_mut();
        let mut arg_ctrl_pressed = WrapParamRef::<::std::os::raw::c_int>::from(arg_ctrl_pressed);
        let arg_ctrl_pressed = arg_ctrl_pressed.as_mut();
        let mut arg_alt_pressed = WrapParamRef::<::std::os::raw::c_int>::from(arg_alt_pressed);
        let arg_alt_pressed = arg_alt_pressed.as_mut();
        arg_self_
            .interface
            .get_accelerator_at(
                arg_index,
                arg_key_code,
                arg_shift_pressed,
                arg_ctrl_pressed,
                arg_alt_pressed,
            )
            .into()
    }
    extern "C" fn set_color<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
        color_type: cef_menu_color_type_t,
        color: u32,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id, arg_color_type, arg_color) =
            (self_, command_id, color_type, color);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let arg_color_type = arg_color_type.as_raw();
        let arg_color = arg_color.as_raw();
        arg_self_
            .interface
            .set_color(arg_command_id, arg_color_type, arg_color)
            .into()
    }
    extern "C" fn set_color_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: ::std::os::raw::c_int,
        color_type: cef_menu_color_type_t,
        color: u32,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_color_type, arg_color) = (self_, index, color_type, color);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_color_type = arg_color_type.as_raw();
        let arg_color = arg_color.as_raw();
        arg_self_
            .interface
            .set_color_at(arg_index, arg_color_type, arg_color)
            .into()
    }
    extern "C" fn get_color<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
        color_type: cef_menu_color_type_t,
        color: *mut u32,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id, arg_color_type, arg_color) =
            (self_, command_id, color_type, color);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let arg_color_type = arg_color_type.as_raw();
        let mut arg_color = WrapParamRef::<u32>::from(arg_color);
        let arg_color = arg_color.as_mut();
        arg_self_
            .interface
            .get_color(arg_command_id, arg_color_type, arg_color)
            .into()
    }
    extern "C" fn get_color_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: ::std::os::raw::c_int,
        color_type: cef_menu_color_type_t,
        color: *mut u32,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_color_type, arg_color) = (self_, index, color_type, color);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_color_type = arg_color_type.as_raw();
        let mut arg_color = WrapParamRef::<u32>::from(arg_color);
        let arg_color = arg_color.as_mut();
        arg_self_
            .interface
            .get_color_at(arg_index, arg_color_type, arg_color)
            .into()
    }
    extern "C" fn set_font_list<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
        font_list: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id, arg_font_list) = (self_, command_id, font_list);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let arg_font_list = WrapParamRef::<CefStringUtf16>::from(arg_font_list);
        let arg_font_list = arg_font_list.as_ref();
        arg_self_
            .interface
            .set_font_list(arg_command_id, arg_font_list)
            .into()
    }
    extern "C" fn set_font_list_at<I: ImplMenuModel>(
        self_: *mut _cef_menu_model_t,
        index: ::std::os::raw::c_int,
        font_list: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_font_list) = (self_, index, font_list);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_font_list = WrapParamRef::<CefStringUtf16>::from(arg_font_list);
        let arg_font_list = arg_font_list.as_ref();
        arg_self_
            .interface
            .set_font_list_at(arg_index, arg_font_list)
            .into()
    }
}
#[doc = "See [_cef_menu_model_t] for more documentation."]
#[derive(Clone)]
pub struct MenuModel(RefGuard<_cef_menu_model_t>);
impl ImplMenuModel for MenuModel {
    fn is_sub_menu<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_sub_menu
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn clear<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .clear
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_count<'a>(&self) -> usize {
        unsafe {
            self.0
                .get_count
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn add_separator<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .add_separator
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn add_item<'a>(
        &self,
        command_id: ::std::os::raw::c_int,
        label: &'a CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .add_item
                .map(|f| {
                    let (arg_command_id, arg_label) = (command_id, label);
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let arg_label = arg_label.as_raw();
                    let result = f(arg_self_, arg_command_id, arg_label);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn add_check_item<'a>(
        &self,
        command_id: ::std::os::raw::c_int,
        label: &'a CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .add_check_item
                .map(|f| {
                    let (arg_command_id, arg_label) = (command_id, label);
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let arg_label = arg_label.as_raw();
                    let result = f(arg_self_, arg_command_id, arg_label);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn add_radio_item<'a>(
        &self,
        command_id: ::std::os::raw::c_int,
        label: &'a CefStringUtf16,
        group_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .add_radio_item
                .map(|f| {
                    let (arg_command_id, arg_label, arg_group_id) = (command_id, label, group_id);
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let arg_label = arg_label.as_raw();
                    let arg_group_id = arg_group_id;
                    let result = f(arg_self_, arg_command_id, arg_label, arg_group_id);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn add_sub_menu<'a>(
        &self,
        command_id: ::std::os::raw::c_int,
        label: &'a CefStringUtf16,
    ) -> MenuModel {
        unsafe {
            self.0
                .add_sub_menu
                .map(|f| {
                    let (arg_command_id, arg_label) = (command_id, label);
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let arg_label = arg_label.as_raw();
                    let result = f(arg_self_, arg_command_id, arg_label);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn insert_separator_at<'a>(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .insert_separator_at
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn insert_item_at<'a>(
        &self,
        index: usize,
        command_id: ::std::os::raw::c_int,
        label: &'a CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .insert_item_at
                .map(|f| {
                    let (arg_index, arg_command_id, arg_label) = (index, command_id, label);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_command_id = arg_command_id;
                    let arg_label = arg_label.as_raw();
                    let result = f(arg_self_, arg_index, arg_command_id, arg_label);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn insert_check_item_at<'a>(
        &self,
        index: usize,
        command_id: ::std::os::raw::c_int,
        label: &'a CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .insert_check_item_at
                .map(|f| {
                    let (arg_index, arg_command_id, arg_label) = (index, command_id, label);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_command_id = arg_command_id;
                    let arg_label = arg_label.as_raw();
                    let result = f(arg_self_, arg_index, arg_command_id, arg_label);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn insert_radio_item_at<'a>(
        &self,
        index: usize,
        command_id: ::std::os::raw::c_int,
        label: &'a CefStringUtf16,
        group_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .insert_radio_item_at
                .map(|f| {
                    let (arg_index, arg_command_id, arg_label, arg_group_id) =
                        (index, command_id, label, group_id);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_command_id = arg_command_id;
                    let arg_label = arg_label.as_raw();
                    let arg_group_id = arg_group_id;
                    let result = f(
                        arg_self_,
                        arg_index,
                        arg_command_id,
                        arg_label,
                        arg_group_id,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn insert_sub_menu_at<'a>(
        &self,
        index: usize,
        command_id: ::std::os::raw::c_int,
        label: &'a CefStringUtf16,
    ) -> MenuModel {
        unsafe {
            self.0
                .insert_sub_menu_at
                .map(|f| {
                    let (arg_index, arg_command_id, arg_label) = (index, command_id, label);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_command_id = arg_command_id;
                    let arg_label = arg_label.as_raw();
                    let result = f(arg_self_, arg_index, arg_command_id, arg_label);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn remove<'a>(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .remove
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let result = f(arg_self_, arg_command_id);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn remove_at<'a>(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .remove_at
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_index_of<'a>(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_index_of
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let result = f(arg_self_, arg_command_id);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_command_id_at<'a>(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_command_id_at
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_command_id_at<'a>(
        &self,
        index: usize,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_command_id_at
                .map(|f| {
                    let (arg_index, arg_command_id) = (index, command_id);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_command_id = arg_command_id;
                    let result = f(arg_self_, arg_index, arg_command_id);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_label<'a>(&self, command_id: ::std::os::raw::c_int) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_label
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let result = f(arg_self_, arg_command_id);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_label_at<'a>(&self, index: usize) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_label_at
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_label<'a>(
        &self,
        command_id: ::std::os::raw::c_int,
        label: &'a CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_label
                .map(|f| {
                    let (arg_command_id, arg_label) = (command_id, label);
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let arg_label = arg_label.as_raw();
                    let result = f(arg_self_, arg_command_id, arg_label);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_label_at<'a>(&self, index: usize, label: &'a CefStringUtf16) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_label_at
                .map(|f| {
                    let (arg_index, arg_label) = (index, label);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_label = arg_label.as_raw();
                    let result = f(arg_self_, arg_index, arg_label);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_type<'a>(&self, command_id: ::std::os::raw::c_int) -> MenuItemType {
        unsafe {
            self.0
                .get_type
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let result = f(arg_self_, arg_command_id);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_type_at<'a>(&self, index: usize) -> MenuItemType {
        unsafe {
            self.0
                .get_type_at
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_group_id<'a>(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_group_id
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let result = f(arg_self_, arg_command_id);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_group_id_at<'a>(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_group_id_at
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_group_id<'a>(
        &self,
        command_id: ::std::os::raw::c_int,
        group_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_group_id
                .map(|f| {
                    let (arg_command_id, arg_group_id) = (command_id, group_id);
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let arg_group_id = arg_group_id;
                    let result = f(arg_self_, arg_command_id, arg_group_id);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_group_id_at<'a>(
        &self,
        index: usize,
        group_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_group_id_at
                .map(|f| {
                    let (arg_index, arg_group_id) = (index, group_id);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_group_id = arg_group_id;
                    let result = f(arg_self_, arg_index, arg_group_id);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_sub_menu<'a>(&self, command_id: ::std::os::raw::c_int) -> MenuModel {
        unsafe {
            self.0
                .get_sub_menu
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let result = f(arg_self_, arg_command_id);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_sub_menu_at<'a>(&self, index: usize) -> MenuModel {
        unsafe {
            self.0
                .get_sub_menu_at
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_visible<'a>(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_visible
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let result = f(arg_self_, arg_command_id);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_visible_at<'a>(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_visible_at
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_visible<'a>(
        &self,
        command_id: ::std::os::raw::c_int,
        visible: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_visible
                .map(|f| {
                    let (arg_command_id, arg_visible) = (command_id, visible);
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let arg_visible = arg_visible;
                    let result = f(arg_self_, arg_command_id, arg_visible);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_visible_at<'a>(
        &self,
        index: usize,
        visible: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_visible_at
                .map(|f| {
                    let (arg_index, arg_visible) = (index, visible);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_visible = arg_visible;
                    let result = f(arg_self_, arg_index, arg_visible);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_enabled<'a>(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_enabled
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let result = f(arg_self_, arg_command_id);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_enabled_at<'a>(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_enabled_at
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_enabled<'a>(
        &self,
        command_id: ::std::os::raw::c_int,
        enabled: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_enabled
                .map(|f| {
                    let (arg_command_id, arg_enabled) = (command_id, enabled);
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let arg_enabled = arg_enabled;
                    let result = f(arg_self_, arg_command_id, arg_enabled);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_enabled_at<'a>(
        &self,
        index: usize,
        enabled: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_enabled_at
                .map(|f| {
                    let (arg_index, arg_enabled) = (index, enabled);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_enabled = arg_enabled;
                    let result = f(arg_self_, arg_index, arg_enabled);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_checked<'a>(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_checked
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let result = f(arg_self_, arg_command_id);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_checked_at<'a>(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_checked_at
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_checked<'a>(
        &self,
        command_id: ::std::os::raw::c_int,
        checked: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_checked
                .map(|f| {
                    let (arg_command_id, arg_checked) = (command_id, checked);
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let arg_checked = arg_checked;
                    let result = f(arg_self_, arg_command_id, arg_checked);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_checked_at<'a>(
        &self,
        index: usize,
        checked: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_checked_at
                .map(|f| {
                    let (arg_index, arg_checked) = (index, checked);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_checked = arg_checked;
                    let result = f(arg_self_, arg_index, arg_checked);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn has_accelerator<'a>(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_accelerator
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let result = f(arg_self_, arg_command_id);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn has_accelerator_at<'a>(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_accelerator_at
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_accelerator<'a>(
        &self,
        command_id: ::std::os::raw::c_int,
        key_code: ::std::os::raw::c_int,
        shift_pressed: ::std::os::raw::c_int,
        ctrl_pressed: ::std::os::raw::c_int,
        alt_pressed: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_accelerator
                .map(|f| {
                    let (
                        arg_command_id,
                        arg_key_code,
                        arg_shift_pressed,
                        arg_ctrl_pressed,
                        arg_alt_pressed,
                    ) = (
                        command_id,
                        key_code,
                        shift_pressed,
                        ctrl_pressed,
                        alt_pressed,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let arg_key_code = arg_key_code;
                    let arg_shift_pressed = arg_shift_pressed;
                    let arg_ctrl_pressed = arg_ctrl_pressed;
                    let arg_alt_pressed = arg_alt_pressed;
                    let result = f(
                        arg_self_,
                        arg_command_id,
                        arg_key_code,
                        arg_shift_pressed,
                        arg_ctrl_pressed,
                        arg_alt_pressed,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_accelerator_at<'a>(
        &self,
        index: usize,
        key_code: ::std::os::raw::c_int,
        shift_pressed: ::std::os::raw::c_int,
        ctrl_pressed: ::std::os::raw::c_int,
        alt_pressed: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_accelerator_at
                .map(|f| {
                    let (
                        arg_index,
                        arg_key_code,
                        arg_shift_pressed,
                        arg_ctrl_pressed,
                        arg_alt_pressed,
                    ) = (index, key_code, shift_pressed, ctrl_pressed, alt_pressed);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_key_code = arg_key_code;
                    let arg_shift_pressed = arg_shift_pressed;
                    let arg_ctrl_pressed = arg_ctrl_pressed;
                    let arg_alt_pressed = arg_alt_pressed;
                    let result = f(
                        arg_self_,
                        arg_index,
                        arg_key_code,
                        arg_shift_pressed,
                        arg_ctrl_pressed,
                        arg_alt_pressed,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn remove_accelerator<'a>(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .remove_accelerator
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let result = f(arg_self_, arg_command_id);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn remove_accelerator_at<'a>(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .remove_accelerator_at
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_accelerator<'a>(
        &self,
        command_id: ::std::os::raw::c_int,
        key_code: *mut ::std::os::raw::c_int,
        shift_pressed: *mut ::std::os::raw::c_int,
        ctrl_pressed: *mut ::std::os::raw::c_int,
        alt_pressed: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_accelerator
                .map(|f| {
                    let (
                        arg_command_id,
                        arg_key_code,
                        arg_shift_pressed,
                        arg_ctrl_pressed,
                        arg_alt_pressed,
                    ) = (
                        command_id,
                        key_code,
                        shift_pressed,
                        ctrl_pressed,
                        alt_pressed,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let arg_key_code = arg_key_code as *mut _;
                    let arg_shift_pressed = arg_shift_pressed as *mut _;
                    let arg_ctrl_pressed = arg_ctrl_pressed as *mut _;
                    let arg_alt_pressed = arg_alt_pressed as *mut _;
                    let result = f(
                        arg_self_,
                        arg_command_id,
                        arg_key_code,
                        arg_shift_pressed,
                        arg_ctrl_pressed,
                        arg_alt_pressed,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_accelerator_at<'a>(
        &self,
        index: usize,
        key_code: *mut ::std::os::raw::c_int,
        shift_pressed: *mut ::std::os::raw::c_int,
        ctrl_pressed: *mut ::std::os::raw::c_int,
        alt_pressed: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_accelerator_at
                .map(|f| {
                    let (
                        arg_index,
                        arg_key_code,
                        arg_shift_pressed,
                        arg_ctrl_pressed,
                        arg_alt_pressed,
                    ) = (index, key_code, shift_pressed, ctrl_pressed, alt_pressed);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_key_code = arg_key_code as *mut _;
                    let arg_shift_pressed = arg_shift_pressed as *mut _;
                    let arg_ctrl_pressed = arg_ctrl_pressed as *mut _;
                    let arg_alt_pressed = arg_alt_pressed as *mut _;
                    let result = f(
                        arg_self_,
                        arg_index,
                        arg_key_code,
                        arg_shift_pressed,
                        arg_ctrl_pressed,
                        arg_alt_pressed,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_color<'a>(
        &self,
        command_id: ::std::os::raw::c_int,
        color_type: MenuColorType,
        color: u32,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_color
                .map(|f| {
                    let (arg_command_id, arg_color_type, arg_color) =
                        (command_id, color_type, color);
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let arg_color_type = arg_color_type.as_raw();
                    let arg_color = arg_color;
                    let result = f(arg_self_, arg_command_id, arg_color_type, arg_color);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_color_at<'a>(
        &self,
        index: ::std::os::raw::c_int,
        color_type: MenuColorType,
        color: u32,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_color_at
                .map(|f| {
                    let (arg_index, arg_color_type, arg_color) = (index, color_type, color);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_color_type = arg_color_type.as_raw();
                    let arg_color = arg_color;
                    let result = f(arg_self_, arg_index, arg_color_type, arg_color);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_color<'a>(
        &self,
        command_id: ::std::os::raw::c_int,
        color_type: MenuColorType,
        color: *mut u32,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_color
                .map(|f| {
                    let (arg_command_id, arg_color_type, arg_color) =
                        (command_id, color_type, color);
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let arg_color_type = arg_color_type.as_raw();
                    let arg_color = arg_color as *mut _;
                    let result = f(arg_self_, arg_command_id, arg_color_type, arg_color);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_color_at<'a>(
        &self,
        index: ::std::os::raw::c_int,
        color_type: MenuColorType,
        color: *mut u32,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_color_at
                .map(|f| {
                    let (arg_index, arg_color_type, arg_color) = (index, color_type, color);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_color_type = arg_color_type.as_raw();
                    let arg_color = arg_color as *mut _;
                    let result = f(arg_self_, arg_index, arg_color_type, arg_color);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_font_list<'a>(
        &self,
        command_id: ::std::os::raw::c_int,
        font_list: &'a CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_font_list
                .map(|f| {
                    let (arg_command_id, arg_font_list) = (command_id, font_list);
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let arg_font_list = arg_font_list.as_raw();
                    let result = f(arg_self_, arg_command_id, arg_font_list);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_font_list_at<'a>(
        &self,
        index: ::std::os::raw::c_int,
        font_list: &'a CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_font_list_at
                .map(|f| {
                    let (arg_index, arg_font_list) = (index, font_list);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_font_list = arg_font_list.as_raw();
                    let result = f(arg_self_, arg_index, arg_font_list);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_menu_model_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for MenuModel {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_menu_model_t> for &MenuModel {
    fn as_raw(self) -> *mut _cef_menu_model_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_menu_model_t> for &mut MenuModel {
    fn as_raw(self) -> *mut _cef_menu_model_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<MenuModel> for *mut _cef_menu_model_t {
    fn as_wrapper(self) -> MenuModel {
        MenuModel(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_menu_model_t> for MenuModel {
    fn into(self) -> *mut _cef_menu_model_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for MenuModel {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplRunContextMenuCallback: Sized {
    fn cont<'a>(&self, command_id: ::std::os::raw::c_int, event_flags: EventFlags) {
        unsafe { std::mem::zeroed() }
    }
    fn cancel<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_run_context_menu_callback_t {
        let mut object: _cef_run_context_menu_callback_t = unsafe { std::mem::zeroed() };
        impl_cef_run_context_menu_callback_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_run_context_menu_callback_t {
    use super::*;
    pub fn init_methods<I: ImplRunContextMenuCallback>(
        object: &mut _cef_run_context_menu_callback_t,
    ) {
        object.cont = Some(cont::<I>);
        object.cancel = Some(cancel::<I>);
    }
    extern "C" fn cont<I: ImplRunContextMenuCallback>(
        self_: *mut _cef_run_context_menu_callback_t,
        command_id: ::std::os::raw::c_int,
        event_flags: cef_event_flags_t,
    ) {
        let (arg_self_, arg_command_id, arg_event_flags) = (self_, command_id, event_flags);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let arg_event_flags = arg_event_flags.as_raw();
        arg_self_.interface.cont(arg_command_id, arg_event_flags)
    }
    extern "C" fn cancel<I: ImplRunContextMenuCallback>(
        self_: *mut _cef_run_context_menu_callback_t,
    ) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.cancel()
    }
}
#[doc = "See [_cef_run_context_menu_callback_t] for more documentation."]
#[derive(Clone)]
pub struct RunContextMenuCallback(RefGuard<_cef_run_context_menu_callback_t>);
impl ImplRunContextMenuCallback for RunContextMenuCallback {
    fn cont<'a>(&self, command_id: ::std::os::raw::c_int, event_flags: EventFlags) {
        unsafe {
            self.0
                .cont
                .map(|f| {
                    let (arg_command_id, arg_event_flags) = (command_id, event_flags);
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let arg_event_flags = arg_event_flags.as_raw();
                    let result = f(arg_self_, arg_command_id, arg_event_flags);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn cancel<'a>(&self) {
        unsafe {
            self.0
                .cancel
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_run_context_menu_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for RunContextMenuCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_run_context_menu_callback_t> for &RunContextMenuCallback {
    fn as_raw(self) -> *mut _cef_run_context_menu_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_run_context_menu_callback_t> for &mut RunContextMenuCallback {
    fn as_raw(self) -> *mut _cef_run_context_menu_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<RunContextMenuCallback> for *mut _cef_run_context_menu_callback_t {
    fn as_wrapper(self) -> RunContextMenuCallback {
        RunContextMenuCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_run_context_menu_callback_t> for RunContextMenuCallback {
    fn into(self) -> *mut _cef_run_context_menu_callback_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for RunContextMenuCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplRunQuickMenuCallback: Sized {
    fn cont<'a>(&self, command_id: ::std::os::raw::c_int, event_flags: EventFlags) {
        unsafe { std::mem::zeroed() }
    }
    fn cancel<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_run_quick_menu_callback_t {
        let mut object: _cef_run_quick_menu_callback_t = unsafe { std::mem::zeroed() };
        impl_cef_run_quick_menu_callback_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_run_quick_menu_callback_t {
    use super::*;
    pub fn init_methods<I: ImplRunQuickMenuCallback>(object: &mut _cef_run_quick_menu_callback_t) {
        object.cont = Some(cont::<I>);
        object.cancel = Some(cancel::<I>);
    }
    extern "C" fn cont<I: ImplRunQuickMenuCallback>(
        self_: *mut _cef_run_quick_menu_callback_t,
        command_id: ::std::os::raw::c_int,
        event_flags: cef_event_flags_t,
    ) {
        let (arg_self_, arg_command_id, arg_event_flags) = (self_, command_id, event_flags);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let arg_event_flags = arg_event_flags.as_raw();
        arg_self_.interface.cont(arg_command_id, arg_event_flags)
    }
    extern "C" fn cancel<I: ImplRunQuickMenuCallback>(self_: *mut _cef_run_quick_menu_callback_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.cancel()
    }
}
#[doc = "See [_cef_run_quick_menu_callback_t] for more documentation."]
#[derive(Clone)]
pub struct RunQuickMenuCallback(RefGuard<_cef_run_quick_menu_callback_t>);
impl ImplRunQuickMenuCallback for RunQuickMenuCallback {
    fn cont<'a>(&self, command_id: ::std::os::raw::c_int, event_flags: EventFlags) {
        unsafe {
            self.0
                .cont
                .map(|f| {
                    let (arg_command_id, arg_event_flags) = (command_id, event_flags);
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let arg_event_flags = arg_event_flags.as_raw();
                    let result = f(arg_self_, arg_command_id, arg_event_flags);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn cancel<'a>(&self) {
        unsafe {
            self.0
                .cancel
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_run_quick_menu_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for RunQuickMenuCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_run_quick_menu_callback_t> for &RunQuickMenuCallback {
    fn as_raw(self) -> *mut _cef_run_quick_menu_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_run_quick_menu_callback_t> for &mut RunQuickMenuCallback {
    fn as_raw(self) -> *mut _cef_run_quick_menu_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<RunQuickMenuCallback> for *mut _cef_run_quick_menu_callback_t {
    fn as_wrapper(self) -> RunQuickMenuCallback {
        RunQuickMenuCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_run_quick_menu_callback_t> for RunQuickMenuCallback {
    fn into(self) -> *mut _cef_run_quick_menu_callback_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for RunQuickMenuCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplContextMenuHandler: Sized {
    fn on_before_context_menu<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        params: &'a mut ContextMenuParams,
        model: &'a mut MenuModel,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn run_context_menu<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        params: &'a mut ContextMenuParams,
        model: &'a mut MenuModel,
        callback: &'a mut RunContextMenuCallback,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn on_context_menu_command<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        params: &'a mut ContextMenuParams,
        command_id: ::std::os::raw::c_int,
        event_flags: EventFlags,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn on_context_menu_dismissed<'a>(&self, browser: &'a mut Browser, frame: &'a mut Frame) {
        unsafe { std::mem::zeroed() }
    }
    fn run_quick_menu<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        location: &'a Point,
        size: &'a Size,
        edit_state_flags: QuickMenuEditStateFlags,
        callback: &'a mut RunQuickMenuCallback,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn on_quick_menu_command<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        command_id: ::std::os::raw::c_int,
        event_flags: EventFlags,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn on_quick_menu_dismissed<'a>(&self, browser: &'a mut Browser, frame: &'a mut Frame) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_context_menu_handler_t {
        let mut object: _cef_context_menu_handler_t = unsafe { std::mem::zeroed() };
        impl_cef_context_menu_handler_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_context_menu_handler_t {
    use super::*;
    pub fn init_methods<I: ImplContextMenuHandler>(object: &mut _cef_context_menu_handler_t) {
        object.on_before_context_menu = Some(on_before_context_menu::<I>);
        object.run_context_menu = Some(run_context_menu::<I>);
        object.on_context_menu_command = Some(on_context_menu_command::<I>);
        object.on_context_menu_dismissed = Some(on_context_menu_dismissed::<I>);
        object.run_quick_menu = Some(run_quick_menu::<I>);
        object.on_quick_menu_command = Some(on_quick_menu_command::<I>);
        object.on_quick_menu_dismissed = Some(on_quick_menu_dismissed::<I>);
    }
    extern "C" fn on_before_context_menu<I: ImplContextMenuHandler>(
        self_: *mut _cef_context_menu_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        params: *mut _cef_context_menu_params_t,
        model: *mut _cef_menu_model_t,
    ) {
        let (arg_self_, arg_browser, arg_frame, arg_params, arg_model) =
            (self_, browser, frame, params, model);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_frame) });
        let arg_params = &mut ContextMenuParams(unsafe { RefGuard::from_raw_add_ref(arg_params) });
        let arg_model = &mut MenuModel(unsafe { RefGuard::from_raw_add_ref(arg_model) });
        arg_self_
            .interface
            .on_before_context_menu(arg_browser, arg_frame, arg_params, arg_model)
    }
    extern "C" fn run_context_menu<I: ImplContextMenuHandler>(
        self_: *mut _cef_context_menu_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        params: *mut _cef_context_menu_params_t,
        model: *mut _cef_menu_model_t,
        callback: *mut _cef_run_context_menu_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_frame, arg_params, arg_model, arg_callback) =
            (self_, browser, frame, params, model, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_frame) });
        let arg_params = &mut ContextMenuParams(unsafe { RefGuard::from_raw_add_ref(arg_params) });
        let arg_model = &mut MenuModel(unsafe { RefGuard::from_raw_add_ref(arg_model) });
        let arg_callback =
            &mut RunContextMenuCallback(unsafe { RefGuard::from_raw_add_ref(arg_callback) });
        arg_self_
            .interface
            .run_context_menu(arg_browser, arg_frame, arg_params, arg_model, arg_callback)
            .into()
    }
    extern "C" fn on_context_menu_command<I: ImplContextMenuHandler>(
        self_: *mut _cef_context_menu_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        params: *mut _cef_context_menu_params_t,
        command_id: ::std::os::raw::c_int,
        event_flags: cef_event_flags_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_frame, arg_params, arg_command_id, arg_event_flags) =
            (self_, browser, frame, params, command_id, event_flags);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_frame) });
        let arg_params = &mut ContextMenuParams(unsafe { RefGuard::from_raw_add_ref(arg_params) });
        let arg_command_id = arg_command_id.as_raw();
        let arg_event_flags = arg_event_flags.as_raw();
        arg_self_
            .interface
            .on_context_menu_command(
                arg_browser,
                arg_frame,
                arg_params,
                arg_command_id,
                arg_event_flags,
            )
            .into()
    }
    extern "C" fn on_context_menu_dismissed<I: ImplContextMenuHandler>(
        self_: *mut _cef_context_menu_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
    ) {
        let (arg_self_, arg_browser, arg_frame) = (self_, browser, frame);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_frame) });
        arg_self_
            .interface
            .on_context_menu_dismissed(arg_browser, arg_frame)
    }
    extern "C" fn run_quick_menu<I: ImplContextMenuHandler>(
        self_: *mut _cef_context_menu_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        location: *const _cef_point_t,
        size: *const _cef_size_t,
        edit_state_flags: cef_quick_menu_edit_state_flags_t,
        callback: *mut _cef_run_quick_menu_callback_t,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_browser,
            arg_frame,
            arg_location,
            arg_size,
            arg_edit_state_flags,
            arg_callback,
        ) = (
            self_,
            browser,
            frame,
            location,
            size,
            edit_state_flags,
            callback,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_frame) });
        let arg_location = WrapParamRef::<Point>::from(arg_location);
        let arg_location = arg_location.as_ref();
        let arg_size = WrapParamRef::<Size>::from(arg_size);
        let arg_size = arg_size.as_ref();
        let arg_edit_state_flags = arg_edit_state_flags.as_raw();
        let arg_callback =
            &mut RunQuickMenuCallback(unsafe { RefGuard::from_raw_add_ref(arg_callback) });
        arg_self_
            .interface
            .run_quick_menu(
                arg_browser,
                arg_frame,
                arg_location,
                arg_size,
                arg_edit_state_flags,
                arg_callback,
            )
            .into()
    }
    extern "C" fn on_quick_menu_command<I: ImplContextMenuHandler>(
        self_: *mut _cef_context_menu_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        command_id: ::std::os::raw::c_int,
        event_flags: cef_event_flags_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_frame, arg_command_id, arg_event_flags) =
            (self_, browser, frame, command_id, event_flags);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_frame) });
        let arg_command_id = arg_command_id.as_raw();
        let arg_event_flags = arg_event_flags.as_raw();
        arg_self_
            .interface
            .on_quick_menu_command(arg_browser, arg_frame, arg_command_id, arg_event_flags)
            .into()
    }
    extern "C" fn on_quick_menu_dismissed<I: ImplContextMenuHandler>(
        self_: *mut _cef_context_menu_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
    ) {
        let (arg_self_, arg_browser, arg_frame) = (self_, browser, frame);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_frame) });
        arg_self_
            .interface
            .on_quick_menu_dismissed(arg_browser, arg_frame)
    }
}
#[doc = "See [_cef_context_menu_handler_t] for more documentation."]
#[derive(Clone)]
pub struct ContextMenuHandler(RefGuard<_cef_context_menu_handler_t>);
impl ImplContextMenuHandler for ContextMenuHandler {
    fn on_before_context_menu<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        params: &'a mut ContextMenuParams,
        model: &'a mut MenuModel,
    ) {
        unsafe {
            self.0
                .on_before_context_menu
                .map(|f| {
                    let (arg_browser, arg_frame, arg_params, arg_model) =
                        (browser, frame, params, model);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_frame = arg_frame.as_raw();
                    let arg_params = arg_params.as_raw();
                    let arg_model = arg_model.as_raw();
                    let result = f(arg_self_, arg_browser, arg_frame, arg_params, arg_model);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn run_context_menu<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        params: &'a mut ContextMenuParams,
        model: &'a mut MenuModel,
        callback: &'a mut RunContextMenuCallback,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .run_context_menu
                .map(|f| {
                    let (arg_browser, arg_frame, arg_params, arg_model, arg_callback) =
                        (browser, frame, params, model, callback);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_frame = arg_frame.as_raw();
                    let arg_params = arg_params.as_raw();
                    let arg_model = arg_model.as_raw();
                    let arg_callback = arg_callback.as_raw();
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_params,
                        arg_model,
                        arg_callback,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_context_menu_command<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        params: &'a mut ContextMenuParams,
        command_id: ::std::os::raw::c_int,
        event_flags: EventFlags,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_context_menu_command
                .map(|f| {
                    let (arg_browser, arg_frame, arg_params, arg_command_id, arg_event_flags) =
                        (browser, frame, params, command_id, event_flags);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_frame = arg_frame.as_raw();
                    let arg_params = arg_params.as_raw();
                    let arg_command_id = arg_command_id;
                    let arg_event_flags = arg_event_flags.as_raw();
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_params,
                        arg_command_id,
                        arg_event_flags,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_context_menu_dismissed<'a>(&self, browser: &'a mut Browser, frame: &'a mut Frame) {
        unsafe {
            self.0
                .on_context_menu_dismissed
                .map(|f| {
                    let (arg_browser, arg_frame) = (browser, frame);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_frame = arg_frame.as_raw();
                    let result = f(arg_self_, arg_browser, arg_frame);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn run_quick_menu<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        location: &'a Point,
        size: &'a Size,
        edit_state_flags: QuickMenuEditStateFlags,
        callback: &'a mut RunQuickMenuCallback,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .run_quick_menu
                .map(|f| {
                    let (
                        arg_browser,
                        arg_frame,
                        arg_location,
                        arg_size,
                        arg_edit_state_flags,
                        arg_callback,
                    ) = (browser, frame, location, size, edit_state_flags, callback);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_frame = arg_frame.as_raw();
                    let mut arg_location: _cef_point_t = arg_location.clone().into();
                    let arg_location = &mut arg_location;
                    let mut arg_size: _cef_size_t = arg_size.clone().into();
                    let arg_size = &mut arg_size;
                    let arg_edit_state_flags = arg_edit_state_flags.as_raw();
                    let arg_callback = arg_callback.as_raw();
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_location,
                        arg_size,
                        arg_edit_state_flags,
                        arg_callback,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_quick_menu_command<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        command_id: ::std::os::raw::c_int,
        event_flags: EventFlags,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_quick_menu_command
                .map(|f| {
                    let (arg_browser, arg_frame, arg_command_id, arg_event_flags) =
                        (browser, frame, command_id, event_flags);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_frame = arg_frame.as_raw();
                    let arg_command_id = arg_command_id;
                    let arg_event_flags = arg_event_flags.as_raw();
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_command_id,
                        arg_event_flags,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_quick_menu_dismissed<'a>(&self, browser: &'a mut Browser, frame: &'a mut Frame) {
        unsafe {
            self.0
                .on_quick_menu_dismissed
                .map(|f| {
                    let (arg_browser, arg_frame) = (browser, frame);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_frame = arg_frame.as_raw();
                    let result = f(arg_self_, arg_browser, arg_frame);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_context_menu_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ContextMenuHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_context_menu_handler_t> for &ContextMenuHandler {
    fn as_raw(self) -> *mut _cef_context_menu_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_context_menu_handler_t> for &mut ContextMenuHandler {
    fn as_raw(self) -> *mut _cef_context_menu_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<ContextMenuHandler> for *mut _cef_context_menu_handler_t {
    fn as_wrapper(self) -> ContextMenuHandler {
        ContextMenuHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_context_menu_handler_t> for ContextMenuHandler {
    fn into(self) -> *mut _cef_context_menu_handler_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for ContextMenuHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplContextMenuParams: Sized {
    fn get_xcoord<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_ycoord<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_type_flags<'a>(&self) -> ContextMenuTypeFlags {
        unsafe { std::mem::zeroed() }
    }
    fn get_link_url<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_unfiltered_link_url<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_source_url<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn has_image_contents<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_title_text<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_page_url<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_frame_url<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_frame_charset<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_media_type<'a>(&self) -> ContextMenuMediaType {
        unsafe { std::mem::zeroed() }
    }
    fn get_media_state_flags<'a>(&self) -> ContextMenuMediaStateFlags {
        unsafe { std::mem::zeroed() }
    }
    fn get_selection_text<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_misspelled_word<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_dictionary_suggestions<'a>(
        &self,
        suggestions: &'a mut CefStringList,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_editable<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_spell_check_enabled<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_edit_state_flags<'a>(&self) -> ContextMenuEditStateFlags {
        unsafe { std::mem::zeroed() }
    }
    fn is_custom_menu<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_context_menu_params_t {
        let mut object: _cef_context_menu_params_t = unsafe { std::mem::zeroed() };
        impl_cef_context_menu_params_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_context_menu_params_t {
    use super::*;
    pub fn init_methods<I: ImplContextMenuParams>(object: &mut _cef_context_menu_params_t) {
        object.get_xcoord = Some(get_xcoord::<I>);
        object.get_ycoord = Some(get_ycoord::<I>);
        object.get_type_flags = Some(get_type_flags::<I>);
        object.get_link_url = Some(get_link_url::<I>);
        object.get_unfiltered_link_url = Some(get_unfiltered_link_url::<I>);
        object.get_source_url = Some(get_source_url::<I>);
        object.has_image_contents = Some(has_image_contents::<I>);
        object.get_title_text = Some(get_title_text::<I>);
        object.get_page_url = Some(get_page_url::<I>);
        object.get_frame_url = Some(get_frame_url::<I>);
        object.get_frame_charset = Some(get_frame_charset::<I>);
        object.get_media_type = Some(get_media_type::<I>);
        object.get_media_state_flags = Some(get_media_state_flags::<I>);
        object.get_selection_text = Some(get_selection_text::<I>);
        object.get_misspelled_word = Some(get_misspelled_word::<I>);
        object.get_dictionary_suggestions = Some(get_dictionary_suggestions::<I>);
        object.is_editable = Some(is_editable::<I>);
        object.is_spell_check_enabled = Some(is_spell_check_enabled::<I>);
        object.get_edit_state_flags = Some(get_edit_state_flags::<I>);
        object.is_custom_menu = Some(is_custom_menu::<I>);
    }
    extern "C" fn get_xcoord<I: ImplContextMenuParams>(
        self_: *mut _cef_context_menu_params_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_xcoord().into()
    }
    extern "C" fn get_ycoord<I: ImplContextMenuParams>(
        self_: *mut _cef_context_menu_params_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_ycoord().into()
    }
    extern "C" fn get_type_flags<I: ImplContextMenuParams>(
        self_: *mut _cef_context_menu_params_t,
    ) -> cef_context_menu_type_flags_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_type_flags().into()
    }
    extern "C" fn get_link_url<I: ImplContextMenuParams>(
        self_: *mut _cef_context_menu_params_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_link_url().into()
    }
    extern "C" fn get_unfiltered_link_url<I: ImplContextMenuParams>(
        self_: *mut _cef_context_menu_params_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_unfiltered_link_url().into()
    }
    extern "C" fn get_source_url<I: ImplContextMenuParams>(
        self_: *mut _cef_context_menu_params_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_source_url().into()
    }
    extern "C" fn has_image_contents<I: ImplContextMenuParams>(
        self_: *mut _cef_context_menu_params_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.has_image_contents().into()
    }
    extern "C" fn get_title_text<I: ImplContextMenuParams>(
        self_: *mut _cef_context_menu_params_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_title_text().into()
    }
    extern "C" fn get_page_url<I: ImplContextMenuParams>(
        self_: *mut _cef_context_menu_params_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_page_url().into()
    }
    extern "C" fn get_frame_url<I: ImplContextMenuParams>(
        self_: *mut _cef_context_menu_params_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_frame_url().into()
    }
    extern "C" fn get_frame_charset<I: ImplContextMenuParams>(
        self_: *mut _cef_context_menu_params_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_frame_charset().into()
    }
    extern "C" fn get_media_type<I: ImplContextMenuParams>(
        self_: *mut _cef_context_menu_params_t,
    ) -> cef_context_menu_media_type_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_media_type().into()
    }
    extern "C" fn get_media_state_flags<I: ImplContextMenuParams>(
        self_: *mut _cef_context_menu_params_t,
    ) -> cef_context_menu_media_state_flags_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_media_state_flags().into()
    }
    extern "C" fn get_selection_text<I: ImplContextMenuParams>(
        self_: *mut _cef_context_menu_params_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_selection_text().into()
    }
    extern "C" fn get_misspelled_word<I: ImplContextMenuParams>(
        self_: *mut _cef_context_menu_params_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_misspelled_word().into()
    }
    extern "C" fn get_dictionary_suggestions<I: ImplContextMenuParams>(
        self_: *mut _cef_context_menu_params_t,
        suggestions: *mut _cef_string_list_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_suggestions) = (self_, suggestions);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_suggestions = WrapParamRef::<CefStringList>::from(arg_suggestions);
        let arg_suggestions = arg_suggestions.as_mut();
        arg_self_
            .interface
            .get_dictionary_suggestions(arg_suggestions)
            .into()
    }
    extern "C" fn is_editable<I: ImplContextMenuParams>(
        self_: *mut _cef_context_menu_params_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_editable().into()
    }
    extern "C" fn is_spell_check_enabled<I: ImplContextMenuParams>(
        self_: *mut _cef_context_menu_params_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_spell_check_enabled().into()
    }
    extern "C" fn get_edit_state_flags<I: ImplContextMenuParams>(
        self_: *mut _cef_context_menu_params_t,
    ) -> cef_context_menu_edit_state_flags_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_edit_state_flags().into()
    }
    extern "C" fn is_custom_menu<I: ImplContextMenuParams>(
        self_: *mut _cef_context_menu_params_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_custom_menu().into()
    }
}
#[doc = "See [_cef_context_menu_params_t] for more documentation."]
#[derive(Clone)]
pub struct ContextMenuParams(RefGuard<_cef_context_menu_params_t>);
impl ImplContextMenuParams for ContextMenuParams {
    fn get_xcoord<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_xcoord
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_ycoord<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_ycoord
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_type_flags<'a>(&self) -> ContextMenuTypeFlags {
        unsafe {
            self.0
                .get_type_flags
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_link_url<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_link_url
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_unfiltered_link_url<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_unfiltered_link_url
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_source_url<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_source_url
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn has_image_contents<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_image_contents
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_title_text<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_title_text
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_page_url<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_page_url
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_frame_url<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_frame_url
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_frame_charset<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_frame_charset
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_media_type<'a>(&self) -> ContextMenuMediaType {
        unsafe {
            self.0
                .get_media_type
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_media_state_flags<'a>(&self) -> ContextMenuMediaStateFlags {
        unsafe {
            self.0
                .get_media_state_flags
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_selection_text<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_selection_text
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_misspelled_word<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_misspelled_word
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_dictionary_suggestions<'a>(
        &self,
        suggestions: &'a mut CefStringList,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_dictionary_suggestions
                .map(|f| {
                    let arg_suggestions = suggestions;
                    let arg_self_ = self.as_raw();
                    let arg_suggestions = arg_suggestions.as_raw();
                    let result = f(arg_self_, arg_suggestions);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_editable<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_editable
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_spell_check_enabled<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_spell_check_enabled
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_edit_state_flags<'a>(&self) -> ContextMenuEditStateFlags {
        unsafe {
            self.0
                .get_edit_state_flags
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_custom_menu<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_custom_menu
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_context_menu_params_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ContextMenuParams {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_context_menu_params_t> for &ContextMenuParams {
    fn as_raw(self) -> *mut _cef_context_menu_params_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_context_menu_params_t> for &mut ContextMenuParams {
    fn as_raw(self) -> *mut _cef_context_menu_params_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<ContextMenuParams> for *mut _cef_context_menu_params_t {
    fn as_wrapper(self) -> ContextMenuParams {
        ContextMenuParams(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_context_menu_params_t> for ContextMenuParams {
    fn into(self) -> *mut _cef_context_menu_params_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for ContextMenuParams {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplFileDialogCallback: Sized {
    fn cont<'a>(&self, file_paths: &'a mut CefStringList) {
        unsafe { std::mem::zeroed() }
    }
    fn cancel<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_file_dialog_callback_t {
        let mut object: _cef_file_dialog_callback_t = unsafe { std::mem::zeroed() };
        impl_cef_file_dialog_callback_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_file_dialog_callback_t {
    use super::*;
    pub fn init_methods<I: ImplFileDialogCallback>(object: &mut _cef_file_dialog_callback_t) {
        object.cont = Some(cont::<I>);
        object.cancel = Some(cancel::<I>);
    }
    extern "C" fn cont<I: ImplFileDialogCallback>(
        self_: *mut _cef_file_dialog_callback_t,
        file_paths: *mut _cef_string_list_t,
    ) {
        let (arg_self_, arg_file_paths) = (self_, file_paths);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_file_paths = WrapParamRef::<CefStringList>::from(arg_file_paths);
        let arg_file_paths = arg_file_paths.as_mut();
        arg_self_.interface.cont(arg_file_paths)
    }
    extern "C" fn cancel<I: ImplFileDialogCallback>(self_: *mut _cef_file_dialog_callback_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.cancel()
    }
}
#[doc = "See [_cef_file_dialog_callback_t] for more documentation."]
#[derive(Clone)]
pub struct FileDialogCallback(RefGuard<_cef_file_dialog_callback_t>);
impl ImplFileDialogCallback for FileDialogCallback {
    fn cont<'a>(&self, file_paths: &'a mut CefStringList) {
        unsafe {
            self.0
                .cont
                .map(|f| {
                    let arg_file_paths = file_paths;
                    let arg_self_ = self.as_raw();
                    let arg_file_paths = arg_file_paths.as_raw();
                    let result = f(arg_self_, arg_file_paths);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn cancel<'a>(&self) {
        unsafe {
            self.0
                .cancel
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_file_dialog_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for FileDialogCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_file_dialog_callback_t> for &FileDialogCallback {
    fn as_raw(self) -> *mut _cef_file_dialog_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_file_dialog_callback_t> for &mut FileDialogCallback {
    fn as_raw(self) -> *mut _cef_file_dialog_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<FileDialogCallback> for *mut _cef_file_dialog_callback_t {
    fn as_wrapper(self) -> FileDialogCallback {
        FileDialogCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_file_dialog_callback_t> for FileDialogCallback {
    fn into(self) -> *mut _cef_file_dialog_callback_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for FileDialogCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplDialogHandler: Sized {
    fn on_file_dialog<'a>(
        &self,
        browser: &'a mut Browser,
        mode: FileDialogMode,
        title: &'a CefStringUtf16,
        default_file_path: &'a CefStringUtf16,
        accept_filters: &'a mut CefStringList,
        accept_extensions: &'a mut CefStringList,
        accept_descriptions: &'a mut CefStringList,
        callback: &'a mut FileDialogCallback,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_dialog_handler_t {
        let mut object: _cef_dialog_handler_t = unsafe { std::mem::zeroed() };
        impl_cef_dialog_handler_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_dialog_handler_t {
    use super::*;
    pub fn init_methods<I: ImplDialogHandler>(object: &mut _cef_dialog_handler_t) {
        object.on_file_dialog = Some(on_file_dialog::<I>);
    }
    extern "C" fn on_file_dialog<I: ImplDialogHandler>(
        self_: *mut _cef_dialog_handler_t,
        browser: *mut _cef_browser_t,
        mode: cef_file_dialog_mode_t,
        title: *const _cef_string_utf16_t,
        default_file_path: *const _cef_string_utf16_t,
        accept_filters: *mut _cef_string_list_t,
        accept_extensions: *mut _cef_string_list_t,
        accept_descriptions: *mut _cef_string_list_t,
        callback: *mut _cef_file_dialog_callback_t,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_browser,
            arg_mode,
            arg_title,
            arg_default_file_path,
            arg_accept_filters,
            arg_accept_extensions,
            arg_accept_descriptions,
            arg_callback,
        ) = (
            self_,
            browser,
            mode,
            title,
            default_file_path,
            accept_filters,
            accept_extensions,
            accept_descriptions,
            callback,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_mode = arg_mode.as_raw();
        let arg_title = WrapParamRef::<CefStringUtf16>::from(arg_title);
        let arg_title = arg_title.as_ref();
        let arg_default_file_path = WrapParamRef::<CefStringUtf16>::from(arg_default_file_path);
        let arg_default_file_path = arg_default_file_path.as_ref();
        let mut arg_accept_filters = WrapParamRef::<CefStringList>::from(arg_accept_filters);
        let arg_accept_filters = arg_accept_filters.as_mut();
        let mut arg_accept_extensions = WrapParamRef::<CefStringList>::from(arg_accept_extensions);
        let arg_accept_extensions = arg_accept_extensions.as_mut();
        let mut arg_accept_descriptions =
            WrapParamRef::<CefStringList>::from(arg_accept_descriptions);
        let arg_accept_descriptions = arg_accept_descriptions.as_mut();
        let arg_callback =
            &mut FileDialogCallback(unsafe { RefGuard::from_raw_add_ref(arg_callback) });
        arg_self_
            .interface
            .on_file_dialog(
                arg_browser,
                arg_mode,
                arg_title,
                arg_default_file_path,
                arg_accept_filters,
                arg_accept_extensions,
                arg_accept_descriptions,
                arg_callback,
            )
            .into()
    }
}
#[doc = "See [_cef_dialog_handler_t] for more documentation."]
#[derive(Clone)]
pub struct DialogHandler(RefGuard<_cef_dialog_handler_t>);
impl ImplDialogHandler for DialogHandler {
    fn on_file_dialog<'a>(
        &self,
        browser: &'a mut Browser,
        mode: FileDialogMode,
        title: &'a CefStringUtf16,
        default_file_path: &'a CefStringUtf16,
        accept_filters: &'a mut CefStringList,
        accept_extensions: &'a mut CefStringList,
        accept_descriptions: &'a mut CefStringList,
        callback: &'a mut FileDialogCallback,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_file_dialog
                .map(|f| {
                    let (
                        arg_browser,
                        arg_mode,
                        arg_title,
                        arg_default_file_path,
                        arg_accept_filters,
                        arg_accept_extensions,
                        arg_accept_descriptions,
                        arg_callback,
                    ) = (
                        browser,
                        mode,
                        title,
                        default_file_path,
                        accept_filters,
                        accept_extensions,
                        accept_descriptions,
                        callback,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_mode = arg_mode.as_raw();
                    let arg_title = arg_title.as_raw();
                    let arg_default_file_path = arg_default_file_path.as_raw();
                    let arg_accept_filters = arg_accept_filters.as_raw();
                    let arg_accept_extensions = arg_accept_extensions.as_raw();
                    let arg_accept_descriptions = arg_accept_descriptions.as_raw();
                    let arg_callback = arg_callback.as_raw();
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_mode,
                        arg_title,
                        arg_default_file_path,
                        arg_accept_filters,
                        arg_accept_extensions,
                        arg_accept_descriptions,
                        arg_callback,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_dialog_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for DialogHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_dialog_handler_t> for &DialogHandler {
    fn as_raw(self) -> *mut _cef_dialog_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_dialog_handler_t> for &mut DialogHandler {
    fn as_raw(self) -> *mut _cef_dialog_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<DialogHandler> for *mut _cef_dialog_handler_t {
    fn as_wrapper(self) -> DialogHandler {
        DialogHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_dialog_handler_t> for DialogHandler {
    fn into(self) -> *mut _cef_dialog_handler_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for DialogHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplDisplayHandler: Sized {
    fn on_address_change<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        url: &'a CefStringUtf16,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn on_title_change<'a>(&self, browser: &'a mut Browser, title: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn on_favicon_urlchange<'a>(&self, browser: &'a mut Browser, icon_urls: &'a mut CefStringList) {
        unsafe { std::mem::zeroed() }
    }
    fn on_fullscreen_mode_change<'a>(
        &self,
        browser: &'a mut Browser,
        fullscreen: ::std::os::raw::c_int,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn on_tooltip<'a>(
        &self,
        browser: &'a mut Browser,
        text: &'a mut CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn on_status_message<'a>(&self, browser: &'a mut Browser, value: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn on_console_message<'a>(
        &self,
        browser: &'a mut Browser,
        level: LogSeverity,
        message: &'a CefStringUtf16,
        source: &'a CefStringUtf16,
        line: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn on_auto_resize<'a>(
        &self,
        browser: &'a mut Browser,
        new_size: &'a Size,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn on_loading_progress_change<'a>(&self, browser: &'a mut Browser, progress: f64) {
        unsafe { std::mem::zeroed() }
    }
    fn on_cursor_change<'a>(
        &self,
        browser: &'a mut Browser,
        cursor: ::std::os::raw::c_ulong,
        type_: CursorType,
        custom_cursor_info: &'a CursorInfo,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn on_media_access_change<'a>(
        &self,
        browser: &'a mut Browser,
        has_video_access: ::std::os::raw::c_int,
        has_audio_access: ::std::os::raw::c_int,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_display_handler_t {
        let mut object: _cef_display_handler_t = unsafe { std::mem::zeroed() };
        impl_cef_display_handler_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_display_handler_t {
    use super::*;
    pub fn init_methods<I: ImplDisplayHandler>(object: &mut _cef_display_handler_t) {
        object.on_address_change = Some(on_address_change::<I>);
        object.on_title_change = Some(on_title_change::<I>);
        object.on_favicon_urlchange = Some(on_favicon_urlchange::<I>);
        object.on_fullscreen_mode_change = Some(on_fullscreen_mode_change::<I>);
        object.on_tooltip = Some(on_tooltip::<I>);
        object.on_status_message = Some(on_status_message::<I>);
        object.on_console_message = Some(on_console_message::<I>);
        object.on_auto_resize = Some(on_auto_resize::<I>);
        object.on_loading_progress_change = Some(on_loading_progress_change::<I>);
        object.on_cursor_change = Some(on_cursor_change::<I>);
        object.on_media_access_change = Some(on_media_access_change::<I>);
    }
    extern "C" fn on_address_change<I: ImplDisplayHandler>(
        self_: *mut _cef_display_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        url: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_browser, arg_frame, arg_url) = (self_, browser, frame, url);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_frame) });
        let arg_url = WrapParamRef::<CefStringUtf16>::from(arg_url);
        let arg_url = arg_url.as_ref();
        arg_self_
            .interface
            .on_address_change(arg_browser, arg_frame, arg_url)
    }
    extern "C" fn on_title_change<I: ImplDisplayHandler>(
        self_: *mut _cef_display_handler_t,
        browser: *mut _cef_browser_t,
        title: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_browser, arg_title) = (self_, browser, title);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_title = WrapParamRef::<CefStringUtf16>::from(arg_title);
        let arg_title = arg_title.as_ref();
        arg_self_.interface.on_title_change(arg_browser, arg_title)
    }
    extern "C" fn on_favicon_urlchange<I: ImplDisplayHandler>(
        self_: *mut _cef_display_handler_t,
        browser: *mut _cef_browser_t,
        icon_urls: *mut _cef_string_list_t,
    ) {
        let (arg_self_, arg_browser, arg_icon_urls) = (self_, browser, icon_urls);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let mut arg_icon_urls = WrapParamRef::<CefStringList>::from(arg_icon_urls);
        let arg_icon_urls = arg_icon_urls.as_mut();
        arg_self_
            .interface
            .on_favicon_urlchange(arg_browser, arg_icon_urls)
    }
    extern "C" fn on_fullscreen_mode_change<I: ImplDisplayHandler>(
        self_: *mut _cef_display_handler_t,
        browser: *mut _cef_browser_t,
        fullscreen: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_browser, arg_fullscreen) = (self_, browser, fullscreen);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_fullscreen = arg_fullscreen.as_raw();
        arg_self_
            .interface
            .on_fullscreen_mode_change(arg_browser, arg_fullscreen)
    }
    extern "C" fn on_tooltip<I: ImplDisplayHandler>(
        self_: *mut _cef_display_handler_t,
        browser: *mut _cef_browser_t,
        text: *mut _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_text) = (self_, browser, text);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let mut arg_text = WrapParamRef::<CefStringUtf16>::from(arg_text);
        let arg_text = arg_text.as_mut();
        arg_self_.interface.on_tooltip(arg_browser, arg_text).into()
    }
    extern "C" fn on_status_message<I: ImplDisplayHandler>(
        self_: *mut _cef_display_handler_t,
        browser: *mut _cef_browser_t,
        value: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_browser, arg_value) = (self_, browser, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_value = WrapParamRef::<CefStringUtf16>::from(arg_value);
        let arg_value = arg_value.as_ref();
        arg_self_
            .interface
            .on_status_message(arg_browser, arg_value)
    }
    extern "C" fn on_console_message<I: ImplDisplayHandler>(
        self_: *mut _cef_display_handler_t,
        browser: *mut _cef_browser_t,
        level: cef_log_severity_t,
        message: *const _cef_string_utf16_t,
        source: *const _cef_string_utf16_t,
        line: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_level, arg_message, arg_source, arg_line) =
            (self_, browser, level, message, source, line);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_level = arg_level.as_raw();
        let arg_message = WrapParamRef::<CefStringUtf16>::from(arg_message);
        let arg_message = arg_message.as_ref();
        let arg_source = WrapParamRef::<CefStringUtf16>::from(arg_source);
        let arg_source = arg_source.as_ref();
        let arg_line = arg_line.as_raw();
        arg_self_
            .interface
            .on_console_message(arg_browser, arg_level, arg_message, arg_source, arg_line)
            .into()
    }
    extern "C" fn on_auto_resize<I: ImplDisplayHandler>(
        self_: *mut _cef_display_handler_t,
        browser: *mut _cef_browser_t,
        new_size: *const _cef_size_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_new_size) = (self_, browser, new_size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_new_size = WrapParamRef::<Size>::from(arg_new_size);
        let arg_new_size = arg_new_size.as_ref();
        arg_self_
            .interface
            .on_auto_resize(arg_browser, arg_new_size)
            .into()
    }
    extern "C" fn on_loading_progress_change<I: ImplDisplayHandler>(
        self_: *mut _cef_display_handler_t,
        browser: *mut _cef_browser_t,
        progress: f64,
    ) {
        let (arg_self_, arg_browser, arg_progress) = (self_, browser, progress);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_progress = arg_progress.as_raw();
        arg_self_
            .interface
            .on_loading_progress_change(arg_browser, arg_progress)
    }
    extern "C" fn on_cursor_change<I: ImplDisplayHandler>(
        self_: *mut _cef_display_handler_t,
        browser: *mut _cef_browser_t,
        cursor: ::std::os::raw::c_ulong,
        type_: cef_cursor_type_t,
        custom_cursor_info: *const _cef_cursor_info_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_cursor, arg_type_, arg_custom_cursor_info) =
            (self_, browser, cursor, type_, custom_cursor_info);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_cursor = arg_cursor.as_raw();
        let arg_type_ = arg_type_.as_raw();
        let arg_custom_cursor_info = WrapParamRef::<CursorInfo>::from(arg_custom_cursor_info);
        let arg_custom_cursor_info = arg_custom_cursor_info.as_ref();
        arg_self_
            .interface
            .on_cursor_change(arg_browser, arg_cursor, arg_type_, arg_custom_cursor_info)
            .into()
    }
    extern "C" fn on_media_access_change<I: ImplDisplayHandler>(
        self_: *mut _cef_display_handler_t,
        browser: *mut _cef_browser_t,
        has_video_access: ::std::os::raw::c_int,
        has_audio_access: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_browser, arg_has_video_access, arg_has_audio_access) =
            (self_, browser, has_video_access, has_audio_access);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_has_video_access = arg_has_video_access.as_raw();
        let arg_has_audio_access = arg_has_audio_access.as_raw();
        arg_self_.interface.on_media_access_change(
            arg_browser,
            arg_has_video_access,
            arg_has_audio_access,
        )
    }
}
#[doc = "See [_cef_display_handler_t] for more documentation."]
#[derive(Clone)]
pub struct DisplayHandler(RefGuard<_cef_display_handler_t>);
impl ImplDisplayHandler for DisplayHandler {
    fn on_address_change<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        url: &'a CefStringUtf16,
    ) {
        unsafe {
            self.0
                .on_address_change
                .map(|f| {
                    let (arg_browser, arg_frame, arg_url) = (browser, frame, url);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_frame = arg_frame.as_raw();
                    let arg_url = arg_url.as_raw();
                    let result = f(arg_self_, arg_browser, arg_frame, arg_url);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_title_change<'a>(&self, browser: &'a mut Browser, title: &'a CefStringUtf16) {
        unsafe {
            self.0
                .on_title_change
                .map(|f| {
                    let (arg_browser, arg_title) = (browser, title);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_title = arg_title.as_raw();
                    let result = f(arg_self_, arg_browser, arg_title);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_favicon_urlchange<'a>(&self, browser: &'a mut Browser, icon_urls: &'a mut CefStringList) {
        unsafe {
            self.0
                .on_favicon_urlchange
                .map(|f| {
                    let (arg_browser, arg_icon_urls) = (browser, icon_urls);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_icon_urls = arg_icon_urls.as_raw();
                    let result = f(arg_self_, arg_browser, arg_icon_urls);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_fullscreen_mode_change<'a>(
        &self,
        browser: &'a mut Browser,
        fullscreen: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .on_fullscreen_mode_change
                .map(|f| {
                    let (arg_browser, arg_fullscreen) = (browser, fullscreen);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_fullscreen = arg_fullscreen;
                    let result = f(arg_self_, arg_browser, arg_fullscreen);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_tooltip<'a>(
        &self,
        browser: &'a mut Browser,
        text: &'a mut CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_tooltip
                .map(|f| {
                    let (arg_browser, arg_text) = (browser, text);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_text = arg_text.as_raw();
                    let result = f(arg_self_, arg_browser, arg_text);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_status_message<'a>(&self, browser: &'a mut Browser, value: &'a CefStringUtf16) {
        unsafe {
            self.0
                .on_status_message
                .map(|f| {
                    let (arg_browser, arg_value) = (browser, value);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_value = arg_value.as_raw();
                    let result = f(arg_self_, arg_browser, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_console_message<'a>(
        &self,
        browser: &'a mut Browser,
        level: LogSeverity,
        message: &'a CefStringUtf16,
        source: &'a CefStringUtf16,
        line: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_console_message
                .map(|f| {
                    let (arg_browser, arg_level, arg_message, arg_source, arg_line) =
                        (browser, level, message, source, line);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_level = arg_level.as_raw();
                    let arg_message = arg_message.as_raw();
                    let arg_source = arg_source.as_raw();
                    let arg_line = arg_line;
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_level,
                        arg_message,
                        arg_source,
                        arg_line,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_auto_resize<'a>(
        &self,
        browser: &'a mut Browser,
        new_size: &'a Size,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_auto_resize
                .map(|f| {
                    let (arg_browser, arg_new_size) = (browser, new_size);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let mut arg_new_size: _cef_size_t = arg_new_size.clone().into();
                    let arg_new_size = &mut arg_new_size;
                    let result = f(arg_self_, arg_browser, arg_new_size);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_loading_progress_change<'a>(&self, browser: &'a mut Browser, progress: f64) {
        unsafe {
            self.0
                .on_loading_progress_change
                .map(|f| {
                    let (arg_browser, arg_progress) = (browser, progress);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_progress = arg_progress;
                    let result = f(arg_self_, arg_browser, arg_progress);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_cursor_change<'a>(
        &self,
        browser: &'a mut Browser,
        cursor: ::std::os::raw::c_ulong,
        type_: CursorType,
        custom_cursor_info: &'a CursorInfo,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_cursor_change
                .map(|f| {
                    let (arg_browser, arg_cursor, arg_type_, arg_custom_cursor_info) =
                        (browser, cursor, type_, custom_cursor_info);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_cursor = arg_cursor;
                    let arg_type_ = arg_type_.as_raw();
                    let mut arg_custom_cursor_info: _cef_cursor_info_t =
                        arg_custom_cursor_info.clone().into();
                    let arg_custom_cursor_info = &mut arg_custom_cursor_info;
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_cursor,
                        arg_type_,
                        arg_custom_cursor_info,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_media_access_change<'a>(
        &self,
        browser: &'a mut Browser,
        has_video_access: ::std::os::raw::c_int,
        has_audio_access: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .on_media_access_change
                .map(|f| {
                    let (arg_browser, arg_has_video_access, arg_has_audio_access) =
                        (browser, has_video_access, has_audio_access);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_has_video_access = arg_has_video_access;
                    let arg_has_audio_access = arg_has_audio_access;
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_has_video_access,
                        arg_has_audio_access,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_display_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for DisplayHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_display_handler_t> for &DisplayHandler {
    fn as_raw(self) -> *mut _cef_display_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_display_handler_t> for &mut DisplayHandler {
    fn as_raw(self) -> *mut _cef_display_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<DisplayHandler> for *mut _cef_display_handler_t {
    fn as_wrapper(self) -> DisplayHandler {
        DisplayHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_display_handler_t> for DisplayHandler {
    fn into(self) -> *mut _cef_display_handler_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for DisplayHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplDownloadItem: Sized {
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_in_progress<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_complete<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_canceled<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_interrupted<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_interrupt_reason<'a>(&self) -> DownloadInterruptReason {
        unsafe { std::mem::zeroed() }
    }
    fn get_current_speed<'a>(&self) -> i64 {
        unsafe { std::mem::zeroed() }
    }
    fn get_percent_complete<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_total_bytes<'a>(&self) -> i64 {
        unsafe { std::mem::zeroed() }
    }
    fn get_received_bytes<'a>(&self) -> i64 {
        unsafe { std::mem::zeroed() }
    }
    fn get_start_time<'a>(&self) -> Basetime {
        unsafe { std::mem::zeroed() }
    }
    fn get_end_time<'a>(&self) -> Basetime {
        unsafe { std::mem::zeroed() }
    }
    fn get_full_path<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_id<'a>(&self) -> u32 {
        unsafe { std::mem::zeroed() }
    }
    fn get_url<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_original_url<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_suggested_file_name<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_content_disposition<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_mime_type<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_download_item_t {
        let mut object: _cef_download_item_t = unsafe { std::mem::zeroed() };
        impl_cef_download_item_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_download_item_t {
    use super::*;
    pub fn init_methods<I: ImplDownloadItem>(object: &mut _cef_download_item_t) {
        object.is_valid = Some(is_valid::<I>);
        object.is_in_progress = Some(is_in_progress::<I>);
        object.is_complete = Some(is_complete::<I>);
        object.is_canceled = Some(is_canceled::<I>);
        object.is_interrupted = Some(is_interrupted::<I>);
        object.get_interrupt_reason = Some(get_interrupt_reason::<I>);
        object.get_current_speed = Some(get_current_speed::<I>);
        object.get_percent_complete = Some(get_percent_complete::<I>);
        object.get_total_bytes = Some(get_total_bytes::<I>);
        object.get_received_bytes = Some(get_received_bytes::<I>);
        object.get_start_time = Some(get_start_time::<I>);
        object.get_end_time = Some(get_end_time::<I>);
        object.get_full_path = Some(get_full_path::<I>);
        object.get_id = Some(get_id::<I>);
        object.get_url = Some(get_url::<I>);
        object.get_original_url = Some(get_original_url::<I>);
        object.get_suggested_file_name = Some(get_suggested_file_name::<I>);
        object.get_content_disposition = Some(get_content_disposition::<I>);
        object.get_mime_type = Some(get_mime_type::<I>);
    }
    extern "C" fn is_valid<I: ImplDownloadItem>(
        self_: *mut _cef_download_item_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_valid().into()
    }
    extern "C" fn is_in_progress<I: ImplDownloadItem>(
        self_: *mut _cef_download_item_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_in_progress().into()
    }
    extern "C" fn is_complete<I: ImplDownloadItem>(
        self_: *mut _cef_download_item_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_complete().into()
    }
    extern "C" fn is_canceled<I: ImplDownloadItem>(
        self_: *mut _cef_download_item_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_canceled().into()
    }
    extern "C" fn is_interrupted<I: ImplDownloadItem>(
        self_: *mut _cef_download_item_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_interrupted().into()
    }
    extern "C" fn get_interrupt_reason<I: ImplDownloadItem>(
        self_: *mut _cef_download_item_t,
    ) -> cef_download_interrupt_reason_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_interrupt_reason().into()
    }
    extern "C" fn get_current_speed<I: ImplDownloadItem>(self_: *mut _cef_download_item_t) -> i64 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_current_speed().into()
    }
    extern "C" fn get_percent_complete<I: ImplDownloadItem>(
        self_: *mut _cef_download_item_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_percent_complete().into()
    }
    extern "C" fn get_total_bytes<I: ImplDownloadItem>(self_: *mut _cef_download_item_t) -> i64 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_total_bytes().into()
    }
    extern "C" fn get_received_bytes<I: ImplDownloadItem>(self_: *mut _cef_download_item_t) -> i64 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_received_bytes().into()
    }
    extern "C" fn get_start_time<I: ImplDownloadItem>(
        self_: *mut _cef_download_item_t,
    ) -> _cef_basetime_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_start_time().into()
    }
    extern "C" fn get_end_time<I: ImplDownloadItem>(
        self_: *mut _cef_download_item_t,
    ) -> _cef_basetime_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_end_time().into()
    }
    extern "C" fn get_full_path<I: ImplDownloadItem>(
        self_: *mut _cef_download_item_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_full_path().into()
    }
    extern "C" fn get_id<I: ImplDownloadItem>(self_: *mut _cef_download_item_t) -> u32 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_id().into()
    }
    extern "C" fn get_url<I: ImplDownloadItem>(
        self_: *mut _cef_download_item_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_url().into()
    }
    extern "C" fn get_original_url<I: ImplDownloadItem>(
        self_: *mut _cef_download_item_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_original_url().into()
    }
    extern "C" fn get_suggested_file_name<I: ImplDownloadItem>(
        self_: *mut _cef_download_item_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_suggested_file_name().into()
    }
    extern "C" fn get_content_disposition<I: ImplDownloadItem>(
        self_: *mut _cef_download_item_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_content_disposition().into()
    }
    extern "C" fn get_mime_type<I: ImplDownloadItem>(
        self_: *mut _cef_download_item_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_mime_type().into()
    }
}
#[doc = "See [_cef_download_item_t] for more documentation."]
#[derive(Clone)]
pub struct DownloadItem(RefGuard<_cef_download_item_t>);
impl ImplDownloadItem for DownloadItem {
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_in_progress<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_in_progress
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_complete<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_complete
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_canceled<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_canceled
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_interrupted<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_interrupted
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_interrupt_reason<'a>(&self) -> DownloadInterruptReason {
        unsafe {
            self.0
                .get_interrupt_reason
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_current_speed<'a>(&self) -> i64 {
        unsafe {
            self.0
                .get_current_speed
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_percent_complete<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_percent_complete
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_total_bytes<'a>(&self) -> i64 {
        unsafe {
            self.0
                .get_total_bytes
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_received_bytes<'a>(&self) -> i64 {
        unsafe {
            self.0
                .get_received_bytes
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_start_time<'a>(&self) -> Basetime {
        unsafe {
            self.0
                .get_start_time
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_end_time<'a>(&self) -> Basetime {
        unsafe {
            self.0
                .get_end_time
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_full_path<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_full_path
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_id<'a>(&self) -> u32 {
        unsafe {
            self.0
                .get_id
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_url<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_url
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_original_url<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_original_url
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_suggested_file_name<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_suggested_file_name
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_content_disposition<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_content_disposition
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_mime_type<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_mime_type
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_download_item_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for DownloadItem {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_download_item_t> for &DownloadItem {
    fn as_raw(self) -> *mut _cef_download_item_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_download_item_t> for &mut DownloadItem {
    fn as_raw(self) -> *mut _cef_download_item_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<DownloadItem> for *mut _cef_download_item_t {
    fn as_wrapper(self) -> DownloadItem {
        DownloadItem(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_download_item_t> for DownloadItem {
    fn into(self) -> *mut _cef_download_item_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for DownloadItem {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplBeforeDownloadCallback: Sized {
    fn cont<'a>(&self, download_path: &'a CefStringUtf16, show_dialog: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_before_download_callback_t {
        let mut object: _cef_before_download_callback_t = unsafe { std::mem::zeroed() };
        impl_cef_before_download_callback_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_before_download_callback_t {
    use super::*;
    pub fn init_methods<I: ImplBeforeDownloadCallback>(
        object: &mut _cef_before_download_callback_t,
    ) {
        object.cont = Some(cont::<I>);
    }
    extern "C" fn cont<I: ImplBeforeDownloadCallback>(
        self_: *mut _cef_before_download_callback_t,
        download_path: *const _cef_string_utf16_t,
        show_dialog: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_download_path, arg_show_dialog) = (self_, download_path, show_dialog);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_download_path = WrapParamRef::<CefStringUtf16>::from(arg_download_path);
        let arg_download_path = arg_download_path.as_ref();
        let arg_show_dialog = arg_show_dialog.as_raw();
        arg_self_.interface.cont(arg_download_path, arg_show_dialog)
    }
}
#[doc = "See [_cef_before_download_callback_t] for more documentation."]
#[derive(Clone)]
pub struct BeforeDownloadCallback(RefGuard<_cef_before_download_callback_t>);
impl ImplBeforeDownloadCallback for BeforeDownloadCallback {
    fn cont<'a>(&self, download_path: &'a CefStringUtf16, show_dialog: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .cont
                .map(|f| {
                    let (arg_download_path, arg_show_dialog) = (download_path, show_dialog);
                    let arg_self_ = self.as_raw();
                    let arg_download_path = arg_download_path.as_raw();
                    let arg_show_dialog = arg_show_dialog;
                    let result = f(arg_self_, arg_download_path, arg_show_dialog);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_before_download_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for BeforeDownloadCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_before_download_callback_t> for &BeforeDownloadCallback {
    fn as_raw(self) -> *mut _cef_before_download_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_before_download_callback_t> for &mut BeforeDownloadCallback {
    fn as_raw(self) -> *mut _cef_before_download_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<BeforeDownloadCallback> for *mut _cef_before_download_callback_t {
    fn as_wrapper(self) -> BeforeDownloadCallback {
        BeforeDownloadCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_before_download_callback_t> for BeforeDownloadCallback {
    fn into(self) -> *mut _cef_before_download_callback_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for BeforeDownloadCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplDownloadItemCallback: Sized {
    fn cancel<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn pause<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn resume<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_download_item_callback_t {
        let mut object: _cef_download_item_callback_t = unsafe { std::mem::zeroed() };
        impl_cef_download_item_callback_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_download_item_callback_t {
    use super::*;
    pub fn init_methods<I: ImplDownloadItemCallback>(object: &mut _cef_download_item_callback_t) {
        object.cancel = Some(cancel::<I>);
        object.pause = Some(pause::<I>);
        object.resume = Some(resume::<I>);
    }
    extern "C" fn cancel<I: ImplDownloadItemCallback>(self_: *mut _cef_download_item_callback_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.cancel()
    }
    extern "C" fn pause<I: ImplDownloadItemCallback>(self_: *mut _cef_download_item_callback_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.pause()
    }
    extern "C" fn resume<I: ImplDownloadItemCallback>(self_: *mut _cef_download_item_callback_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.resume()
    }
}
#[doc = "See [_cef_download_item_callback_t] for more documentation."]
#[derive(Clone)]
pub struct DownloadItemCallback(RefGuard<_cef_download_item_callback_t>);
impl ImplDownloadItemCallback for DownloadItemCallback {
    fn cancel<'a>(&self) {
        unsafe {
            self.0
                .cancel
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn pause<'a>(&self) {
        unsafe {
            self.0
                .pause
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn resume<'a>(&self) {
        unsafe {
            self.0
                .resume
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_download_item_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for DownloadItemCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_download_item_callback_t> for &DownloadItemCallback {
    fn as_raw(self) -> *mut _cef_download_item_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_download_item_callback_t> for &mut DownloadItemCallback {
    fn as_raw(self) -> *mut _cef_download_item_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<DownloadItemCallback> for *mut _cef_download_item_callback_t {
    fn as_wrapper(self) -> DownloadItemCallback {
        DownloadItemCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_download_item_callback_t> for DownloadItemCallback {
    fn into(self) -> *mut _cef_download_item_callback_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for DownloadItemCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplDownloadHandler: Sized {
    fn can_download<'a>(
        &self,
        browser: &'a mut Browser,
        url: &'a CefStringUtf16,
        request_method: &'a CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn on_before_download<'a>(
        &self,
        browser: &'a mut Browser,
        download_item: &'a mut DownloadItem,
        suggested_name: &'a CefStringUtf16,
        callback: &'a mut BeforeDownloadCallback,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn on_download_updated<'a>(
        &self,
        browser: &'a mut Browser,
        download_item: &'a mut DownloadItem,
        callback: &'a mut DownloadItemCallback,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_download_handler_t {
        let mut object: _cef_download_handler_t = unsafe { std::mem::zeroed() };
        impl_cef_download_handler_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_download_handler_t {
    use super::*;
    pub fn init_methods<I: ImplDownloadHandler>(object: &mut _cef_download_handler_t) {
        object.can_download = Some(can_download::<I>);
        object.on_before_download = Some(on_before_download::<I>);
        object.on_download_updated = Some(on_download_updated::<I>);
    }
    extern "C" fn can_download<I: ImplDownloadHandler>(
        self_: *mut _cef_download_handler_t,
        browser: *mut _cef_browser_t,
        url: *const _cef_string_utf16_t,
        request_method: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_url, arg_request_method) =
            (self_, browser, url, request_method);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_url = WrapParamRef::<CefStringUtf16>::from(arg_url);
        let arg_url = arg_url.as_ref();
        let arg_request_method = WrapParamRef::<CefStringUtf16>::from(arg_request_method);
        let arg_request_method = arg_request_method.as_ref();
        arg_self_
            .interface
            .can_download(arg_browser, arg_url, arg_request_method)
            .into()
    }
    extern "C" fn on_before_download<I: ImplDownloadHandler>(
        self_: *mut _cef_download_handler_t,
        browser: *mut _cef_browser_t,
        download_item: *mut _cef_download_item_t,
        suggested_name: *const _cef_string_utf16_t,
        callback: *mut _cef_before_download_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_download_item, arg_suggested_name, arg_callback) =
            (self_, browser, download_item, suggested_name, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_download_item =
            &mut DownloadItem(unsafe { RefGuard::from_raw_add_ref(arg_download_item) });
        let arg_suggested_name = WrapParamRef::<CefStringUtf16>::from(arg_suggested_name);
        let arg_suggested_name = arg_suggested_name.as_ref();
        let arg_callback =
            &mut BeforeDownloadCallback(unsafe { RefGuard::from_raw_add_ref(arg_callback) });
        arg_self_
            .interface
            .on_before_download(
                arg_browser,
                arg_download_item,
                arg_suggested_name,
                arg_callback,
            )
            .into()
    }
    extern "C" fn on_download_updated<I: ImplDownloadHandler>(
        self_: *mut _cef_download_handler_t,
        browser: *mut _cef_browser_t,
        download_item: *mut _cef_download_item_t,
        callback: *mut _cef_download_item_callback_t,
    ) {
        let (arg_self_, arg_browser, arg_download_item, arg_callback) =
            (self_, browser, download_item, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_download_item =
            &mut DownloadItem(unsafe { RefGuard::from_raw_add_ref(arg_download_item) });
        let arg_callback =
            &mut DownloadItemCallback(unsafe { RefGuard::from_raw_add_ref(arg_callback) });
        arg_self_
            .interface
            .on_download_updated(arg_browser, arg_download_item, arg_callback)
    }
}
#[doc = "See [_cef_download_handler_t] for more documentation."]
#[derive(Clone)]
pub struct DownloadHandler(RefGuard<_cef_download_handler_t>);
impl ImplDownloadHandler for DownloadHandler {
    fn can_download<'a>(
        &self,
        browser: &'a mut Browser,
        url: &'a CefStringUtf16,
        request_method: &'a CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .can_download
                .map(|f| {
                    let (arg_browser, arg_url, arg_request_method) = (browser, url, request_method);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_url = arg_url.as_raw();
                    let arg_request_method = arg_request_method.as_raw();
                    let result = f(arg_self_, arg_browser, arg_url, arg_request_method);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_before_download<'a>(
        &self,
        browser: &'a mut Browser,
        download_item: &'a mut DownloadItem,
        suggested_name: &'a CefStringUtf16,
        callback: &'a mut BeforeDownloadCallback,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_before_download
                .map(|f| {
                    let (arg_browser, arg_download_item, arg_suggested_name, arg_callback) =
                        (browser, download_item, suggested_name, callback);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_download_item = arg_download_item.as_raw();
                    let arg_suggested_name = arg_suggested_name.as_raw();
                    let arg_callback = arg_callback.as_raw();
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_download_item,
                        arg_suggested_name,
                        arg_callback,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_download_updated<'a>(
        &self,
        browser: &'a mut Browser,
        download_item: &'a mut DownloadItem,
        callback: &'a mut DownloadItemCallback,
    ) {
        unsafe {
            self.0
                .on_download_updated
                .map(|f| {
                    let (arg_browser, arg_download_item, arg_callback) =
                        (browser, download_item, callback);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_download_item = arg_download_item.as_raw();
                    let arg_callback = arg_callback.as_raw();
                    let result = f(arg_self_, arg_browser, arg_download_item, arg_callback);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_download_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for DownloadHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_download_handler_t> for &DownloadHandler {
    fn as_raw(self) -> *mut _cef_download_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_download_handler_t> for &mut DownloadHandler {
    fn as_raw(self) -> *mut _cef_download_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<DownloadHandler> for *mut _cef_download_handler_t {
    fn as_wrapper(self) -> DownloadHandler {
        DownloadHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_download_handler_t> for DownloadHandler {
    fn into(self) -> *mut _cef_download_handler_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for DownloadHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplDragHandler: Sized {
    fn on_drag_enter<'a>(
        &self,
        browser: &'a mut Browser,
        drag_data: &'a mut DragData,
        mask: DragOperationsMask,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn on_draggable_regions_changed<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        regions_count: usize,
        regions: &'a DraggableRegion,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_drag_handler_t {
        let mut object: _cef_drag_handler_t = unsafe { std::mem::zeroed() };
        impl_cef_drag_handler_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_drag_handler_t {
    use super::*;
    pub fn init_methods<I: ImplDragHandler>(object: &mut _cef_drag_handler_t) {
        object.on_drag_enter = Some(on_drag_enter::<I>);
        object.on_draggable_regions_changed = Some(on_draggable_regions_changed::<I>);
    }
    extern "C" fn on_drag_enter<I: ImplDragHandler>(
        self_: *mut _cef_drag_handler_t,
        browser: *mut _cef_browser_t,
        drag_data: *mut _cef_drag_data_t,
        mask: cef_drag_operations_mask_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_drag_data, arg_mask) = (self_, browser, drag_data, mask);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_drag_data = &mut DragData(unsafe { RefGuard::from_raw_add_ref(arg_drag_data) });
        let arg_mask = arg_mask.as_raw();
        arg_self_
            .interface
            .on_drag_enter(arg_browser, arg_drag_data, arg_mask)
            .into()
    }
    extern "C" fn on_draggable_regions_changed<I: ImplDragHandler>(
        self_: *mut _cef_drag_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        regions_count: usize,
        regions: *const _cef_draggable_region_t,
    ) {
        let (arg_self_, arg_browser, arg_frame, arg_regions_count, arg_regions) =
            (self_, browser, frame, regions_count, regions);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_frame) });
        let arg_regions_count = arg_regions_count.as_raw();
        let arg_regions = WrapParamRef::<DraggableRegion>::from(arg_regions);
        let arg_regions = arg_regions.as_ref();
        arg_self_.interface.on_draggable_regions_changed(
            arg_browser,
            arg_frame,
            arg_regions_count,
            arg_regions,
        )
    }
}
#[doc = "See [_cef_drag_handler_t] for more documentation."]
#[derive(Clone)]
pub struct DragHandler(RefGuard<_cef_drag_handler_t>);
impl ImplDragHandler for DragHandler {
    fn on_drag_enter<'a>(
        &self,
        browser: &'a mut Browser,
        drag_data: &'a mut DragData,
        mask: DragOperationsMask,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_drag_enter
                .map(|f| {
                    let (arg_browser, arg_drag_data, arg_mask) = (browser, drag_data, mask);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_drag_data = arg_drag_data.as_raw();
                    let arg_mask = arg_mask.as_raw();
                    let result = f(arg_self_, arg_browser, arg_drag_data, arg_mask);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_draggable_regions_changed<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        regions_count: usize,
        regions: &'a DraggableRegion,
    ) {
        unsafe {
            self.0
                .on_draggable_regions_changed
                .map(|f| {
                    let (arg_browser, arg_frame, arg_regions_count, arg_regions) =
                        (browser, frame, regions_count, regions);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_frame = arg_frame.as_raw();
                    let arg_regions_count = arg_regions_count;
                    let mut arg_regions: _cef_draggable_region_t = arg_regions.clone().into();
                    let arg_regions = &mut arg_regions;
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_regions_count,
                        arg_regions,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_drag_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for DragHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_drag_handler_t> for &DragHandler {
    fn as_raw(self) -> *mut _cef_drag_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_drag_handler_t> for &mut DragHandler {
    fn as_raw(self) -> *mut _cef_drag_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<DragHandler> for *mut _cef_drag_handler_t {
    fn as_wrapper(self) -> DragHandler {
        DragHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_drag_handler_t> for DragHandler {
    fn into(self) -> *mut _cef_drag_handler_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for DragHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplFindHandler: Sized {
    fn on_find_result<'a>(
        &self,
        browser: &'a mut Browser,
        identifier: ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
        selection_rect: &'a Rect,
        active_match_ordinal: ::std::os::raw::c_int,
        final_update: ::std::os::raw::c_int,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_find_handler_t {
        let mut object: _cef_find_handler_t = unsafe { std::mem::zeroed() };
        impl_cef_find_handler_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_find_handler_t {
    use super::*;
    pub fn init_methods<I: ImplFindHandler>(object: &mut _cef_find_handler_t) {
        object.on_find_result = Some(on_find_result::<I>);
    }
    extern "C" fn on_find_result<I: ImplFindHandler>(
        self_: *mut _cef_find_handler_t,
        browser: *mut _cef_browser_t,
        identifier: ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
        selection_rect: *const _cef_rect_t,
        active_match_ordinal: ::std::os::raw::c_int,
        final_update: ::std::os::raw::c_int,
    ) {
        let (
            arg_self_,
            arg_browser,
            arg_identifier,
            arg_count,
            arg_selection_rect,
            arg_active_match_ordinal,
            arg_final_update,
        ) = (
            self_,
            browser,
            identifier,
            count,
            selection_rect,
            active_match_ordinal,
            final_update,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_identifier = arg_identifier.as_raw();
        let arg_count = arg_count.as_raw();
        let arg_selection_rect = WrapParamRef::<Rect>::from(arg_selection_rect);
        let arg_selection_rect = arg_selection_rect.as_ref();
        let arg_active_match_ordinal = arg_active_match_ordinal.as_raw();
        let arg_final_update = arg_final_update.as_raw();
        arg_self_.interface.on_find_result(
            arg_browser,
            arg_identifier,
            arg_count,
            arg_selection_rect,
            arg_active_match_ordinal,
            arg_final_update,
        )
    }
}
#[doc = "See [_cef_find_handler_t] for more documentation."]
#[derive(Clone)]
pub struct FindHandler(RefGuard<_cef_find_handler_t>);
impl ImplFindHandler for FindHandler {
    fn on_find_result<'a>(
        &self,
        browser: &'a mut Browser,
        identifier: ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
        selection_rect: &'a Rect,
        active_match_ordinal: ::std::os::raw::c_int,
        final_update: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .on_find_result
                .map(|f| {
                    let (
                        arg_browser,
                        arg_identifier,
                        arg_count,
                        arg_selection_rect,
                        arg_active_match_ordinal,
                        arg_final_update,
                    ) = (
                        browser,
                        identifier,
                        count,
                        selection_rect,
                        active_match_ordinal,
                        final_update,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_identifier = arg_identifier;
                    let arg_count = arg_count;
                    let mut arg_selection_rect: _cef_rect_t = arg_selection_rect.clone().into();
                    let arg_selection_rect = &mut arg_selection_rect;
                    let arg_active_match_ordinal = arg_active_match_ordinal;
                    let arg_final_update = arg_final_update;
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_identifier,
                        arg_count,
                        arg_selection_rect,
                        arg_active_match_ordinal,
                        arg_final_update,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_find_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for FindHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_find_handler_t> for &FindHandler {
    fn as_raw(self) -> *mut _cef_find_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_find_handler_t> for &mut FindHandler {
    fn as_raw(self) -> *mut _cef_find_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<FindHandler> for *mut _cef_find_handler_t {
    fn as_wrapper(self) -> FindHandler {
        FindHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_find_handler_t> for FindHandler {
    fn into(self) -> *mut _cef_find_handler_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for FindHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplFocusHandler: Sized {
    fn on_take_focus<'a>(&self, browser: &'a mut Browser, next: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn on_set_focus<'a>(
        &self,
        browser: &'a mut Browser,
        source: FocusSource,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn on_got_focus<'a>(&self, browser: &'a mut Browser) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_focus_handler_t {
        let mut object: _cef_focus_handler_t = unsafe { std::mem::zeroed() };
        impl_cef_focus_handler_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_focus_handler_t {
    use super::*;
    pub fn init_methods<I: ImplFocusHandler>(object: &mut _cef_focus_handler_t) {
        object.on_take_focus = Some(on_take_focus::<I>);
        object.on_set_focus = Some(on_set_focus::<I>);
        object.on_got_focus = Some(on_got_focus::<I>);
    }
    extern "C" fn on_take_focus<I: ImplFocusHandler>(
        self_: *mut _cef_focus_handler_t,
        browser: *mut _cef_browser_t,
        next: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_browser, arg_next) = (self_, browser, next);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_next = arg_next.as_raw();
        arg_self_.interface.on_take_focus(arg_browser, arg_next)
    }
    extern "C" fn on_set_focus<I: ImplFocusHandler>(
        self_: *mut _cef_focus_handler_t,
        browser: *mut _cef_browser_t,
        source: cef_focus_source_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_source) = (self_, browser, source);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_source = arg_source.as_raw();
        arg_self_
            .interface
            .on_set_focus(arg_browser, arg_source)
            .into()
    }
    extern "C" fn on_got_focus<I: ImplFocusHandler>(
        self_: *mut _cef_focus_handler_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        arg_self_.interface.on_got_focus(arg_browser)
    }
}
#[doc = "See [_cef_focus_handler_t] for more documentation."]
#[derive(Clone)]
pub struct FocusHandler(RefGuard<_cef_focus_handler_t>);
impl ImplFocusHandler for FocusHandler {
    fn on_take_focus<'a>(&self, browser: &'a mut Browser, next: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .on_take_focus
                .map(|f| {
                    let (arg_browser, arg_next) = (browser, next);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_next = arg_next;
                    let result = f(arg_self_, arg_browser, arg_next);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_set_focus<'a>(
        &self,
        browser: &'a mut Browser,
        source: FocusSource,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_set_focus
                .map(|f| {
                    let (arg_browser, arg_source) = (browser, source);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_source = arg_source.as_raw();
                    let result = f(arg_self_, arg_browser, arg_source);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_got_focus<'a>(&self, browser: &'a mut Browser) {
        unsafe {
            self.0
                .on_got_focus
                .map(|f| {
                    let arg_browser = browser;
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let result = f(arg_self_, arg_browser);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_focus_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for FocusHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_focus_handler_t> for &FocusHandler {
    fn as_raw(self) -> *mut _cef_focus_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_focus_handler_t> for &mut FocusHandler {
    fn as_raw(self) -> *mut _cef_focus_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<FocusHandler> for *mut _cef_focus_handler_t {
    fn as_wrapper(self) -> FocusHandler {
        FocusHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_focus_handler_t> for FocusHandler {
    fn into(self) -> *mut _cef_focus_handler_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for FocusHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplFrameHandler: Sized {
    fn on_frame_created<'a>(&self, browser: &'a mut Browser, frame: &'a mut Frame) {
        unsafe { std::mem::zeroed() }
    }
    fn on_frame_destroyed<'a>(&self, browser: &'a mut Browser, frame: &'a mut Frame) {
        unsafe { std::mem::zeroed() }
    }
    fn on_frame_attached<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        reattached: ::std::os::raw::c_int,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn on_frame_detached<'a>(&self, browser: &'a mut Browser, frame: &'a mut Frame) {
        unsafe { std::mem::zeroed() }
    }
    fn on_main_frame_changed<'a>(
        &self,
        browser: &'a mut Browser,
        old_frame: &'a mut Frame,
        new_frame: &'a mut Frame,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_frame_handler_t {
        let mut object: _cef_frame_handler_t = unsafe { std::mem::zeroed() };
        impl_cef_frame_handler_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_frame_handler_t {
    use super::*;
    pub fn init_methods<I: ImplFrameHandler>(object: &mut _cef_frame_handler_t) {
        object.on_frame_created = Some(on_frame_created::<I>);
        object.on_frame_destroyed = Some(on_frame_destroyed::<I>);
        object.on_frame_attached = Some(on_frame_attached::<I>);
        object.on_frame_detached = Some(on_frame_detached::<I>);
        object.on_main_frame_changed = Some(on_main_frame_changed::<I>);
    }
    extern "C" fn on_frame_created<I: ImplFrameHandler>(
        self_: *mut _cef_frame_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
    ) {
        let (arg_self_, arg_browser, arg_frame) = (self_, browser, frame);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_frame) });
        arg_self_.interface.on_frame_created(arg_browser, arg_frame)
    }
    extern "C" fn on_frame_destroyed<I: ImplFrameHandler>(
        self_: *mut _cef_frame_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
    ) {
        let (arg_self_, arg_browser, arg_frame) = (self_, browser, frame);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_frame) });
        arg_self_
            .interface
            .on_frame_destroyed(arg_browser, arg_frame)
    }
    extern "C" fn on_frame_attached<I: ImplFrameHandler>(
        self_: *mut _cef_frame_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        reattached: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_browser, arg_frame, arg_reattached) =
            (self_, browser, frame, reattached);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_frame) });
        let arg_reattached = arg_reattached.as_raw();
        arg_self_
            .interface
            .on_frame_attached(arg_browser, arg_frame, arg_reattached)
    }
    extern "C" fn on_frame_detached<I: ImplFrameHandler>(
        self_: *mut _cef_frame_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
    ) {
        let (arg_self_, arg_browser, arg_frame) = (self_, browser, frame);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_frame) });
        arg_self_
            .interface
            .on_frame_detached(arg_browser, arg_frame)
    }
    extern "C" fn on_main_frame_changed<I: ImplFrameHandler>(
        self_: *mut _cef_frame_handler_t,
        browser: *mut _cef_browser_t,
        old_frame: *mut _cef_frame_t,
        new_frame: *mut _cef_frame_t,
    ) {
        let (arg_self_, arg_browser, arg_old_frame, arg_new_frame) =
            (self_, browser, old_frame, new_frame);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_old_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_old_frame) });
        let arg_new_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_new_frame) });
        arg_self_
            .interface
            .on_main_frame_changed(arg_browser, arg_old_frame, arg_new_frame)
    }
}
#[doc = "See [_cef_frame_handler_t] for more documentation."]
#[derive(Clone)]
pub struct FrameHandler(RefGuard<_cef_frame_handler_t>);
impl ImplFrameHandler for FrameHandler {
    fn on_frame_created<'a>(&self, browser: &'a mut Browser, frame: &'a mut Frame) {
        unsafe {
            self.0
                .on_frame_created
                .map(|f| {
                    let (arg_browser, arg_frame) = (browser, frame);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_frame = arg_frame.as_raw();
                    let result = f(arg_self_, arg_browser, arg_frame);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_frame_destroyed<'a>(&self, browser: &'a mut Browser, frame: &'a mut Frame) {
        unsafe {
            self.0
                .on_frame_destroyed
                .map(|f| {
                    let (arg_browser, arg_frame) = (browser, frame);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_frame = arg_frame.as_raw();
                    let result = f(arg_self_, arg_browser, arg_frame);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_frame_attached<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        reattached: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .on_frame_attached
                .map(|f| {
                    let (arg_browser, arg_frame, arg_reattached) = (browser, frame, reattached);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_frame = arg_frame.as_raw();
                    let arg_reattached = arg_reattached;
                    let result = f(arg_self_, arg_browser, arg_frame, arg_reattached);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_frame_detached<'a>(&self, browser: &'a mut Browser, frame: &'a mut Frame) {
        unsafe {
            self.0
                .on_frame_detached
                .map(|f| {
                    let (arg_browser, arg_frame) = (browser, frame);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_frame = arg_frame.as_raw();
                    let result = f(arg_self_, arg_browser, arg_frame);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_main_frame_changed<'a>(
        &self,
        browser: &'a mut Browser,
        old_frame: &'a mut Frame,
        new_frame: &'a mut Frame,
    ) {
        unsafe {
            self.0
                .on_main_frame_changed
                .map(|f| {
                    let (arg_browser, arg_old_frame, arg_new_frame) =
                        (browser, old_frame, new_frame);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_old_frame = arg_old_frame.as_raw();
                    let arg_new_frame = arg_new_frame.as_raw();
                    let result = f(arg_self_, arg_browser, arg_old_frame, arg_new_frame);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_frame_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for FrameHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_frame_handler_t> for &FrameHandler {
    fn as_raw(self) -> *mut _cef_frame_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_frame_handler_t> for &mut FrameHandler {
    fn as_raw(self) -> *mut _cef_frame_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<FrameHandler> for *mut _cef_frame_handler_t {
    fn as_wrapper(self) -> FrameHandler {
        FrameHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_frame_handler_t> for FrameHandler {
    fn into(self) -> *mut _cef_frame_handler_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for FrameHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplJsdialogCallback: Sized {
    fn cont<'a>(&self, success: ::std::os::raw::c_int, user_input: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_jsdialog_callback_t {
        let mut object: _cef_jsdialog_callback_t = unsafe { std::mem::zeroed() };
        impl_cef_jsdialog_callback_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_jsdialog_callback_t {
    use super::*;
    pub fn init_methods<I: ImplJsdialogCallback>(object: &mut _cef_jsdialog_callback_t) {
        object.cont = Some(cont::<I>);
    }
    extern "C" fn cont<I: ImplJsdialogCallback>(
        self_: *mut _cef_jsdialog_callback_t,
        success: ::std::os::raw::c_int,
        user_input: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_success, arg_user_input) = (self_, success, user_input);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_success = arg_success.as_raw();
        let arg_user_input = WrapParamRef::<CefStringUtf16>::from(arg_user_input);
        let arg_user_input = arg_user_input.as_ref();
        arg_self_.interface.cont(arg_success, arg_user_input)
    }
}
#[doc = "See [_cef_jsdialog_callback_t] for more documentation."]
#[derive(Clone)]
pub struct JsdialogCallback(RefGuard<_cef_jsdialog_callback_t>);
impl ImplJsdialogCallback for JsdialogCallback {
    fn cont<'a>(&self, success: ::std::os::raw::c_int, user_input: &'a CefStringUtf16) {
        unsafe {
            self.0
                .cont
                .map(|f| {
                    let (arg_success, arg_user_input) = (success, user_input);
                    let arg_self_ = self.as_raw();
                    let arg_success = arg_success;
                    let arg_user_input = arg_user_input.as_raw();
                    let result = f(arg_self_, arg_success, arg_user_input);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_jsdialog_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for JsdialogCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_jsdialog_callback_t> for &JsdialogCallback {
    fn as_raw(self) -> *mut _cef_jsdialog_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_jsdialog_callback_t> for &mut JsdialogCallback {
    fn as_raw(self) -> *mut _cef_jsdialog_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<JsdialogCallback> for *mut _cef_jsdialog_callback_t {
    fn as_wrapper(self) -> JsdialogCallback {
        JsdialogCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_jsdialog_callback_t> for JsdialogCallback {
    fn into(self) -> *mut _cef_jsdialog_callback_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for JsdialogCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplJsdialogHandler: Sized {
    fn on_jsdialog<'a>(
        &self,
        browser: &'a mut Browser,
        origin_url: &'a CefStringUtf16,
        dialog_type: JsdialogType,
        message_text: &'a CefStringUtf16,
        default_prompt_text: &'a CefStringUtf16,
        callback: &'a mut JsdialogCallback,
        suppress_message: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn on_before_unload_dialog<'a>(
        &self,
        browser: &'a mut Browser,
        message_text: &'a CefStringUtf16,
        is_reload: ::std::os::raw::c_int,
        callback: &'a mut JsdialogCallback,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn on_reset_dialog_state<'a>(&self, browser: &'a mut Browser) {
        unsafe { std::mem::zeroed() }
    }
    fn on_dialog_closed<'a>(&self, browser: &'a mut Browser) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_jsdialog_handler_t {
        let mut object: _cef_jsdialog_handler_t = unsafe { std::mem::zeroed() };
        impl_cef_jsdialog_handler_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_jsdialog_handler_t {
    use super::*;
    pub fn init_methods<I: ImplJsdialogHandler>(object: &mut _cef_jsdialog_handler_t) {
        object.on_jsdialog = Some(on_jsdialog::<I>);
        object.on_before_unload_dialog = Some(on_before_unload_dialog::<I>);
        object.on_reset_dialog_state = Some(on_reset_dialog_state::<I>);
        object.on_dialog_closed = Some(on_dialog_closed::<I>);
    }
    extern "C" fn on_jsdialog<I: ImplJsdialogHandler>(
        self_: *mut _cef_jsdialog_handler_t,
        browser: *mut _cef_browser_t,
        origin_url: *const _cef_string_utf16_t,
        dialog_type: cef_jsdialog_type_t,
        message_text: *const _cef_string_utf16_t,
        default_prompt_text: *const _cef_string_utf16_t,
        callback: *mut _cef_jsdialog_callback_t,
        suppress_message: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_browser,
            arg_origin_url,
            arg_dialog_type,
            arg_message_text,
            arg_default_prompt_text,
            arg_callback,
            arg_suppress_message,
        ) = (
            self_,
            browser,
            origin_url,
            dialog_type,
            message_text,
            default_prompt_text,
            callback,
            suppress_message,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_origin_url = WrapParamRef::<CefStringUtf16>::from(arg_origin_url);
        let arg_origin_url = arg_origin_url.as_ref();
        let arg_dialog_type = arg_dialog_type.as_raw();
        let arg_message_text = WrapParamRef::<CefStringUtf16>::from(arg_message_text);
        let arg_message_text = arg_message_text.as_ref();
        let arg_default_prompt_text = WrapParamRef::<CefStringUtf16>::from(arg_default_prompt_text);
        let arg_default_prompt_text = arg_default_prompt_text.as_ref();
        let arg_callback =
            &mut JsdialogCallback(unsafe { RefGuard::from_raw_add_ref(arg_callback) });
        let mut arg_suppress_message =
            WrapParamRef::<::std::os::raw::c_int>::from(arg_suppress_message);
        let arg_suppress_message = arg_suppress_message.as_mut();
        arg_self_
            .interface
            .on_jsdialog(
                arg_browser,
                arg_origin_url,
                arg_dialog_type,
                arg_message_text,
                arg_default_prompt_text,
                arg_callback,
                arg_suppress_message,
            )
            .into()
    }
    extern "C" fn on_before_unload_dialog<I: ImplJsdialogHandler>(
        self_: *mut _cef_jsdialog_handler_t,
        browser: *mut _cef_browser_t,
        message_text: *const _cef_string_utf16_t,
        is_reload: ::std::os::raw::c_int,
        callback: *mut _cef_jsdialog_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_message_text, arg_is_reload, arg_callback) =
            (self_, browser, message_text, is_reload, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_message_text = WrapParamRef::<CefStringUtf16>::from(arg_message_text);
        let arg_message_text = arg_message_text.as_ref();
        let arg_is_reload = arg_is_reload.as_raw();
        let arg_callback =
            &mut JsdialogCallback(unsafe { RefGuard::from_raw_add_ref(arg_callback) });
        arg_self_
            .interface
            .on_before_unload_dialog(arg_browser, arg_message_text, arg_is_reload, arg_callback)
            .into()
    }
    extern "C" fn on_reset_dialog_state<I: ImplJsdialogHandler>(
        self_: *mut _cef_jsdialog_handler_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        arg_self_.interface.on_reset_dialog_state(arg_browser)
    }
    extern "C" fn on_dialog_closed<I: ImplJsdialogHandler>(
        self_: *mut _cef_jsdialog_handler_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        arg_self_.interface.on_dialog_closed(arg_browser)
    }
}
#[doc = "See [_cef_jsdialog_handler_t] for more documentation."]
#[derive(Clone)]
pub struct JsdialogHandler(RefGuard<_cef_jsdialog_handler_t>);
impl ImplJsdialogHandler for JsdialogHandler {
    fn on_jsdialog<'a>(
        &self,
        browser: &'a mut Browser,
        origin_url: &'a CefStringUtf16,
        dialog_type: JsdialogType,
        message_text: &'a CefStringUtf16,
        default_prompt_text: &'a CefStringUtf16,
        callback: &'a mut JsdialogCallback,
        suppress_message: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_jsdialog
                .map(|f| {
                    let (
                        arg_browser,
                        arg_origin_url,
                        arg_dialog_type,
                        arg_message_text,
                        arg_default_prompt_text,
                        arg_callback,
                        arg_suppress_message,
                    ) = (
                        browser,
                        origin_url,
                        dialog_type,
                        message_text,
                        default_prompt_text,
                        callback,
                        suppress_message,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_origin_url = arg_origin_url.as_raw();
                    let arg_dialog_type = arg_dialog_type.as_raw();
                    let arg_message_text = arg_message_text.as_raw();
                    let arg_default_prompt_text = arg_default_prompt_text.as_raw();
                    let arg_callback = arg_callback.as_raw();
                    let arg_suppress_message = arg_suppress_message as *mut _;
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_origin_url,
                        arg_dialog_type,
                        arg_message_text,
                        arg_default_prompt_text,
                        arg_callback,
                        arg_suppress_message,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_before_unload_dialog<'a>(
        &self,
        browser: &'a mut Browser,
        message_text: &'a CefStringUtf16,
        is_reload: ::std::os::raw::c_int,
        callback: &'a mut JsdialogCallback,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_before_unload_dialog
                .map(|f| {
                    let (arg_browser, arg_message_text, arg_is_reload, arg_callback) =
                        (browser, message_text, is_reload, callback);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_message_text = arg_message_text.as_raw();
                    let arg_is_reload = arg_is_reload;
                    let arg_callback = arg_callback.as_raw();
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_message_text,
                        arg_is_reload,
                        arg_callback,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_reset_dialog_state<'a>(&self, browser: &'a mut Browser) {
        unsafe {
            self.0
                .on_reset_dialog_state
                .map(|f| {
                    let arg_browser = browser;
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let result = f(arg_self_, arg_browser);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_dialog_closed<'a>(&self, browser: &'a mut Browser) {
        unsafe {
            self.0
                .on_dialog_closed
                .map(|f| {
                    let arg_browser = browser;
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let result = f(arg_self_, arg_browser);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_jsdialog_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for JsdialogHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_jsdialog_handler_t> for &JsdialogHandler {
    fn as_raw(self) -> *mut _cef_jsdialog_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_jsdialog_handler_t> for &mut JsdialogHandler {
    fn as_raw(self) -> *mut _cef_jsdialog_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<JsdialogHandler> for *mut _cef_jsdialog_handler_t {
    fn as_wrapper(self) -> JsdialogHandler {
        JsdialogHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_jsdialog_handler_t> for JsdialogHandler {
    fn into(self) -> *mut _cef_jsdialog_handler_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for JsdialogHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplKeyboardHandler: Sized {
    fn on_pre_key_event<'a>(
        &self,
        browser: &'a mut Browser,
        event: &'a KeyEvent,
        os_event: *mut XEvent,
        is_keyboard_shortcut: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn on_key_event<'a>(
        &self,
        browser: &'a mut Browser,
        event: &'a KeyEvent,
        os_event: *mut XEvent,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_keyboard_handler_t {
        let mut object: _cef_keyboard_handler_t = unsafe { std::mem::zeroed() };
        impl_cef_keyboard_handler_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_keyboard_handler_t {
    use super::*;
    pub fn init_methods<I: ImplKeyboardHandler>(object: &mut _cef_keyboard_handler_t) {
        object.on_pre_key_event = Some(on_pre_key_event::<I>);
        object.on_key_event = Some(on_key_event::<I>);
    }
    extern "C" fn on_pre_key_event<I: ImplKeyboardHandler>(
        self_: *mut _cef_keyboard_handler_t,
        browser: *mut _cef_browser_t,
        event: *const _cef_key_event_t,
        os_event: *mut XEvent,
        is_keyboard_shortcut: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_event, arg_os_event, arg_is_keyboard_shortcut) =
            (self_, browser, event, os_event, is_keyboard_shortcut);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_event = WrapParamRef::<KeyEvent>::from(arg_event);
        let arg_event = arg_event.as_ref();
        let mut arg_os_event = WrapParamRef::<XEvent>::from(arg_os_event);
        let arg_os_event = arg_os_event.as_mut();
        let mut arg_is_keyboard_shortcut =
            WrapParamRef::<::std::os::raw::c_int>::from(arg_is_keyboard_shortcut);
        let arg_is_keyboard_shortcut = arg_is_keyboard_shortcut.as_mut();
        arg_self_
            .interface
            .on_pre_key_event(
                arg_browser,
                arg_event,
                arg_os_event,
                arg_is_keyboard_shortcut,
            )
            .into()
    }
    extern "C" fn on_key_event<I: ImplKeyboardHandler>(
        self_: *mut _cef_keyboard_handler_t,
        browser: *mut _cef_browser_t,
        event: *const _cef_key_event_t,
        os_event: *mut XEvent,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_event, arg_os_event) = (self_, browser, event, os_event);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_event = WrapParamRef::<KeyEvent>::from(arg_event);
        let arg_event = arg_event.as_ref();
        let mut arg_os_event = WrapParamRef::<XEvent>::from(arg_os_event);
        let arg_os_event = arg_os_event.as_mut();
        arg_self_
            .interface
            .on_key_event(arg_browser, arg_event, arg_os_event)
            .into()
    }
}
#[doc = "See [_cef_keyboard_handler_t] for more documentation."]
#[derive(Clone)]
pub struct KeyboardHandler(RefGuard<_cef_keyboard_handler_t>);
impl ImplKeyboardHandler for KeyboardHandler {
    fn on_pre_key_event<'a>(
        &self,
        browser: &'a mut Browser,
        event: &'a KeyEvent,
        os_event: *mut XEvent,
        is_keyboard_shortcut: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_pre_key_event
                .map(|f| {
                    let (arg_browser, arg_event, arg_os_event, arg_is_keyboard_shortcut) =
                        (browser, event, os_event, is_keyboard_shortcut);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let mut arg_event: _cef_key_event_t = arg_event.clone().into();
                    let arg_event = &mut arg_event;
                    let arg_os_event = arg_os_event as *mut _;
                    let arg_is_keyboard_shortcut = arg_is_keyboard_shortcut as *mut _;
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_event,
                        arg_os_event,
                        arg_is_keyboard_shortcut,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_key_event<'a>(
        &self,
        browser: &'a mut Browser,
        event: &'a KeyEvent,
        os_event: *mut XEvent,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_key_event
                .map(|f| {
                    let (arg_browser, arg_event, arg_os_event) = (browser, event, os_event);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let mut arg_event: _cef_key_event_t = arg_event.clone().into();
                    let arg_event = &mut arg_event;
                    let arg_os_event = arg_os_event as *mut _;
                    let result = f(arg_self_, arg_browser, arg_event, arg_os_event);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_keyboard_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for KeyboardHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_keyboard_handler_t> for &KeyboardHandler {
    fn as_raw(self) -> *mut _cef_keyboard_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_keyboard_handler_t> for &mut KeyboardHandler {
    fn as_raw(self) -> *mut _cef_keyboard_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<KeyboardHandler> for *mut _cef_keyboard_handler_t {
    fn as_wrapper(self) -> KeyboardHandler {
        KeyboardHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_keyboard_handler_t> for KeyboardHandler {
    fn into(self) -> *mut _cef_keyboard_handler_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for KeyboardHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplLifeSpanHandler: Sized {
    fn on_before_popup<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        popup_id: ::std::os::raw::c_int,
        target_url: &'a CefStringUtf16,
        target_frame_name: &'a CefStringUtf16,
        target_disposition: WindowOpenDisposition,
        user_gesture: ::std::os::raw::c_int,
        popup_features: &'a PopupFeatures,
        window_info: &'a mut WindowInfo,
        client: _cef_client_t,
        settings: &'a mut BrowserSettings,
        extra_info: _cef_dictionary_value_t,
        no_javascript_access: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn on_before_popup_aborted<'a>(
        &self,
        browser: &'a mut Browser,
        popup_id: ::std::os::raw::c_int,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn on_before_dev_tools_popup<'a>(
        &self,
        browser: &'a mut Browser,
        window_info: &'a mut WindowInfo,
        client: _cef_client_t,
        settings: &'a mut BrowserSettings,
        extra_info: _cef_dictionary_value_t,
        use_default_window: *mut ::std::os::raw::c_int,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn on_after_created<'a>(&self, browser: &'a mut Browser) {
        unsafe { std::mem::zeroed() }
    }
    fn do_close<'a>(&self, browser: &'a mut Browser) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn on_before_close<'a>(&self, browser: &'a mut Browser) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_life_span_handler_t {
        let mut object: _cef_life_span_handler_t = unsafe { std::mem::zeroed() };
        impl_cef_life_span_handler_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_life_span_handler_t {
    use super::*;
    pub fn init_methods<I: ImplLifeSpanHandler>(object: &mut _cef_life_span_handler_t) {
        object.on_before_popup = Some(on_before_popup::<I>);
        object.on_before_popup_aborted = Some(on_before_popup_aborted::<I>);
        object.on_before_dev_tools_popup = Some(on_before_dev_tools_popup::<I>);
        object.on_after_created = Some(on_after_created::<I>);
        object.do_close = Some(do_close::<I>);
        object.on_before_close = Some(on_before_close::<I>);
    }
    extern "C" fn on_before_popup<I: ImplLifeSpanHandler>(
        self_: *mut _cef_life_span_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        popup_id: ::std::os::raw::c_int,
        target_url: *const _cef_string_utf16_t,
        target_frame_name: *const _cef_string_utf16_t,
        target_disposition: cef_window_open_disposition_t,
        user_gesture: ::std::os::raw::c_int,
        popup_features: *const _cef_popup_features_t,
        window_info: *mut _cef_window_info_t,
        client: *mut *mut _cef_client_t,
        settings: *mut _cef_browser_settings_t,
        extra_info: *mut *mut _cef_dictionary_value_t,
        no_javascript_access: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_browser,
            arg_frame,
            arg_popup_id,
            arg_target_url,
            arg_target_frame_name,
            arg_target_disposition,
            arg_user_gesture,
            arg_popup_features,
            arg_window_info,
            arg_client,
            arg_settings,
            arg_extra_info,
            arg_no_javascript_access,
        ) = (
            self_,
            browser,
            frame,
            popup_id,
            target_url,
            target_frame_name,
            target_disposition,
            user_gesture,
            popup_features,
            window_info,
            client,
            settings,
            extra_info,
            no_javascript_access,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_frame) });
        let arg_popup_id = arg_popup_id.as_raw();
        let arg_target_url = WrapParamRef::<CefStringUtf16>::from(arg_target_url);
        let arg_target_url = arg_target_url.as_ref();
        let arg_target_frame_name = WrapParamRef::<CefStringUtf16>::from(arg_target_frame_name);
        let arg_target_frame_name = arg_target_frame_name.as_ref();
        let arg_target_disposition = arg_target_disposition.as_raw();
        let arg_user_gesture = arg_user_gesture.as_raw();
        let arg_popup_features = WrapParamRef::<PopupFeatures>::from(arg_popup_features);
        let arg_popup_features = arg_popup_features.as_ref();
        let mut arg_window_info = WrapParamRef::<WindowInfo>::from(arg_window_info);
        let arg_window_info = arg_window_info.as_mut();
        let mut arg_client = WrapParamRef::<Client>::from(arg_client);
        let arg_client = arg_client.as_mut();
        let mut arg_settings = WrapParamRef::<BrowserSettings>::from(arg_settings);
        let arg_settings = arg_settings.as_mut();
        let mut arg_extra_info = WrapParamRef::<DictionaryValue>::from(arg_extra_info);
        let arg_extra_info = arg_extra_info.as_mut();
        let mut arg_no_javascript_access =
            WrapParamRef::<::std::os::raw::c_int>::from(arg_no_javascript_access);
        let arg_no_javascript_access = arg_no_javascript_access.as_mut();
        arg_self_
            .interface
            .on_before_popup(
                arg_browser,
                arg_frame,
                arg_popup_id,
                arg_target_url,
                arg_target_frame_name,
                arg_target_disposition,
                arg_user_gesture,
                arg_popup_features,
                arg_window_info,
                arg_client,
                arg_settings,
                arg_extra_info,
                arg_no_javascript_access,
            )
            .into()
    }
    extern "C" fn on_before_popup_aborted<I: ImplLifeSpanHandler>(
        self_: *mut _cef_life_span_handler_t,
        browser: *mut _cef_browser_t,
        popup_id: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_browser, arg_popup_id) = (self_, browser, popup_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_popup_id = arg_popup_id.as_raw();
        arg_self_
            .interface
            .on_before_popup_aborted(arg_browser, arg_popup_id)
    }
    extern "C" fn on_before_dev_tools_popup<I: ImplLifeSpanHandler>(
        self_: *mut _cef_life_span_handler_t,
        browser: *mut _cef_browser_t,
        window_info: *mut _cef_window_info_t,
        client: *mut *mut _cef_client_t,
        settings: *mut _cef_browser_settings_t,
        extra_info: *mut *mut _cef_dictionary_value_t,
        use_default_window: *mut ::std::os::raw::c_int,
    ) {
        let (
            arg_self_,
            arg_browser,
            arg_window_info,
            arg_client,
            arg_settings,
            arg_extra_info,
            arg_use_default_window,
        ) = (
            self_,
            browser,
            window_info,
            client,
            settings,
            extra_info,
            use_default_window,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let mut arg_window_info = WrapParamRef::<WindowInfo>::from(arg_window_info);
        let arg_window_info = arg_window_info.as_mut();
        let mut arg_client = WrapParamRef::<Client>::from(arg_client);
        let arg_client = arg_client.as_mut();
        let mut arg_settings = WrapParamRef::<BrowserSettings>::from(arg_settings);
        let arg_settings = arg_settings.as_mut();
        let mut arg_extra_info = WrapParamRef::<DictionaryValue>::from(arg_extra_info);
        let arg_extra_info = arg_extra_info.as_mut();
        let mut arg_use_default_window =
            WrapParamRef::<::std::os::raw::c_int>::from(arg_use_default_window);
        let arg_use_default_window = arg_use_default_window.as_mut();
        arg_self_.interface.on_before_dev_tools_popup(
            arg_browser,
            arg_window_info,
            arg_client,
            arg_settings,
            arg_extra_info,
            arg_use_default_window,
        )
    }
    extern "C" fn on_after_created<I: ImplLifeSpanHandler>(
        self_: *mut _cef_life_span_handler_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        arg_self_.interface.on_after_created(arg_browser)
    }
    extern "C" fn do_close<I: ImplLifeSpanHandler>(
        self_: *mut _cef_life_span_handler_t,
        browser: *mut _cef_browser_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        arg_self_.interface.do_close(arg_browser).into()
    }
    extern "C" fn on_before_close<I: ImplLifeSpanHandler>(
        self_: *mut _cef_life_span_handler_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        arg_self_.interface.on_before_close(arg_browser)
    }
}
#[doc = "See [_cef_life_span_handler_t] for more documentation."]
#[derive(Clone)]
pub struct LifeSpanHandler(RefGuard<_cef_life_span_handler_t>);
impl ImplLifeSpanHandler for LifeSpanHandler {
    fn on_before_popup<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        popup_id: ::std::os::raw::c_int,
        target_url: &'a CefStringUtf16,
        target_frame_name: &'a CefStringUtf16,
        target_disposition: WindowOpenDisposition,
        user_gesture: ::std::os::raw::c_int,
        popup_features: &'a PopupFeatures,
        window_info: &'a mut WindowInfo,
        client: _cef_client_t,
        settings: &'a mut BrowserSettings,
        extra_info: _cef_dictionary_value_t,
        no_javascript_access: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_before_popup
                .map(|f| {
                    let (
                        arg_browser,
                        arg_frame,
                        arg_popup_id,
                        arg_target_url,
                        arg_target_frame_name,
                        arg_target_disposition,
                        arg_user_gesture,
                        arg_popup_features,
                        arg_window_info,
                        arg_client,
                        arg_settings,
                        arg_extra_info,
                        arg_no_javascript_access,
                    ) = (
                        browser,
                        frame,
                        popup_id,
                        target_url,
                        target_frame_name,
                        target_disposition,
                        user_gesture,
                        popup_features,
                        window_info,
                        client,
                        settings,
                        extra_info,
                        no_javascript_access,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_frame = arg_frame.as_raw();
                    let arg_popup_id = arg_popup_id;
                    let arg_target_url = arg_target_url.as_raw();
                    let arg_target_frame_name = arg_target_frame_name.as_raw();
                    let arg_target_disposition = arg_target_disposition.as_raw();
                    let arg_user_gesture = arg_user_gesture;
                    let mut arg_popup_features: _cef_popup_features_t =
                        arg_popup_features.clone().into();
                    let arg_popup_features = &mut arg_popup_features;
                    let mut arg_window_info: _cef_window_info_t = arg_window_info.clone().into();
                    let arg_window_info = &mut arg_window_info;
                    let arg_client = arg_client.as_raw();
                    let mut arg_settings: _cef_browser_settings_t = arg_settings.clone().into();
                    let arg_settings = &mut arg_settings;
                    let arg_extra_info = arg_extra_info.as_raw();
                    let arg_no_javascript_access = arg_no_javascript_access as *mut _;
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_popup_id,
                        arg_target_url,
                        arg_target_frame_name,
                        arg_target_disposition,
                        arg_user_gesture,
                        arg_popup_features,
                        arg_window_info,
                        arg_client,
                        arg_settings,
                        arg_extra_info,
                        arg_no_javascript_access,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_before_popup_aborted<'a>(
        &self,
        browser: &'a mut Browser,
        popup_id: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .on_before_popup_aborted
                .map(|f| {
                    let (arg_browser, arg_popup_id) = (browser, popup_id);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_popup_id = arg_popup_id;
                    let result = f(arg_self_, arg_browser, arg_popup_id);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_before_dev_tools_popup<'a>(
        &self,
        browser: &'a mut Browser,
        window_info: &'a mut WindowInfo,
        client: _cef_client_t,
        settings: &'a mut BrowserSettings,
        extra_info: _cef_dictionary_value_t,
        use_default_window: *mut ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .on_before_dev_tools_popup
                .map(|f| {
                    let (
                        arg_browser,
                        arg_window_info,
                        arg_client,
                        arg_settings,
                        arg_extra_info,
                        arg_use_default_window,
                    ) = (
                        browser,
                        window_info,
                        client,
                        settings,
                        extra_info,
                        use_default_window,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let mut arg_window_info: _cef_window_info_t = arg_window_info.clone().into();
                    let arg_window_info = &mut arg_window_info;
                    let arg_client = arg_client.as_raw();
                    let mut arg_settings: _cef_browser_settings_t = arg_settings.clone().into();
                    let arg_settings = &mut arg_settings;
                    let arg_extra_info = arg_extra_info.as_raw();
                    let arg_use_default_window = arg_use_default_window as *mut _;
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_window_info,
                        arg_client,
                        arg_settings,
                        arg_extra_info,
                        arg_use_default_window,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_after_created<'a>(&self, browser: &'a mut Browser) {
        unsafe {
            self.0
                .on_after_created
                .map(|f| {
                    let arg_browser = browser;
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let result = f(arg_self_, arg_browser);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn do_close<'a>(&self, browser: &'a mut Browser) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .do_close
                .map(|f| {
                    let arg_browser = browser;
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let result = f(arg_self_, arg_browser);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_before_close<'a>(&self, browser: &'a mut Browser) {
        unsafe {
            self.0
                .on_before_close
                .map(|f| {
                    let arg_browser = browser;
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let result = f(arg_self_, arg_browser);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_life_span_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for LifeSpanHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_life_span_handler_t> for &LifeSpanHandler {
    fn as_raw(self) -> *mut _cef_life_span_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_life_span_handler_t> for &mut LifeSpanHandler {
    fn as_raw(self) -> *mut _cef_life_span_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<LifeSpanHandler> for *mut _cef_life_span_handler_t {
    fn as_wrapper(self) -> LifeSpanHandler {
        LifeSpanHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_life_span_handler_t> for LifeSpanHandler {
    fn into(self) -> *mut _cef_life_span_handler_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for LifeSpanHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplLoadHandler: Sized {
    fn on_loading_state_change<'a>(
        &self,
        browser: &'a mut Browser,
        is_loading: ::std::os::raw::c_int,
        can_go_back: ::std::os::raw::c_int,
        can_go_forward: ::std::os::raw::c_int,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn on_load_start<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        transition_type: TransitionType,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn on_load_end<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        http_status_code: ::std::os::raw::c_int,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn on_load_error<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        error_code: Errorcode,
        error_text: &'a CefStringUtf16,
        failed_url: &'a CefStringUtf16,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_load_handler_t {
        let mut object: _cef_load_handler_t = unsafe { std::mem::zeroed() };
        impl_cef_load_handler_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_load_handler_t {
    use super::*;
    pub fn init_methods<I: ImplLoadHandler>(object: &mut _cef_load_handler_t) {
        object.on_loading_state_change = Some(on_loading_state_change::<I>);
        object.on_load_start = Some(on_load_start::<I>);
        object.on_load_end = Some(on_load_end::<I>);
        object.on_load_error = Some(on_load_error::<I>);
    }
    extern "C" fn on_loading_state_change<I: ImplLoadHandler>(
        self_: *mut _cef_load_handler_t,
        browser: *mut _cef_browser_t,
        is_loading: ::std::os::raw::c_int,
        can_go_back: ::std::os::raw::c_int,
        can_go_forward: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_browser, arg_is_loading, arg_can_go_back, arg_can_go_forward) =
            (self_, browser, is_loading, can_go_back, can_go_forward);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_is_loading = arg_is_loading.as_raw();
        let arg_can_go_back = arg_can_go_back.as_raw();
        let arg_can_go_forward = arg_can_go_forward.as_raw();
        arg_self_.interface.on_loading_state_change(
            arg_browser,
            arg_is_loading,
            arg_can_go_back,
            arg_can_go_forward,
        )
    }
    extern "C" fn on_load_start<I: ImplLoadHandler>(
        self_: *mut _cef_load_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        transition_type: cef_transition_type_t,
    ) {
        let (arg_self_, arg_browser, arg_frame, arg_transition_type) =
            (self_, browser, frame, transition_type);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_frame) });
        let arg_transition_type = arg_transition_type.as_raw();
        arg_self_
            .interface
            .on_load_start(arg_browser, arg_frame, arg_transition_type)
    }
    extern "C" fn on_load_end<I: ImplLoadHandler>(
        self_: *mut _cef_load_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        http_status_code: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_browser, arg_frame, arg_http_status_code) =
            (self_, browser, frame, http_status_code);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_frame) });
        let arg_http_status_code = arg_http_status_code.as_raw();
        arg_self_
            .interface
            .on_load_end(arg_browser, arg_frame, arg_http_status_code)
    }
    extern "C" fn on_load_error<I: ImplLoadHandler>(
        self_: *mut _cef_load_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        error_code: cef_errorcode_t,
        error_text: *const _cef_string_utf16_t,
        failed_url: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_browser, arg_frame, arg_error_code, arg_error_text, arg_failed_url) =
            (self_, browser, frame, error_code, error_text, failed_url);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_frame) });
        let arg_error_code = arg_error_code.as_raw();
        let arg_error_text = WrapParamRef::<CefStringUtf16>::from(arg_error_text);
        let arg_error_text = arg_error_text.as_ref();
        let arg_failed_url = WrapParamRef::<CefStringUtf16>::from(arg_failed_url);
        let arg_failed_url = arg_failed_url.as_ref();
        arg_self_.interface.on_load_error(
            arg_browser,
            arg_frame,
            arg_error_code,
            arg_error_text,
            arg_failed_url,
        )
    }
}
#[doc = "See [_cef_load_handler_t] for more documentation."]
#[derive(Clone)]
pub struct LoadHandler(RefGuard<_cef_load_handler_t>);
impl ImplLoadHandler for LoadHandler {
    fn on_loading_state_change<'a>(
        &self,
        browser: &'a mut Browser,
        is_loading: ::std::os::raw::c_int,
        can_go_back: ::std::os::raw::c_int,
        can_go_forward: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .on_loading_state_change
                .map(|f| {
                    let (arg_browser, arg_is_loading, arg_can_go_back, arg_can_go_forward) =
                        (browser, is_loading, can_go_back, can_go_forward);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_is_loading = arg_is_loading;
                    let arg_can_go_back = arg_can_go_back;
                    let arg_can_go_forward = arg_can_go_forward;
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_is_loading,
                        arg_can_go_back,
                        arg_can_go_forward,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_load_start<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        transition_type: TransitionType,
    ) {
        unsafe {
            self.0
                .on_load_start
                .map(|f| {
                    let (arg_browser, arg_frame, arg_transition_type) =
                        (browser, frame, transition_type);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_frame = arg_frame.as_raw();
                    let arg_transition_type = arg_transition_type.as_raw();
                    let result = f(arg_self_, arg_browser, arg_frame, arg_transition_type);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_load_end<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        http_status_code: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .on_load_end
                .map(|f| {
                    let (arg_browser, arg_frame, arg_http_status_code) =
                        (browser, frame, http_status_code);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_frame = arg_frame.as_raw();
                    let arg_http_status_code = arg_http_status_code;
                    let result = f(arg_self_, arg_browser, arg_frame, arg_http_status_code);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_load_error<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        error_code: Errorcode,
        error_text: &'a CefStringUtf16,
        failed_url: &'a CefStringUtf16,
    ) {
        unsafe {
            self.0
                .on_load_error
                .map(|f| {
                    let (arg_browser, arg_frame, arg_error_code, arg_error_text, arg_failed_url) =
                        (browser, frame, error_code, error_text, failed_url);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_frame = arg_frame.as_raw();
                    let arg_error_code = arg_error_code.as_raw();
                    let arg_error_text = arg_error_text.as_raw();
                    let arg_failed_url = arg_failed_url.as_raw();
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_error_code,
                        arg_error_text,
                        arg_failed_url,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_load_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for LoadHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_load_handler_t> for &LoadHandler {
    fn as_raw(self) -> *mut _cef_load_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_load_handler_t> for &mut LoadHandler {
    fn as_raw(self) -> *mut _cef_load_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<LoadHandler> for *mut _cef_load_handler_t {
    fn as_wrapper(self) -> LoadHandler {
        LoadHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_load_handler_t> for LoadHandler {
    fn into(self) -> *mut _cef_load_handler_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for LoadHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplMediaAccessCallback: Sized {
    fn cont<'a>(&self, allowed_permissions: u32) {
        unsafe { std::mem::zeroed() }
    }
    fn cancel<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_media_access_callback_t {
        let mut object: _cef_media_access_callback_t = unsafe { std::mem::zeroed() };
        impl_cef_media_access_callback_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_media_access_callback_t {
    use super::*;
    pub fn init_methods<I: ImplMediaAccessCallback>(object: &mut _cef_media_access_callback_t) {
        object.cont = Some(cont::<I>);
        object.cancel = Some(cancel::<I>);
    }
    extern "C" fn cont<I: ImplMediaAccessCallback>(
        self_: *mut _cef_media_access_callback_t,
        allowed_permissions: u32,
    ) {
        let (arg_self_, arg_allowed_permissions) = (self_, allowed_permissions);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_allowed_permissions = arg_allowed_permissions.as_raw();
        arg_self_.interface.cont(arg_allowed_permissions)
    }
    extern "C" fn cancel<I: ImplMediaAccessCallback>(self_: *mut _cef_media_access_callback_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.cancel()
    }
}
#[doc = "See [_cef_media_access_callback_t] for more documentation."]
#[derive(Clone)]
pub struct MediaAccessCallback(RefGuard<_cef_media_access_callback_t>);
impl ImplMediaAccessCallback for MediaAccessCallback {
    fn cont<'a>(&self, allowed_permissions: u32) {
        unsafe {
            self.0
                .cont
                .map(|f| {
                    let arg_allowed_permissions = allowed_permissions;
                    let arg_self_ = self.as_raw();
                    let arg_allowed_permissions = arg_allowed_permissions;
                    let result = f(arg_self_, arg_allowed_permissions);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn cancel<'a>(&self) {
        unsafe {
            self.0
                .cancel
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_media_access_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for MediaAccessCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_media_access_callback_t> for &MediaAccessCallback {
    fn as_raw(self) -> *mut _cef_media_access_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_media_access_callback_t> for &mut MediaAccessCallback {
    fn as_raw(self) -> *mut _cef_media_access_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<MediaAccessCallback> for *mut _cef_media_access_callback_t {
    fn as_wrapper(self) -> MediaAccessCallback {
        MediaAccessCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_media_access_callback_t> for MediaAccessCallback {
    fn into(self) -> *mut _cef_media_access_callback_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for MediaAccessCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplPermissionPromptCallback: Sized {
    fn cont<'a>(&self, result: PermissionRequestResult) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_permission_prompt_callback_t {
        let mut object: _cef_permission_prompt_callback_t = unsafe { std::mem::zeroed() };
        impl_cef_permission_prompt_callback_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_permission_prompt_callback_t {
    use super::*;
    pub fn init_methods<I: ImplPermissionPromptCallback>(
        object: &mut _cef_permission_prompt_callback_t,
    ) {
        object.cont = Some(cont::<I>);
    }
    extern "C" fn cont<I: ImplPermissionPromptCallback>(
        self_: *mut _cef_permission_prompt_callback_t,
        result: cef_permission_request_result_t,
    ) {
        let (arg_self_, arg_result) = (self_, result);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_result = arg_result.as_raw();
        arg_self_.interface.cont(arg_result)
    }
}
#[doc = "See [_cef_permission_prompt_callback_t] for more documentation."]
#[derive(Clone)]
pub struct PermissionPromptCallback(RefGuard<_cef_permission_prompt_callback_t>);
impl ImplPermissionPromptCallback for PermissionPromptCallback {
    fn cont<'a>(&self, result: PermissionRequestResult) {
        unsafe {
            self.0
                .cont
                .map(|f| {
                    let arg_result = result;
                    let arg_self_ = self.as_raw();
                    let arg_result = arg_result.as_raw();
                    let result = f(arg_self_, arg_result);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_permission_prompt_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for PermissionPromptCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_permission_prompt_callback_t> for &PermissionPromptCallback {
    fn as_raw(self) -> *mut _cef_permission_prompt_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_permission_prompt_callback_t> for &mut PermissionPromptCallback {
    fn as_raw(self) -> *mut _cef_permission_prompt_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<PermissionPromptCallback> for *mut _cef_permission_prompt_callback_t {
    fn as_wrapper(self) -> PermissionPromptCallback {
        PermissionPromptCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_permission_prompt_callback_t> for PermissionPromptCallback {
    fn into(self) -> *mut _cef_permission_prompt_callback_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for PermissionPromptCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplPermissionHandler: Sized {
    fn on_request_media_access_permission<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        requesting_origin: &'a CefStringUtf16,
        requested_permissions: u32,
        callback: &'a mut MediaAccessCallback,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn on_show_permission_prompt<'a>(
        &self,
        browser: &'a mut Browser,
        prompt_id: u64,
        requesting_origin: &'a CefStringUtf16,
        requested_permissions: u32,
        callback: &'a mut PermissionPromptCallback,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn on_dismiss_permission_prompt<'a>(
        &self,
        browser: &'a mut Browser,
        prompt_id: u64,
        result: PermissionRequestResult,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_permission_handler_t {
        let mut object: _cef_permission_handler_t = unsafe { std::mem::zeroed() };
        impl_cef_permission_handler_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_permission_handler_t {
    use super::*;
    pub fn init_methods<I: ImplPermissionHandler>(object: &mut _cef_permission_handler_t) {
        object.on_request_media_access_permission = Some(on_request_media_access_permission::<I>);
        object.on_show_permission_prompt = Some(on_show_permission_prompt::<I>);
        object.on_dismiss_permission_prompt = Some(on_dismiss_permission_prompt::<I>);
    }
    extern "C" fn on_request_media_access_permission<I: ImplPermissionHandler>(
        self_: *mut _cef_permission_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        requesting_origin: *const _cef_string_utf16_t,
        requested_permissions: u32,
        callback: *mut _cef_media_access_callback_t,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_browser,
            arg_frame,
            arg_requesting_origin,
            arg_requested_permissions,
            arg_callback,
        ) = (
            self_,
            browser,
            frame,
            requesting_origin,
            requested_permissions,
            callback,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_frame) });
        let arg_requesting_origin = WrapParamRef::<CefStringUtf16>::from(arg_requesting_origin);
        let arg_requesting_origin = arg_requesting_origin.as_ref();
        let arg_requested_permissions = arg_requested_permissions.as_raw();
        let arg_callback =
            &mut MediaAccessCallback(unsafe { RefGuard::from_raw_add_ref(arg_callback) });
        arg_self_
            .interface
            .on_request_media_access_permission(
                arg_browser,
                arg_frame,
                arg_requesting_origin,
                arg_requested_permissions,
                arg_callback,
            )
            .into()
    }
    extern "C" fn on_show_permission_prompt<I: ImplPermissionHandler>(
        self_: *mut _cef_permission_handler_t,
        browser: *mut _cef_browser_t,
        prompt_id: u64,
        requesting_origin: *const _cef_string_utf16_t,
        requested_permissions: u32,
        callback: *mut _cef_permission_prompt_callback_t,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_browser,
            arg_prompt_id,
            arg_requesting_origin,
            arg_requested_permissions,
            arg_callback,
        ) = (
            self_,
            browser,
            prompt_id,
            requesting_origin,
            requested_permissions,
            callback,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_prompt_id = arg_prompt_id.as_raw();
        let arg_requesting_origin = WrapParamRef::<CefStringUtf16>::from(arg_requesting_origin);
        let arg_requesting_origin = arg_requesting_origin.as_ref();
        let arg_requested_permissions = arg_requested_permissions.as_raw();
        let arg_callback =
            &mut PermissionPromptCallback(unsafe { RefGuard::from_raw_add_ref(arg_callback) });
        arg_self_
            .interface
            .on_show_permission_prompt(
                arg_browser,
                arg_prompt_id,
                arg_requesting_origin,
                arg_requested_permissions,
                arg_callback,
            )
            .into()
    }
    extern "C" fn on_dismiss_permission_prompt<I: ImplPermissionHandler>(
        self_: *mut _cef_permission_handler_t,
        browser: *mut _cef_browser_t,
        prompt_id: u64,
        result: cef_permission_request_result_t,
    ) {
        let (arg_self_, arg_browser, arg_prompt_id, arg_result) =
            (self_, browser, prompt_id, result);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_prompt_id = arg_prompt_id.as_raw();
        let arg_result = arg_result.as_raw();
        arg_self_
            .interface
            .on_dismiss_permission_prompt(arg_browser, arg_prompt_id, arg_result)
    }
}
#[doc = "See [_cef_permission_handler_t] for more documentation."]
#[derive(Clone)]
pub struct PermissionHandler(RefGuard<_cef_permission_handler_t>);
impl ImplPermissionHandler for PermissionHandler {
    fn on_request_media_access_permission<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        requesting_origin: &'a CefStringUtf16,
        requested_permissions: u32,
        callback: &'a mut MediaAccessCallback,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_request_media_access_permission
                .map(|f| {
                    let (
                        arg_browser,
                        arg_frame,
                        arg_requesting_origin,
                        arg_requested_permissions,
                        arg_callback,
                    ) = (
                        browser,
                        frame,
                        requesting_origin,
                        requested_permissions,
                        callback,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_frame = arg_frame.as_raw();
                    let arg_requesting_origin = arg_requesting_origin.as_raw();
                    let arg_requested_permissions = arg_requested_permissions;
                    let arg_callback = arg_callback.as_raw();
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_requesting_origin,
                        arg_requested_permissions,
                        arg_callback,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_show_permission_prompt<'a>(
        &self,
        browser: &'a mut Browser,
        prompt_id: u64,
        requesting_origin: &'a CefStringUtf16,
        requested_permissions: u32,
        callback: &'a mut PermissionPromptCallback,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_show_permission_prompt
                .map(|f| {
                    let (
                        arg_browser,
                        arg_prompt_id,
                        arg_requesting_origin,
                        arg_requested_permissions,
                        arg_callback,
                    ) = (
                        browser,
                        prompt_id,
                        requesting_origin,
                        requested_permissions,
                        callback,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_prompt_id = arg_prompt_id;
                    let arg_requesting_origin = arg_requesting_origin.as_raw();
                    let arg_requested_permissions = arg_requested_permissions;
                    let arg_callback = arg_callback.as_raw();
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_prompt_id,
                        arg_requesting_origin,
                        arg_requested_permissions,
                        arg_callback,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_dismiss_permission_prompt<'a>(
        &self,
        browser: &'a mut Browser,
        prompt_id: u64,
        result: PermissionRequestResult,
    ) {
        unsafe {
            self.0
                .on_dismiss_permission_prompt
                .map(|f| {
                    let (arg_browser, arg_prompt_id, arg_result) = (browser, prompt_id, result);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_prompt_id = arg_prompt_id;
                    let arg_result = arg_result.as_raw();
                    let result = f(arg_self_, arg_browser, arg_prompt_id, arg_result);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_permission_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for PermissionHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_permission_handler_t> for &PermissionHandler {
    fn as_raw(self) -> *mut _cef_permission_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_permission_handler_t> for &mut PermissionHandler {
    fn as_raw(self) -> *mut _cef_permission_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<PermissionHandler> for *mut _cef_permission_handler_t {
    fn as_wrapper(self) -> PermissionHandler {
        PermissionHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_permission_handler_t> for PermissionHandler {
    fn into(self) -> *mut _cef_permission_handler_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for PermissionHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplPrintSettings: Sized {
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_read_only<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_orientation<'a>(&self, landscape: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn is_landscape<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_printer_printable_area<'a>(
        &self,
        physical_size_device_units: &'a Size,
        printable_area_device_units: &'a Rect,
        landscape_needs_flip: ::std::os::raw::c_int,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn set_device_name<'a>(&self, name: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn get_device_name<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn set_dpi<'a>(&self, dpi: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn get_dpi<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_page_ranges<'a>(&self, ranges_count: usize, ranges: &'a Range) {
        unsafe { std::mem::zeroed() }
    }
    fn get_page_ranges_count<'a>(&self) -> usize {
        unsafe { std::mem::zeroed() }
    }
    fn get_page_ranges<'a>(&self, ranges_count: *mut usize, ranges: &'a mut Range) {
        unsafe { std::mem::zeroed() }
    }
    fn set_selection_only<'a>(&self, selection_only: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn is_selection_only<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_collate<'a>(&self, collate: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn will_collate<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_color_model<'a>(&self, model: ColorModel) {
        unsafe { std::mem::zeroed() }
    }
    fn get_color_model<'a>(&self) -> ColorModel {
        unsafe { std::mem::zeroed() }
    }
    fn set_copies<'a>(&self, copies: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn get_copies<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_duplex_mode<'a>(&self, mode: DuplexMode) {
        unsafe { std::mem::zeroed() }
    }
    fn get_duplex_mode<'a>(&self) -> DuplexMode {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_print_settings_t {
        let mut object: _cef_print_settings_t = unsafe { std::mem::zeroed() };
        impl_cef_print_settings_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_print_settings_t {
    use super::*;
    pub fn init_methods<I: ImplPrintSettings>(object: &mut _cef_print_settings_t) {
        object.is_valid = Some(is_valid::<I>);
        object.is_read_only = Some(is_read_only::<I>);
        object.set_orientation = Some(set_orientation::<I>);
        object.is_landscape = Some(is_landscape::<I>);
        object.set_printer_printable_area = Some(set_printer_printable_area::<I>);
        object.set_device_name = Some(set_device_name::<I>);
        object.get_device_name = Some(get_device_name::<I>);
        object.set_dpi = Some(set_dpi::<I>);
        object.get_dpi = Some(get_dpi::<I>);
        object.set_page_ranges = Some(set_page_ranges::<I>);
        object.get_page_ranges_count = Some(get_page_ranges_count::<I>);
        object.get_page_ranges = Some(get_page_ranges::<I>);
        object.set_selection_only = Some(set_selection_only::<I>);
        object.is_selection_only = Some(is_selection_only::<I>);
        object.set_collate = Some(set_collate::<I>);
        object.will_collate = Some(will_collate::<I>);
        object.set_color_model = Some(set_color_model::<I>);
        object.get_color_model = Some(get_color_model::<I>);
        object.set_copies = Some(set_copies::<I>);
        object.get_copies = Some(get_copies::<I>);
        object.set_duplex_mode = Some(set_duplex_mode::<I>);
        object.get_duplex_mode = Some(get_duplex_mode::<I>);
    }
    extern "C" fn is_valid<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_valid().into()
    }
    extern "C" fn is_read_only<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_read_only().into()
    }
    extern "C" fn set_orientation<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
        landscape: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_landscape) = (self_, landscape);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_landscape = arg_landscape.as_raw();
        arg_self_.interface.set_orientation(arg_landscape)
    }
    extern "C" fn is_landscape<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_landscape().into()
    }
    extern "C" fn set_printer_printable_area<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
        physical_size_device_units: *const _cef_size_t,
        printable_area_device_units: *const _cef_rect_t,
        landscape_needs_flip: ::std::os::raw::c_int,
    ) {
        let (
            arg_self_,
            arg_physical_size_device_units,
            arg_printable_area_device_units,
            arg_landscape_needs_flip,
        ) = (
            self_,
            physical_size_device_units,
            printable_area_device_units,
            landscape_needs_flip,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_physical_size_device_units =
            WrapParamRef::<Size>::from(arg_physical_size_device_units);
        let arg_physical_size_device_units = arg_physical_size_device_units.as_ref();
        let arg_printable_area_device_units =
            WrapParamRef::<Rect>::from(arg_printable_area_device_units);
        let arg_printable_area_device_units = arg_printable_area_device_units.as_ref();
        let arg_landscape_needs_flip = arg_landscape_needs_flip.as_raw();
        arg_self_.interface.set_printer_printable_area(
            arg_physical_size_device_units,
            arg_printable_area_device_units,
            arg_landscape_needs_flip,
        )
    }
    extern "C" fn set_device_name<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
        name: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_name) = (self_, name);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = WrapParamRef::<CefStringUtf16>::from(arg_name);
        let arg_name = arg_name.as_ref();
        arg_self_.interface.set_device_name(arg_name)
    }
    extern "C" fn get_device_name<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_device_name().into()
    }
    extern "C" fn set_dpi<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
        dpi: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_dpi) = (self_, dpi);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_dpi = arg_dpi.as_raw();
        arg_self_.interface.set_dpi(arg_dpi)
    }
    extern "C" fn get_dpi<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_dpi().into()
    }
    extern "C" fn set_page_ranges<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
        ranges_count: usize,
        ranges: *const _cef_range_t,
    ) {
        let (arg_self_, arg_ranges_count, arg_ranges) = (self_, ranges_count, ranges);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_ranges_count = arg_ranges_count.as_raw();
        let arg_ranges = WrapParamRef::<Range>::from(arg_ranges);
        let arg_ranges = arg_ranges.as_ref();
        arg_self_
            .interface
            .set_page_ranges(arg_ranges_count, arg_ranges)
    }
    extern "C" fn get_page_ranges_count<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
    ) -> usize {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_page_ranges_count().into()
    }
    extern "C" fn get_page_ranges<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
        ranges_count: *mut usize,
        ranges: *mut _cef_range_t,
    ) {
        let (arg_self_, arg_ranges_count, arg_ranges) = (self_, ranges_count, ranges);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_ranges_count = WrapParamRef::<usize>::from(arg_ranges_count);
        let arg_ranges_count = arg_ranges_count.as_mut();
        let mut arg_ranges = WrapParamRef::<Range>::from(arg_ranges);
        let arg_ranges = arg_ranges.as_mut();
        arg_self_
            .interface
            .get_page_ranges(arg_ranges_count, arg_ranges)
    }
    extern "C" fn set_selection_only<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
        selection_only: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_selection_only) = (self_, selection_only);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_selection_only = arg_selection_only.as_raw();
        arg_self_.interface.set_selection_only(arg_selection_only)
    }
    extern "C" fn is_selection_only<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_selection_only().into()
    }
    extern "C" fn set_collate<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
        collate: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_collate) = (self_, collate);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_collate = arg_collate.as_raw();
        arg_self_.interface.set_collate(arg_collate)
    }
    extern "C" fn will_collate<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.will_collate().into()
    }
    extern "C" fn set_color_model<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
        model: cef_color_model_t,
    ) {
        let (arg_self_, arg_model) = (self_, model);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_model = arg_model.as_raw();
        arg_self_.interface.set_color_model(arg_model)
    }
    extern "C" fn get_color_model<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
    ) -> cef_color_model_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_color_model().into()
    }
    extern "C" fn set_copies<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
        copies: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_copies) = (self_, copies);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_copies = arg_copies.as_raw();
        arg_self_.interface.set_copies(arg_copies)
    }
    extern "C" fn get_copies<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_copies().into()
    }
    extern "C" fn set_duplex_mode<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
        mode: cef_duplex_mode_t,
    ) {
        let (arg_self_, arg_mode) = (self_, mode);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_mode = arg_mode.as_raw();
        arg_self_.interface.set_duplex_mode(arg_mode)
    }
    extern "C" fn get_duplex_mode<I: ImplPrintSettings>(
        self_: *mut _cef_print_settings_t,
    ) -> cef_duplex_mode_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_duplex_mode().into()
    }
}
#[doc = "See [_cef_print_settings_t] for more documentation."]
#[derive(Clone)]
pub struct PrintSettings(RefGuard<_cef_print_settings_t>);
impl ImplPrintSettings for PrintSettings {
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_read_only<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_read_only
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_orientation<'a>(&self, landscape: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_orientation
                .map(|f| {
                    let arg_landscape = landscape;
                    let arg_self_ = self.as_raw();
                    let arg_landscape = arg_landscape;
                    let result = f(arg_self_, arg_landscape);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_landscape<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_landscape
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_printer_printable_area<'a>(
        &self,
        physical_size_device_units: &'a Size,
        printable_area_device_units: &'a Rect,
        landscape_needs_flip: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .set_printer_printable_area
                .map(|f| {
                    let (
                        arg_physical_size_device_units,
                        arg_printable_area_device_units,
                        arg_landscape_needs_flip,
                    ) = (
                        physical_size_device_units,
                        printable_area_device_units,
                        landscape_needs_flip,
                    );
                    let arg_self_ = self.as_raw();
                    let mut arg_physical_size_device_units: _cef_size_t =
                        arg_physical_size_device_units.clone().into();
                    let arg_physical_size_device_units = &mut arg_physical_size_device_units;
                    let mut arg_printable_area_device_units: _cef_rect_t =
                        arg_printable_area_device_units.clone().into();
                    let arg_printable_area_device_units = &mut arg_printable_area_device_units;
                    let arg_landscape_needs_flip = arg_landscape_needs_flip;
                    let result = f(
                        arg_self_,
                        arg_physical_size_device_units,
                        arg_printable_area_device_units,
                        arg_landscape_needs_flip,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_device_name<'a>(&self, name: &'a CefStringUtf16) {
        unsafe {
            self.0
                .set_device_name
                .map(|f| {
                    let arg_name = name;
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.as_raw();
                    let result = f(arg_self_, arg_name);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_device_name<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_device_name
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_dpi<'a>(&self, dpi: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_dpi
                .map(|f| {
                    let arg_dpi = dpi;
                    let arg_self_ = self.as_raw();
                    let arg_dpi = arg_dpi;
                    let result = f(arg_self_, arg_dpi);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_dpi<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_dpi
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_page_ranges<'a>(&self, ranges_count: usize, ranges: &'a Range) {
        unsafe {
            self.0
                .set_page_ranges
                .map(|f| {
                    let (arg_ranges_count, arg_ranges) = (ranges_count, ranges);
                    let arg_self_ = self.as_raw();
                    let arg_ranges_count = arg_ranges_count;
                    let mut arg_ranges: _cef_range_t = arg_ranges.clone().into();
                    let arg_ranges = &mut arg_ranges;
                    let result = f(arg_self_, arg_ranges_count, arg_ranges);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_page_ranges_count<'a>(&self) -> usize {
        unsafe {
            self.0
                .get_page_ranges_count
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_page_ranges<'a>(&self, ranges_count: *mut usize, ranges: &'a mut Range) {
        unsafe {
            self.0
                .get_page_ranges
                .map(|f| {
                    let (arg_ranges_count, arg_ranges) = (ranges_count, ranges);
                    let arg_self_ = self.as_raw();
                    let arg_ranges_count = arg_ranges_count as *mut _;
                    let mut arg_ranges: _cef_range_t = arg_ranges.clone().into();
                    let arg_ranges = &mut arg_ranges;
                    let result = f(arg_self_, arg_ranges_count, arg_ranges);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_selection_only<'a>(&self, selection_only: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_selection_only
                .map(|f| {
                    let arg_selection_only = selection_only;
                    let arg_self_ = self.as_raw();
                    let arg_selection_only = arg_selection_only;
                    let result = f(arg_self_, arg_selection_only);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_selection_only<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_selection_only
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_collate<'a>(&self, collate: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_collate
                .map(|f| {
                    let arg_collate = collate;
                    let arg_self_ = self.as_raw();
                    let arg_collate = arg_collate;
                    let result = f(arg_self_, arg_collate);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn will_collate<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .will_collate
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_color_model<'a>(&self, model: ColorModel) {
        unsafe {
            self.0
                .set_color_model
                .map(|f| {
                    let arg_model = model;
                    let arg_self_ = self.as_raw();
                    let arg_model = arg_model.as_raw();
                    let result = f(arg_self_, arg_model);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_color_model<'a>(&self) -> ColorModel {
        unsafe {
            self.0
                .get_color_model
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_copies<'a>(&self, copies: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_copies
                .map(|f| {
                    let arg_copies = copies;
                    let arg_self_ = self.as_raw();
                    let arg_copies = arg_copies;
                    let result = f(arg_self_, arg_copies);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_copies<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_copies
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_duplex_mode<'a>(&self, mode: DuplexMode) {
        unsafe {
            self.0
                .set_duplex_mode
                .map(|f| {
                    let arg_mode = mode;
                    let arg_self_ = self.as_raw();
                    let arg_mode = arg_mode.as_raw();
                    let result = f(arg_self_, arg_mode);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_duplex_mode<'a>(&self) -> DuplexMode {
        unsafe {
            self.0
                .get_duplex_mode
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_print_settings_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for PrintSettings {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_print_settings_t> for &PrintSettings {
    fn as_raw(self) -> *mut _cef_print_settings_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_print_settings_t> for &mut PrintSettings {
    fn as_raw(self) -> *mut _cef_print_settings_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<PrintSettings> for *mut _cef_print_settings_t {
    fn as_wrapper(self) -> PrintSettings {
        PrintSettings(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_print_settings_t> for PrintSettings {
    fn into(self) -> *mut _cef_print_settings_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for PrintSettings {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplPrintDialogCallback: Sized {
    fn cont<'a>(&self, settings: &'a mut PrintSettings) {
        unsafe { std::mem::zeroed() }
    }
    fn cancel<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_print_dialog_callback_t {
        let mut object: _cef_print_dialog_callback_t = unsafe { std::mem::zeroed() };
        impl_cef_print_dialog_callback_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_print_dialog_callback_t {
    use super::*;
    pub fn init_methods<I: ImplPrintDialogCallback>(object: &mut _cef_print_dialog_callback_t) {
        object.cont = Some(cont::<I>);
        object.cancel = Some(cancel::<I>);
    }
    extern "C" fn cont<I: ImplPrintDialogCallback>(
        self_: *mut _cef_print_dialog_callback_t,
        settings: *mut _cef_print_settings_t,
    ) {
        let (arg_self_, arg_settings) = (self_, settings);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_settings = &mut PrintSettings(unsafe { RefGuard::from_raw_add_ref(arg_settings) });
        arg_self_.interface.cont(arg_settings)
    }
    extern "C" fn cancel<I: ImplPrintDialogCallback>(self_: *mut _cef_print_dialog_callback_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.cancel()
    }
}
#[doc = "See [_cef_print_dialog_callback_t] for more documentation."]
#[derive(Clone)]
pub struct PrintDialogCallback(RefGuard<_cef_print_dialog_callback_t>);
impl ImplPrintDialogCallback for PrintDialogCallback {
    fn cont<'a>(&self, settings: &'a mut PrintSettings) {
        unsafe {
            self.0
                .cont
                .map(|f| {
                    let arg_settings = settings;
                    let arg_self_ = self.as_raw();
                    let arg_settings = arg_settings.as_raw();
                    let result = f(arg_self_, arg_settings);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn cancel<'a>(&self) {
        unsafe {
            self.0
                .cancel
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_print_dialog_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for PrintDialogCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_print_dialog_callback_t> for &PrintDialogCallback {
    fn as_raw(self) -> *mut _cef_print_dialog_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_print_dialog_callback_t> for &mut PrintDialogCallback {
    fn as_raw(self) -> *mut _cef_print_dialog_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<PrintDialogCallback> for *mut _cef_print_dialog_callback_t {
    fn as_wrapper(self) -> PrintDialogCallback {
        PrintDialogCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_print_dialog_callback_t> for PrintDialogCallback {
    fn into(self) -> *mut _cef_print_dialog_callback_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for PrintDialogCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplPrintJobCallback: Sized {
    fn cont<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_print_job_callback_t {
        let mut object: _cef_print_job_callback_t = unsafe { std::mem::zeroed() };
        impl_cef_print_job_callback_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_print_job_callback_t {
    use super::*;
    pub fn init_methods<I: ImplPrintJobCallback>(object: &mut _cef_print_job_callback_t) {
        object.cont = Some(cont::<I>);
    }
    extern "C" fn cont<I: ImplPrintJobCallback>(self_: *mut _cef_print_job_callback_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.cont()
    }
}
#[doc = "See [_cef_print_job_callback_t] for more documentation."]
#[derive(Clone)]
pub struct PrintJobCallback(RefGuard<_cef_print_job_callback_t>);
impl ImplPrintJobCallback for PrintJobCallback {
    fn cont<'a>(&self) {
        unsafe {
            self.0
                .cont
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_print_job_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for PrintJobCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_print_job_callback_t> for &PrintJobCallback {
    fn as_raw(self) -> *mut _cef_print_job_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_print_job_callback_t> for &mut PrintJobCallback {
    fn as_raw(self) -> *mut _cef_print_job_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<PrintJobCallback> for *mut _cef_print_job_callback_t {
    fn as_wrapper(self) -> PrintJobCallback {
        PrintJobCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_print_job_callback_t> for PrintJobCallback {
    fn into(self) -> *mut _cef_print_job_callback_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for PrintJobCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplPrintHandler: Sized {
    fn on_print_start<'a>(&self, browser: &'a mut Browser) {
        unsafe { std::mem::zeroed() }
    }
    fn on_print_settings<'a>(
        &self,
        browser: &'a mut Browser,
        settings: &'a mut PrintSettings,
        get_defaults: ::std::os::raw::c_int,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn on_print_dialog<'a>(
        &self,
        browser: &'a mut Browser,
        has_selection: ::std::os::raw::c_int,
        callback: &'a mut PrintDialogCallback,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn on_print_job<'a>(
        &self,
        browser: &'a mut Browser,
        document_name: &'a CefStringUtf16,
        pdf_file_path: &'a CefStringUtf16,
        callback: &'a mut PrintJobCallback,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn on_print_reset<'a>(&self, browser: &'a mut Browser) {
        unsafe { std::mem::zeroed() }
    }
    fn get_pdf_paper_size<'a>(
        &self,
        browser: &'a mut Browser,
        device_units_per_inch: ::std::os::raw::c_int,
    ) -> Size {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_print_handler_t {
        let mut object: _cef_print_handler_t = unsafe { std::mem::zeroed() };
        impl_cef_print_handler_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_print_handler_t {
    use super::*;
    pub fn init_methods<I: ImplPrintHandler>(object: &mut _cef_print_handler_t) {
        object.on_print_start = Some(on_print_start::<I>);
        object.on_print_settings = Some(on_print_settings::<I>);
        object.on_print_dialog = Some(on_print_dialog::<I>);
        object.on_print_job = Some(on_print_job::<I>);
        object.on_print_reset = Some(on_print_reset::<I>);
        object.get_pdf_paper_size = Some(get_pdf_paper_size::<I>);
    }
    extern "C" fn on_print_start<I: ImplPrintHandler>(
        self_: *mut _cef_print_handler_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        arg_self_.interface.on_print_start(arg_browser)
    }
    extern "C" fn on_print_settings<I: ImplPrintHandler>(
        self_: *mut _cef_print_handler_t,
        browser: *mut _cef_browser_t,
        settings: *mut _cef_print_settings_t,
        get_defaults: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_browser, arg_settings, arg_get_defaults) =
            (self_, browser, settings, get_defaults);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_settings = &mut PrintSettings(unsafe { RefGuard::from_raw_add_ref(arg_settings) });
        let arg_get_defaults = arg_get_defaults.as_raw();
        arg_self_
            .interface
            .on_print_settings(arg_browser, arg_settings, arg_get_defaults)
    }
    extern "C" fn on_print_dialog<I: ImplPrintHandler>(
        self_: *mut _cef_print_handler_t,
        browser: *mut _cef_browser_t,
        has_selection: ::std::os::raw::c_int,
        callback: *mut _cef_print_dialog_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_has_selection, arg_callback) =
            (self_, browser, has_selection, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_has_selection = arg_has_selection.as_raw();
        let arg_callback =
            &mut PrintDialogCallback(unsafe { RefGuard::from_raw_add_ref(arg_callback) });
        arg_self_
            .interface
            .on_print_dialog(arg_browser, arg_has_selection, arg_callback)
            .into()
    }
    extern "C" fn on_print_job<I: ImplPrintHandler>(
        self_: *mut _cef_print_handler_t,
        browser: *mut _cef_browser_t,
        document_name: *const _cef_string_utf16_t,
        pdf_file_path: *const _cef_string_utf16_t,
        callback: *mut _cef_print_job_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_document_name, arg_pdf_file_path, arg_callback) =
            (self_, browser, document_name, pdf_file_path, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_document_name = WrapParamRef::<CefStringUtf16>::from(arg_document_name);
        let arg_document_name = arg_document_name.as_ref();
        let arg_pdf_file_path = WrapParamRef::<CefStringUtf16>::from(arg_pdf_file_path);
        let arg_pdf_file_path = arg_pdf_file_path.as_ref();
        let arg_callback =
            &mut PrintJobCallback(unsafe { RefGuard::from_raw_add_ref(arg_callback) });
        arg_self_
            .interface
            .on_print_job(
                arg_browser,
                arg_document_name,
                arg_pdf_file_path,
                arg_callback,
            )
            .into()
    }
    extern "C" fn on_print_reset<I: ImplPrintHandler>(
        self_: *mut _cef_print_handler_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        arg_self_.interface.on_print_reset(arg_browser)
    }
    extern "C" fn get_pdf_paper_size<I: ImplPrintHandler>(
        self_: *mut _cef_print_handler_t,
        browser: *mut _cef_browser_t,
        device_units_per_inch: ::std::os::raw::c_int,
    ) -> _cef_size_t {
        let (arg_self_, arg_browser, arg_device_units_per_inch) =
            (self_, browser, device_units_per_inch);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_device_units_per_inch = arg_device_units_per_inch.as_raw();
        arg_self_
            .interface
            .get_pdf_paper_size(arg_browser, arg_device_units_per_inch)
            .into()
    }
}
#[doc = "See [_cef_print_handler_t] for more documentation."]
#[derive(Clone)]
pub struct PrintHandler(RefGuard<_cef_print_handler_t>);
impl ImplPrintHandler for PrintHandler {
    fn on_print_start<'a>(&self, browser: &'a mut Browser) {
        unsafe {
            self.0
                .on_print_start
                .map(|f| {
                    let arg_browser = browser;
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let result = f(arg_self_, arg_browser);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_print_settings<'a>(
        &self,
        browser: &'a mut Browser,
        settings: &'a mut PrintSettings,
        get_defaults: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .on_print_settings
                .map(|f| {
                    let (arg_browser, arg_settings, arg_get_defaults) =
                        (browser, settings, get_defaults);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_settings = arg_settings.as_raw();
                    let arg_get_defaults = arg_get_defaults;
                    let result = f(arg_self_, arg_browser, arg_settings, arg_get_defaults);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_print_dialog<'a>(
        &self,
        browser: &'a mut Browser,
        has_selection: ::std::os::raw::c_int,
        callback: &'a mut PrintDialogCallback,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_print_dialog
                .map(|f| {
                    let (arg_browser, arg_has_selection, arg_callback) =
                        (browser, has_selection, callback);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_has_selection = arg_has_selection;
                    let arg_callback = arg_callback.as_raw();
                    let result = f(arg_self_, arg_browser, arg_has_selection, arg_callback);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_print_job<'a>(
        &self,
        browser: &'a mut Browser,
        document_name: &'a CefStringUtf16,
        pdf_file_path: &'a CefStringUtf16,
        callback: &'a mut PrintJobCallback,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_print_job
                .map(|f| {
                    let (arg_browser, arg_document_name, arg_pdf_file_path, arg_callback) =
                        (browser, document_name, pdf_file_path, callback);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_document_name = arg_document_name.as_raw();
                    let arg_pdf_file_path = arg_pdf_file_path.as_raw();
                    let arg_callback = arg_callback.as_raw();
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_document_name,
                        arg_pdf_file_path,
                        arg_callback,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_print_reset<'a>(&self, browser: &'a mut Browser) {
        unsafe {
            self.0
                .on_print_reset
                .map(|f| {
                    let arg_browser = browser;
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let result = f(arg_self_, arg_browser);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_pdf_paper_size<'a>(
        &self,
        browser: &'a mut Browser,
        device_units_per_inch: ::std::os::raw::c_int,
    ) -> Size {
        unsafe {
            self.0
                .get_pdf_paper_size
                .map(|f| {
                    let (arg_browser, arg_device_units_per_inch) = (browser, device_units_per_inch);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_device_units_per_inch = arg_device_units_per_inch;
                    let result = f(arg_self_, arg_browser, arg_device_units_per_inch);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_print_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for PrintHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_print_handler_t> for &PrintHandler {
    fn as_raw(self) -> *mut _cef_print_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_print_handler_t> for &mut PrintHandler {
    fn as_raw(self) -> *mut _cef_print_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<PrintHandler> for *mut _cef_print_handler_t {
    fn as_wrapper(self) -> PrintHandler {
        PrintHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_print_handler_t> for PrintHandler {
    fn into(self) -> *mut _cef_print_handler_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for PrintHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplAccessibilityHandler: Sized {
    fn on_accessibility_tree_change<'a>(&self, value: &'a mut Value) {
        unsafe { std::mem::zeroed() }
    }
    fn on_accessibility_location_change<'a>(&self, value: &'a mut Value) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_accessibility_handler_t {
        let mut object: _cef_accessibility_handler_t = unsafe { std::mem::zeroed() };
        impl_cef_accessibility_handler_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_accessibility_handler_t {
    use super::*;
    pub fn init_methods<I: ImplAccessibilityHandler>(object: &mut _cef_accessibility_handler_t) {
        object.on_accessibility_tree_change = Some(on_accessibility_tree_change::<I>);
        object.on_accessibility_location_change = Some(on_accessibility_location_change::<I>);
    }
    extern "C" fn on_accessibility_tree_change<I: ImplAccessibilityHandler>(
        self_: *mut _cef_accessibility_handler_t,
        value: *mut _cef_value_t,
    ) {
        let (arg_self_, arg_value) = (self_, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_value = &mut Value(unsafe { RefGuard::from_raw_add_ref(arg_value) });
        arg_self_.interface.on_accessibility_tree_change(arg_value)
    }
    extern "C" fn on_accessibility_location_change<I: ImplAccessibilityHandler>(
        self_: *mut _cef_accessibility_handler_t,
        value: *mut _cef_value_t,
    ) {
        let (arg_self_, arg_value) = (self_, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_value = &mut Value(unsafe { RefGuard::from_raw_add_ref(arg_value) });
        arg_self_
            .interface
            .on_accessibility_location_change(arg_value)
    }
}
#[doc = "See [_cef_accessibility_handler_t] for more documentation."]
#[derive(Clone)]
pub struct AccessibilityHandler(RefGuard<_cef_accessibility_handler_t>);
impl ImplAccessibilityHandler for AccessibilityHandler {
    fn on_accessibility_tree_change<'a>(&self, value: &'a mut Value) {
        unsafe {
            self.0
                .on_accessibility_tree_change
                .map(|f| {
                    let arg_value = value;
                    let arg_self_ = self.as_raw();
                    let arg_value = arg_value.as_raw();
                    let result = f(arg_self_, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_accessibility_location_change<'a>(&self, value: &'a mut Value) {
        unsafe {
            self.0
                .on_accessibility_location_change
                .map(|f| {
                    let arg_value = value;
                    let arg_self_ = self.as_raw();
                    let arg_value = arg_value.as_raw();
                    let result = f(arg_self_, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_accessibility_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for AccessibilityHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_accessibility_handler_t> for &AccessibilityHandler {
    fn as_raw(self) -> *mut _cef_accessibility_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_accessibility_handler_t> for &mut AccessibilityHandler {
    fn as_raw(self) -> *mut _cef_accessibility_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<AccessibilityHandler> for *mut _cef_accessibility_handler_t {
    fn as_wrapper(self) -> AccessibilityHandler {
        AccessibilityHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_accessibility_handler_t> for AccessibilityHandler {
    fn into(self) -> *mut _cef_accessibility_handler_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for AccessibilityHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplRenderHandler: Sized {
    fn get_accessibility_handler<'a>(&self) -> AccessibilityHandler {
        unsafe { std::mem::zeroed() }
    }
    fn get_root_screen_rect<'a>(
        &self,
        browser: &'a mut Browser,
        rect: &'a mut Rect,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_view_rect<'a>(&self, browser: &'a mut Browser, rect: &'a mut Rect) {
        unsafe { std::mem::zeroed() }
    }
    fn get_screen_point<'a>(
        &self,
        browser: &'a mut Browser,
        view_x: ::std::os::raw::c_int,
        view_y: ::std::os::raw::c_int,
        screen_x: *mut ::std::os::raw::c_int,
        screen_y: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_screen_info<'a>(
        &self,
        browser: &'a mut Browser,
        screen_info: &'a mut ScreenInfo,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn on_popup_show<'a>(&self, browser: &'a mut Browser, show: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn on_popup_size<'a>(&self, browser: &'a mut Browser, rect: &'a Rect) {
        unsafe { std::mem::zeroed() }
    }
    fn on_paint<'a>(
        &self,
        browser: &'a mut Browser,
        type_: PaintElementType,
        dirty_rects_count: usize,
        dirty_rects: &'a Rect,
        buffer: *const ::std::os::raw::c_void,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn on_accelerated_paint<'a>(
        &self,
        browser: &'a mut Browser,
        type_: PaintElementType,
        dirty_rects_count: usize,
        dirty_rects: &'a Rect,
        info: &'a AcceleratedPaintInfo,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn get_touch_handle_size<'a>(
        &self,
        browser: &'a mut Browser,
        orientation: HorizontalAlignment,
        size: &'a mut Size,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn on_touch_handle_state_changed<'a>(
        &self,
        browser: &'a mut Browser,
        state: &'a TouchHandleState,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn start_dragging<'a>(
        &self,
        browser: &'a mut Browser,
        drag_data: &'a mut DragData,
        allowed_ops: DragOperationsMask,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn update_drag_cursor<'a>(&self, browser: &'a mut Browser, operation: DragOperationsMask) {
        unsafe { std::mem::zeroed() }
    }
    fn on_scroll_offset_changed<'a>(&self, browser: &'a mut Browser, x: f64, y: f64) {
        unsafe { std::mem::zeroed() }
    }
    fn on_ime_composition_range_changed<'a>(
        &self,
        browser: &'a mut Browser,
        selected_range: &'a Range,
        character_bounds_count: usize,
        character_bounds: &'a Rect,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn on_text_selection_changed<'a>(
        &self,
        browser: &'a mut Browser,
        selected_text: &'a CefStringUtf16,
        selected_range: &'a Range,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn on_virtual_keyboard_requested<'a>(
        &self,
        browser: &'a mut Browser,
        input_mode: TextInputMode,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_render_handler_t {
        let mut object: _cef_render_handler_t = unsafe { std::mem::zeroed() };
        impl_cef_render_handler_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_render_handler_t {
    use super::*;
    pub fn init_methods<I: ImplRenderHandler>(object: &mut _cef_render_handler_t) {
        object.get_accessibility_handler = Some(get_accessibility_handler::<I>);
        object.get_root_screen_rect = Some(get_root_screen_rect::<I>);
        object.get_view_rect = Some(get_view_rect::<I>);
        object.get_screen_point = Some(get_screen_point::<I>);
        object.get_screen_info = Some(get_screen_info::<I>);
        object.on_popup_show = Some(on_popup_show::<I>);
        object.on_popup_size = Some(on_popup_size::<I>);
        object.on_paint = Some(on_paint::<I>);
        object.on_accelerated_paint = Some(on_accelerated_paint::<I>);
        object.get_touch_handle_size = Some(get_touch_handle_size::<I>);
        object.on_touch_handle_state_changed = Some(on_touch_handle_state_changed::<I>);
        object.start_dragging = Some(start_dragging::<I>);
        object.update_drag_cursor = Some(update_drag_cursor::<I>);
        object.on_scroll_offset_changed = Some(on_scroll_offset_changed::<I>);
        object.on_ime_composition_range_changed = Some(on_ime_composition_range_changed::<I>);
        object.on_text_selection_changed = Some(on_text_selection_changed::<I>);
        object.on_virtual_keyboard_requested = Some(on_virtual_keyboard_requested::<I>);
    }
    extern "C" fn get_accessibility_handler<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
    ) -> *mut _cef_accessibility_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_accessibility_handler().into()
    }
    extern "C" fn get_root_screen_rect<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        rect: *mut _cef_rect_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_rect) = (self_, browser, rect);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let mut arg_rect = WrapParamRef::<Rect>::from(arg_rect);
        let arg_rect = arg_rect.as_mut();
        arg_self_
            .interface
            .get_root_screen_rect(arg_browser, arg_rect)
            .into()
    }
    extern "C" fn get_view_rect<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        rect: *mut _cef_rect_t,
    ) {
        let (arg_self_, arg_browser, arg_rect) = (self_, browser, rect);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let mut arg_rect = WrapParamRef::<Rect>::from(arg_rect);
        let arg_rect = arg_rect.as_mut();
        arg_self_.interface.get_view_rect(arg_browser, arg_rect)
    }
    extern "C" fn get_screen_point<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        view_x: ::std::os::raw::c_int,
        view_y: ::std::os::raw::c_int,
        screen_x: *mut ::std::os::raw::c_int,
        screen_y: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_view_x, arg_view_y, arg_screen_x, arg_screen_y) =
            (self_, browser, view_x, view_y, screen_x, screen_y);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_view_x = arg_view_x.as_raw();
        let arg_view_y = arg_view_y.as_raw();
        let mut arg_screen_x = WrapParamRef::<::std::os::raw::c_int>::from(arg_screen_x);
        let arg_screen_x = arg_screen_x.as_mut();
        let mut arg_screen_y = WrapParamRef::<::std::os::raw::c_int>::from(arg_screen_y);
        let arg_screen_y = arg_screen_y.as_mut();
        arg_self_
            .interface
            .get_screen_point(
                arg_browser,
                arg_view_x,
                arg_view_y,
                arg_screen_x,
                arg_screen_y,
            )
            .into()
    }
    extern "C" fn get_screen_info<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        screen_info: *mut _cef_screen_info_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_screen_info) = (self_, browser, screen_info);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let mut arg_screen_info = WrapParamRef::<ScreenInfo>::from(arg_screen_info);
        let arg_screen_info = arg_screen_info.as_mut();
        arg_self_
            .interface
            .get_screen_info(arg_browser, arg_screen_info)
            .into()
    }
    extern "C" fn on_popup_show<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        show: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_browser, arg_show) = (self_, browser, show);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_show = arg_show.as_raw();
        arg_self_.interface.on_popup_show(arg_browser, arg_show)
    }
    extern "C" fn on_popup_size<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        rect: *const _cef_rect_t,
    ) {
        let (arg_self_, arg_browser, arg_rect) = (self_, browser, rect);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_rect = WrapParamRef::<Rect>::from(arg_rect);
        let arg_rect = arg_rect.as_ref();
        arg_self_.interface.on_popup_size(arg_browser, arg_rect)
    }
    extern "C" fn on_paint<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        type_: cef_paint_element_type_t,
        dirty_rects_count: usize,
        dirty_rects: *const _cef_rect_t,
        buffer: *const ::std::os::raw::c_void,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) {
        let (
            arg_self_,
            arg_browser,
            arg_type_,
            arg_dirty_rects_count,
            arg_dirty_rects,
            arg_buffer,
            arg_width,
            arg_height,
        ) = (
            self_,
            browser,
            type_,
            dirty_rects_count,
            dirty_rects,
            buffer,
            width,
            height,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_type_ = arg_type_.as_raw();
        let arg_dirty_rects_count = arg_dirty_rects_count.as_raw();
        let arg_dirty_rects = WrapParamRef::<Rect>::from(arg_dirty_rects);
        let arg_dirty_rects = arg_dirty_rects.as_ref();
        let arg_width = arg_width.as_raw();
        let arg_height = arg_height.as_raw();
        arg_self_.interface.on_paint(
            arg_browser,
            arg_type_,
            arg_dirty_rects_count,
            arg_dirty_rects,
            arg_buffer,
            arg_width,
            arg_height,
        )
    }
    extern "C" fn on_accelerated_paint<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        type_: cef_paint_element_type_t,
        dirty_rects_count: usize,
        dirty_rects: *const _cef_rect_t,
        info: *const _cef_accelerated_paint_info_t,
    ) {
        let (arg_self_, arg_browser, arg_type_, arg_dirty_rects_count, arg_dirty_rects, arg_info) =
            (self_, browser, type_, dirty_rects_count, dirty_rects, info);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_type_ = arg_type_.as_raw();
        let arg_dirty_rects_count = arg_dirty_rects_count.as_raw();
        let arg_dirty_rects = WrapParamRef::<Rect>::from(arg_dirty_rects);
        let arg_dirty_rects = arg_dirty_rects.as_ref();
        let arg_info = WrapParamRef::<AcceleratedPaintInfo>::from(arg_info);
        let arg_info = arg_info.as_ref();
        arg_self_.interface.on_accelerated_paint(
            arg_browser,
            arg_type_,
            arg_dirty_rects_count,
            arg_dirty_rects,
            arg_info,
        )
    }
    extern "C" fn get_touch_handle_size<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        orientation: cef_horizontal_alignment_t,
        size: *mut _cef_size_t,
    ) {
        let (arg_self_, arg_browser, arg_orientation, arg_size) =
            (self_, browser, orientation, size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_orientation = arg_orientation.as_raw();
        let mut arg_size = WrapParamRef::<Size>::from(arg_size);
        let arg_size = arg_size.as_mut();
        arg_self_
            .interface
            .get_touch_handle_size(arg_browser, arg_orientation, arg_size)
    }
    extern "C" fn on_touch_handle_state_changed<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        state: *const _cef_touch_handle_state_t,
    ) {
        let (arg_self_, arg_browser, arg_state) = (self_, browser, state);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_state = WrapParamRef::<TouchHandleState>::from(arg_state);
        let arg_state = arg_state.as_ref();
        arg_self_
            .interface
            .on_touch_handle_state_changed(arg_browser, arg_state)
    }
    extern "C" fn start_dragging<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        drag_data: *mut _cef_drag_data_t,
        allowed_ops: cef_drag_operations_mask_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_drag_data, arg_allowed_ops, arg_x, arg_y) =
            (self_, browser, drag_data, allowed_ops, x, y);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_drag_data = &mut DragData(unsafe { RefGuard::from_raw_add_ref(arg_drag_data) });
        let arg_allowed_ops = arg_allowed_ops.as_raw();
        let arg_x = arg_x.as_raw();
        let arg_y = arg_y.as_raw();
        arg_self_
            .interface
            .start_dragging(arg_browser, arg_drag_data, arg_allowed_ops, arg_x, arg_y)
            .into()
    }
    extern "C" fn update_drag_cursor<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        operation: cef_drag_operations_mask_t,
    ) {
        let (arg_self_, arg_browser, arg_operation) = (self_, browser, operation);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_operation = arg_operation.as_raw();
        arg_self_
            .interface
            .update_drag_cursor(arg_browser, arg_operation)
    }
    extern "C" fn on_scroll_offset_changed<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        x: f64,
        y: f64,
    ) {
        let (arg_self_, arg_browser, arg_x, arg_y) = (self_, browser, x, y);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_x = arg_x.as_raw();
        let arg_y = arg_y.as_raw();
        arg_self_
            .interface
            .on_scroll_offset_changed(arg_browser, arg_x, arg_y)
    }
    extern "C" fn on_ime_composition_range_changed<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        selected_range: *const _cef_range_t,
        character_bounds_count: usize,
        character_bounds: *const _cef_rect_t,
    ) {
        let (
            arg_self_,
            arg_browser,
            arg_selected_range,
            arg_character_bounds_count,
            arg_character_bounds,
        ) = (
            self_,
            browser,
            selected_range,
            character_bounds_count,
            character_bounds,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_selected_range = WrapParamRef::<Range>::from(arg_selected_range);
        let arg_selected_range = arg_selected_range.as_ref();
        let arg_character_bounds_count = arg_character_bounds_count.as_raw();
        let arg_character_bounds = WrapParamRef::<Rect>::from(arg_character_bounds);
        let arg_character_bounds = arg_character_bounds.as_ref();
        arg_self_.interface.on_ime_composition_range_changed(
            arg_browser,
            arg_selected_range,
            arg_character_bounds_count,
            arg_character_bounds,
        )
    }
    extern "C" fn on_text_selection_changed<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        selected_text: *const _cef_string_utf16_t,
        selected_range: *const _cef_range_t,
    ) {
        let (arg_self_, arg_browser, arg_selected_text, arg_selected_range) =
            (self_, browser, selected_text, selected_range);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_selected_text = WrapParamRef::<CefStringUtf16>::from(arg_selected_text);
        let arg_selected_text = arg_selected_text.as_ref();
        let arg_selected_range = WrapParamRef::<Range>::from(arg_selected_range);
        let arg_selected_range = arg_selected_range.as_ref();
        arg_self_.interface.on_text_selection_changed(
            arg_browser,
            arg_selected_text,
            arg_selected_range,
        )
    }
    extern "C" fn on_virtual_keyboard_requested<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        input_mode: cef_text_input_mode_t,
    ) {
        let (arg_self_, arg_browser, arg_input_mode) = (self_, browser, input_mode);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_input_mode = arg_input_mode.as_raw();
        arg_self_
            .interface
            .on_virtual_keyboard_requested(arg_browser, arg_input_mode)
    }
}
#[doc = "See [_cef_render_handler_t] for more documentation."]
#[derive(Clone)]
pub struct RenderHandler(RefGuard<_cef_render_handler_t>);
impl ImplRenderHandler for RenderHandler {
    fn get_accessibility_handler<'a>(&self) -> AccessibilityHandler {
        unsafe {
            self.0
                .get_accessibility_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_root_screen_rect<'a>(
        &self,
        browser: &'a mut Browser,
        rect: &'a mut Rect,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_root_screen_rect
                .map(|f| {
                    let (arg_browser, arg_rect) = (browser, rect);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let mut arg_rect: _cef_rect_t = arg_rect.clone().into();
                    let arg_rect = &mut arg_rect;
                    let result = f(arg_self_, arg_browser, arg_rect);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_view_rect<'a>(&self, browser: &'a mut Browser, rect: &'a mut Rect) {
        unsafe {
            self.0
                .get_view_rect
                .map(|f| {
                    let (arg_browser, arg_rect) = (browser, rect);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let mut arg_rect: _cef_rect_t = arg_rect.clone().into();
                    let arg_rect = &mut arg_rect;
                    let result = f(arg_self_, arg_browser, arg_rect);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_screen_point<'a>(
        &self,
        browser: &'a mut Browser,
        view_x: ::std::os::raw::c_int,
        view_y: ::std::os::raw::c_int,
        screen_x: *mut ::std::os::raw::c_int,
        screen_y: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_screen_point
                .map(|f| {
                    let (arg_browser, arg_view_x, arg_view_y, arg_screen_x, arg_screen_y) =
                        (browser, view_x, view_y, screen_x, screen_y);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_view_x = arg_view_x;
                    let arg_view_y = arg_view_y;
                    let arg_screen_x = arg_screen_x as *mut _;
                    let arg_screen_y = arg_screen_y as *mut _;
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_view_x,
                        arg_view_y,
                        arg_screen_x,
                        arg_screen_y,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_screen_info<'a>(
        &self,
        browser: &'a mut Browser,
        screen_info: &'a mut ScreenInfo,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_screen_info
                .map(|f| {
                    let (arg_browser, arg_screen_info) = (browser, screen_info);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let mut arg_screen_info: _cef_screen_info_t = arg_screen_info.clone().into();
                    let arg_screen_info = &mut arg_screen_info;
                    let result = f(arg_self_, arg_browser, arg_screen_info);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_popup_show<'a>(&self, browser: &'a mut Browser, show: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .on_popup_show
                .map(|f| {
                    let (arg_browser, arg_show) = (browser, show);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_show = arg_show;
                    let result = f(arg_self_, arg_browser, arg_show);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_popup_size<'a>(&self, browser: &'a mut Browser, rect: &'a Rect) {
        unsafe {
            self.0
                .on_popup_size
                .map(|f| {
                    let (arg_browser, arg_rect) = (browser, rect);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let mut arg_rect: _cef_rect_t = arg_rect.clone().into();
                    let arg_rect = &mut arg_rect;
                    let result = f(arg_self_, arg_browser, arg_rect);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_paint<'a>(
        &self,
        browser: &'a mut Browser,
        type_: PaintElementType,
        dirty_rects_count: usize,
        dirty_rects: &'a Rect,
        buffer: *const ::std::os::raw::c_void,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .on_paint
                .map(|f| {
                    let (
                        arg_browser,
                        arg_type_,
                        arg_dirty_rects_count,
                        arg_dirty_rects,
                        arg_buffer,
                        arg_width,
                        arg_height,
                    ) = (
                        browser,
                        type_,
                        dirty_rects_count,
                        dirty_rects,
                        buffer,
                        width,
                        height,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_type_ = arg_type_.as_raw();
                    let arg_dirty_rects_count = arg_dirty_rects_count;
                    let mut arg_dirty_rects: _cef_rect_t = arg_dirty_rects.clone().into();
                    let arg_dirty_rects = &mut arg_dirty_rects;
                    let arg_buffer = arg_buffer as *const _;
                    let arg_width = arg_width;
                    let arg_height = arg_height;
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_type_,
                        arg_dirty_rects_count,
                        arg_dirty_rects,
                        arg_buffer,
                        arg_width,
                        arg_height,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_accelerated_paint<'a>(
        &self,
        browser: &'a mut Browser,
        type_: PaintElementType,
        dirty_rects_count: usize,
        dirty_rects: &'a Rect,
        info: &'a AcceleratedPaintInfo,
    ) {
        unsafe {
            self.0
                .on_accelerated_paint
                .map(|f| {
                    let (arg_browser, arg_type_, arg_dirty_rects_count, arg_dirty_rects, arg_info) =
                        (browser, type_, dirty_rects_count, dirty_rects, info);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_type_ = arg_type_.as_raw();
                    let arg_dirty_rects_count = arg_dirty_rects_count;
                    let mut arg_dirty_rects: _cef_rect_t = arg_dirty_rects.clone().into();
                    let arg_dirty_rects = &mut arg_dirty_rects;
                    let mut arg_info: _cef_accelerated_paint_info_t = arg_info.clone().into();
                    let arg_info = &mut arg_info;
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_type_,
                        arg_dirty_rects_count,
                        arg_dirty_rects,
                        arg_info,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_touch_handle_size<'a>(
        &self,
        browser: &'a mut Browser,
        orientation: HorizontalAlignment,
        size: &'a mut Size,
    ) {
        unsafe {
            self.0
                .get_touch_handle_size
                .map(|f| {
                    let (arg_browser, arg_orientation, arg_size) = (browser, orientation, size);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_orientation = arg_orientation.as_raw();
                    let mut arg_size: _cef_size_t = arg_size.clone().into();
                    let arg_size = &mut arg_size;
                    let result = f(arg_self_, arg_browser, arg_orientation, arg_size);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_touch_handle_state_changed<'a>(
        &self,
        browser: &'a mut Browser,
        state: &'a TouchHandleState,
    ) {
        unsafe {
            self.0
                .on_touch_handle_state_changed
                .map(|f| {
                    let (arg_browser, arg_state) = (browser, state);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let mut arg_state: _cef_touch_handle_state_t = arg_state.clone().into();
                    let arg_state = &mut arg_state;
                    let result = f(arg_self_, arg_browser, arg_state);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn start_dragging<'a>(
        &self,
        browser: &'a mut Browser,
        drag_data: &'a mut DragData,
        allowed_ops: DragOperationsMask,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .start_dragging
                .map(|f| {
                    let (arg_browser, arg_drag_data, arg_allowed_ops, arg_x, arg_y) =
                        (browser, drag_data, allowed_ops, x, y);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_drag_data = arg_drag_data.as_raw();
                    let arg_allowed_ops = arg_allowed_ops.as_raw();
                    let arg_x = arg_x;
                    let arg_y = arg_y;
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_drag_data,
                        arg_allowed_ops,
                        arg_x,
                        arg_y,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn update_drag_cursor<'a>(&self, browser: &'a mut Browser, operation: DragOperationsMask) {
        unsafe {
            self.0
                .update_drag_cursor
                .map(|f| {
                    let (arg_browser, arg_operation) = (browser, operation);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_operation = arg_operation.as_raw();
                    let result = f(arg_self_, arg_browser, arg_operation);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_scroll_offset_changed<'a>(&self, browser: &'a mut Browser, x: f64, y: f64) {
        unsafe {
            self.0
                .on_scroll_offset_changed
                .map(|f| {
                    let (arg_browser, arg_x, arg_y) = (browser, x, y);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_x = arg_x;
                    let arg_y = arg_y;
                    let result = f(arg_self_, arg_browser, arg_x, arg_y);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_ime_composition_range_changed<'a>(
        &self,
        browser: &'a mut Browser,
        selected_range: &'a Range,
        character_bounds_count: usize,
        character_bounds: &'a Rect,
    ) {
        unsafe {
            self.0
                .on_ime_composition_range_changed
                .map(|f| {
                    let (
                        arg_browser,
                        arg_selected_range,
                        arg_character_bounds_count,
                        arg_character_bounds,
                    ) = (
                        browser,
                        selected_range,
                        character_bounds_count,
                        character_bounds,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let mut arg_selected_range: _cef_range_t = arg_selected_range.clone().into();
                    let arg_selected_range = &mut arg_selected_range;
                    let arg_character_bounds_count = arg_character_bounds_count;
                    let mut arg_character_bounds: _cef_rect_t = arg_character_bounds.clone().into();
                    let arg_character_bounds = &mut arg_character_bounds;
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_selected_range,
                        arg_character_bounds_count,
                        arg_character_bounds,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_text_selection_changed<'a>(
        &self,
        browser: &'a mut Browser,
        selected_text: &'a CefStringUtf16,
        selected_range: &'a Range,
    ) {
        unsafe {
            self.0
                .on_text_selection_changed
                .map(|f| {
                    let (arg_browser, arg_selected_text, arg_selected_range) =
                        (browser, selected_text, selected_range);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_selected_text = arg_selected_text.as_raw();
                    let mut arg_selected_range: _cef_range_t = arg_selected_range.clone().into();
                    let arg_selected_range = &mut arg_selected_range;
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_selected_text,
                        arg_selected_range,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_virtual_keyboard_requested<'a>(
        &self,
        browser: &'a mut Browser,
        input_mode: TextInputMode,
    ) {
        unsafe {
            self.0
                .on_virtual_keyboard_requested
                .map(|f| {
                    let (arg_browser, arg_input_mode) = (browser, input_mode);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_input_mode = arg_input_mode.as_raw();
                    let result = f(arg_self_, arg_browser, arg_input_mode);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_render_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for RenderHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_render_handler_t> for &RenderHandler {
    fn as_raw(self) -> *mut _cef_render_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_render_handler_t> for &mut RenderHandler {
    fn as_raw(self) -> *mut _cef_render_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<RenderHandler> for *mut _cef_render_handler_t {
    fn as_wrapper(self) -> RenderHandler {
        RenderHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_render_handler_t> for RenderHandler {
    fn into(self) -> *mut _cef_render_handler_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for RenderHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplAuthCallback: Sized {
    fn cont<'a>(&self, username: &'a CefStringUtf16, password: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn cancel<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_auth_callback_t {
        let mut object: _cef_auth_callback_t = unsafe { std::mem::zeroed() };
        impl_cef_auth_callback_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_auth_callback_t {
    use super::*;
    pub fn init_methods<I: ImplAuthCallback>(object: &mut _cef_auth_callback_t) {
        object.cont = Some(cont::<I>);
        object.cancel = Some(cancel::<I>);
    }
    extern "C" fn cont<I: ImplAuthCallback>(
        self_: *mut _cef_auth_callback_t,
        username: *const _cef_string_utf16_t,
        password: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_username, arg_password) = (self_, username, password);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_username = WrapParamRef::<CefStringUtf16>::from(arg_username);
        let arg_username = arg_username.as_ref();
        let arg_password = WrapParamRef::<CefStringUtf16>::from(arg_password);
        let arg_password = arg_password.as_ref();
        arg_self_.interface.cont(arg_username, arg_password)
    }
    extern "C" fn cancel<I: ImplAuthCallback>(self_: *mut _cef_auth_callback_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.cancel()
    }
}
#[doc = "See [_cef_auth_callback_t] for more documentation."]
#[derive(Clone)]
pub struct AuthCallback(RefGuard<_cef_auth_callback_t>);
impl ImplAuthCallback for AuthCallback {
    fn cont<'a>(&self, username: &'a CefStringUtf16, password: &'a CefStringUtf16) {
        unsafe {
            self.0
                .cont
                .map(|f| {
                    let (arg_username, arg_password) = (username, password);
                    let arg_self_ = self.as_raw();
                    let arg_username = arg_username.as_raw();
                    let arg_password = arg_password.as_raw();
                    let result = f(arg_self_, arg_username, arg_password);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn cancel<'a>(&self) {
        unsafe {
            self.0
                .cancel
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_auth_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for AuthCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_auth_callback_t> for &AuthCallback {
    fn as_raw(self) -> *mut _cef_auth_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_auth_callback_t> for &mut AuthCallback {
    fn as_raw(self) -> *mut _cef_auth_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<AuthCallback> for *mut _cef_auth_callback_t {
    fn as_wrapper(self) -> AuthCallback {
        AuthCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_auth_callback_t> for AuthCallback {
    fn into(self) -> *mut _cef_auth_callback_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for AuthCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplResponse: Sized {
    fn is_read_only<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_error<'a>(&self) -> Errorcode {
        unsafe { std::mem::zeroed() }
    }
    fn set_error<'a>(&self, error: Errorcode) {
        unsafe { std::mem::zeroed() }
    }
    fn get_status<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_status<'a>(&self, status: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn get_status_text<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn set_status_text<'a>(&self, status_text: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn get_mime_type<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn set_mime_type<'a>(&self, mime_type: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn get_charset<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn set_charset<'a>(&self, charset: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn get_header_by_name<'a>(&self, name: &'a CefStringUtf16) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn set_header_by_name<'a>(
        &self,
        name: &'a CefStringUtf16,
        value: &'a CefStringUtf16,
        overwrite: ::std::os::raw::c_int,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn get_header_map<'a>(&self, header_map: &'a mut CefStringMultimap) {
        unsafe { std::mem::zeroed() }
    }
    fn set_header_map<'a>(&self, header_map: &'a mut CefStringMultimap) {
        unsafe { std::mem::zeroed() }
    }
    fn get_url<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn set_url<'a>(&self, url: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_response_t {
        let mut object: _cef_response_t = unsafe { std::mem::zeroed() };
        impl_cef_response_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_response_t {
    use super::*;
    pub fn init_methods<I: ImplResponse>(object: &mut _cef_response_t) {
        object.is_read_only = Some(is_read_only::<I>);
        object.get_error = Some(get_error::<I>);
        object.set_error = Some(set_error::<I>);
        object.get_status = Some(get_status::<I>);
        object.set_status = Some(set_status::<I>);
        object.get_status_text = Some(get_status_text::<I>);
        object.set_status_text = Some(set_status_text::<I>);
        object.get_mime_type = Some(get_mime_type::<I>);
        object.set_mime_type = Some(set_mime_type::<I>);
        object.get_charset = Some(get_charset::<I>);
        object.set_charset = Some(set_charset::<I>);
        object.get_header_by_name = Some(get_header_by_name::<I>);
        object.set_header_by_name = Some(set_header_by_name::<I>);
        object.get_header_map = Some(get_header_map::<I>);
        object.set_header_map = Some(set_header_map::<I>);
        object.get_url = Some(get_url::<I>);
        object.set_url = Some(set_url::<I>);
    }
    extern "C" fn is_read_only<I: ImplResponse>(
        self_: *mut _cef_response_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_read_only().into()
    }
    extern "C" fn get_error<I: ImplResponse>(self_: *mut _cef_response_t) -> cef_errorcode_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_error().into()
    }
    extern "C" fn set_error<I: ImplResponse>(self_: *mut _cef_response_t, error: cef_errorcode_t) {
        let (arg_self_, arg_error) = (self_, error);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_error = arg_error.as_raw();
        arg_self_.interface.set_error(arg_error)
    }
    extern "C" fn get_status<I: ImplResponse>(
        self_: *mut _cef_response_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_status().into()
    }
    extern "C" fn set_status<I: ImplResponse>(
        self_: *mut _cef_response_t,
        status: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_status) = (self_, status);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_status = arg_status.as_raw();
        arg_self_.interface.set_status(arg_status)
    }
    extern "C" fn get_status_text<I: ImplResponse>(
        self_: *mut _cef_response_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_status_text().into()
    }
    extern "C" fn set_status_text<I: ImplResponse>(
        self_: *mut _cef_response_t,
        status_text: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_status_text) = (self_, status_text);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_status_text = WrapParamRef::<CefStringUtf16>::from(arg_status_text);
        let arg_status_text = arg_status_text.as_ref();
        arg_self_.interface.set_status_text(arg_status_text)
    }
    extern "C" fn get_mime_type<I: ImplResponse>(
        self_: *mut _cef_response_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_mime_type().into()
    }
    extern "C" fn set_mime_type<I: ImplResponse>(
        self_: *mut _cef_response_t,
        mime_type: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_mime_type) = (self_, mime_type);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_mime_type = WrapParamRef::<CefStringUtf16>::from(arg_mime_type);
        let arg_mime_type = arg_mime_type.as_ref();
        arg_self_.interface.set_mime_type(arg_mime_type)
    }
    extern "C" fn get_charset<I: ImplResponse>(
        self_: *mut _cef_response_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_charset().into()
    }
    extern "C" fn set_charset<I: ImplResponse>(
        self_: *mut _cef_response_t,
        charset: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_charset) = (self_, charset);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_charset = WrapParamRef::<CefStringUtf16>::from(arg_charset);
        let arg_charset = arg_charset.as_ref();
        arg_self_.interface.set_charset(arg_charset)
    }
    extern "C" fn get_header_by_name<I: ImplResponse>(
        self_: *mut _cef_response_t,
        name: *const _cef_string_utf16_t,
    ) -> *mut _cef_string_utf16_t {
        let (arg_self_, arg_name) = (self_, name);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = WrapParamRef::<CefStringUtf16>::from(arg_name);
        let arg_name = arg_name.as_ref();
        arg_self_.interface.get_header_by_name(arg_name).into()
    }
    extern "C" fn set_header_by_name<I: ImplResponse>(
        self_: *mut _cef_response_t,
        name: *const _cef_string_utf16_t,
        value: *const _cef_string_utf16_t,
        overwrite: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_name, arg_value, arg_overwrite) = (self_, name, value, overwrite);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = WrapParamRef::<CefStringUtf16>::from(arg_name);
        let arg_name = arg_name.as_ref();
        let arg_value = WrapParamRef::<CefStringUtf16>::from(arg_value);
        let arg_value = arg_value.as_ref();
        let arg_overwrite = arg_overwrite.as_raw();
        arg_self_
            .interface
            .set_header_by_name(arg_name, arg_value, arg_overwrite)
    }
    extern "C" fn get_header_map<I: ImplResponse>(
        self_: *mut _cef_response_t,
        header_map: *mut _cef_string_multimap_t,
    ) {
        let (arg_self_, arg_header_map) = (self_, header_map);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_header_map = WrapParamRef::<CefStringMultimap>::from(arg_header_map);
        let arg_header_map = arg_header_map.as_mut();
        arg_self_.interface.get_header_map(arg_header_map)
    }
    extern "C" fn set_header_map<I: ImplResponse>(
        self_: *mut _cef_response_t,
        header_map: *mut _cef_string_multimap_t,
    ) {
        let (arg_self_, arg_header_map) = (self_, header_map);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_header_map = WrapParamRef::<CefStringMultimap>::from(arg_header_map);
        let arg_header_map = arg_header_map.as_mut();
        arg_self_.interface.set_header_map(arg_header_map)
    }
    extern "C" fn get_url<I: ImplResponse>(
        self_: *mut _cef_response_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_url().into()
    }
    extern "C" fn set_url<I: ImplResponse>(
        self_: *mut _cef_response_t,
        url: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_url) = (self_, url);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_url = WrapParamRef::<CefStringUtf16>::from(arg_url);
        let arg_url = arg_url.as_ref();
        arg_self_.interface.set_url(arg_url)
    }
}
#[doc = "See [_cef_response_t] for more documentation."]
#[derive(Clone)]
pub struct Response(RefGuard<_cef_response_t>);
impl ImplResponse for Response {
    fn is_read_only<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_read_only
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_error<'a>(&self) -> Errorcode {
        unsafe {
            self.0
                .get_error
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_error<'a>(&self, error: Errorcode) {
        unsafe {
            self.0
                .set_error
                .map(|f| {
                    let arg_error = error;
                    let arg_self_ = self.as_raw();
                    let arg_error = arg_error.as_raw();
                    let result = f(arg_self_, arg_error);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_status<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_status
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_status<'a>(&self, status: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_status
                .map(|f| {
                    let arg_status = status;
                    let arg_self_ = self.as_raw();
                    let arg_status = arg_status;
                    let result = f(arg_self_, arg_status);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_status_text<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_status_text
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_status_text<'a>(&self, status_text: &'a CefStringUtf16) {
        unsafe {
            self.0
                .set_status_text
                .map(|f| {
                    let arg_status_text = status_text;
                    let arg_self_ = self.as_raw();
                    let arg_status_text = arg_status_text.as_raw();
                    let result = f(arg_self_, arg_status_text);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_mime_type<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_mime_type
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_mime_type<'a>(&self, mime_type: &'a CefStringUtf16) {
        unsafe {
            self.0
                .set_mime_type
                .map(|f| {
                    let arg_mime_type = mime_type;
                    let arg_self_ = self.as_raw();
                    let arg_mime_type = arg_mime_type.as_raw();
                    let result = f(arg_self_, arg_mime_type);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_charset<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_charset
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_charset<'a>(&self, charset: &'a CefStringUtf16) {
        unsafe {
            self.0
                .set_charset
                .map(|f| {
                    let arg_charset = charset;
                    let arg_self_ = self.as_raw();
                    let arg_charset = arg_charset.as_raw();
                    let result = f(arg_self_, arg_charset);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_header_by_name<'a>(&self, name: &'a CefStringUtf16) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_header_by_name
                .map(|f| {
                    let arg_name = name;
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.as_raw();
                    let result = f(arg_self_, arg_name);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_header_by_name<'a>(
        &self,
        name: &'a CefStringUtf16,
        value: &'a CefStringUtf16,
        overwrite: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .set_header_by_name
                .map(|f| {
                    let (arg_name, arg_value, arg_overwrite) = (name, value, overwrite);
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.as_raw();
                    let arg_value = arg_value.as_raw();
                    let arg_overwrite = arg_overwrite;
                    let result = f(arg_self_, arg_name, arg_value, arg_overwrite);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_header_map<'a>(&self, header_map: &'a mut CefStringMultimap) {
        unsafe {
            self.0
                .get_header_map
                .map(|f| {
                    let arg_header_map = header_map;
                    let arg_self_ = self.as_raw();
                    let arg_header_map = arg_header_map.as_raw();
                    let result = f(arg_self_, arg_header_map);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_header_map<'a>(&self, header_map: &'a mut CefStringMultimap) {
        unsafe {
            self.0
                .set_header_map
                .map(|f| {
                    let arg_header_map = header_map;
                    let arg_self_ = self.as_raw();
                    let arg_header_map = arg_header_map.as_raw();
                    let result = f(arg_self_, arg_header_map);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_url<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_url
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_url<'a>(&self, url: &'a CefStringUtf16) {
        unsafe {
            self.0
                .set_url
                .map(|f| {
                    let arg_url = url;
                    let arg_self_ = self.as_raw();
                    let arg_url = arg_url.as_raw();
                    let result = f(arg_self_, arg_url);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_response_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Response {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_response_t> for &Response {
    fn as_raw(self) -> *mut _cef_response_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_response_t> for &mut Response {
    fn as_raw(self) -> *mut _cef_response_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<Response> for *mut _cef_response_t {
    fn as_wrapper(self) -> Response {
        Response(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_response_t> for Response {
    fn into(self) -> *mut _cef_response_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for Response {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplResourceSkipCallback: Sized {
    fn cont<'a>(&self, bytes_skipped: i64) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_resource_skip_callback_t {
        let mut object: _cef_resource_skip_callback_t = unsafe { std::mem::zeroed() };
        impl_cef_resource_skip_callback_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_resource_skip_callback_t {
    use super::*;
    pub fn init_methods<I: ImplResourceSkipCallback>(object: &mut _cef_resource_skip_callback_t) {
        object.cont = Some(cont::<I>);
    }
    extern "C" fn cont<I: ImplResourceSkipCallback>(
        self_: *mut _cef_resource_skip_callback_t,
        bytes_skipped: i64,
    ) {
        let (arg_self_, arg_bytes_skipped) = (self_, bytes_skipped);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_bytes_skipped = arg_bytes_skipped.as_raw();
        arg_self_.interface.cont(arg_bytes_skipped)
    }
}
#[doc = "See [_cef_resource_skip_callback_t] for more documentation."]
#[derive(Clone)]
pub struct ResourceSkipCallback(RefGuard<_cef_resource_skip_callback_t>);
impl ImplResourceSkipCallback for ResourceSkipCallback {
    fn cont<'a>(&self, bytes_skipped: i64) {
        unsafe {
            self.0
                .cont
                .map(|f| {
                    let arg_bytes_skipped = bytes_skipped;
                    let arg_self_ = self.as_raw();
                    let arg_bytes_skipped = arg_bytes_skipped;
                    let result = f(arg_self_, arg_bytes_skipped);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_resource_skip_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ResourceSkipCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_resource_skip_callback_t> for &ResourceSkipCallback {
    fn as_raw(self) -> *mut _cef_resource_skip_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_resource_skip_callback_t> for &mut ResourceSkipCallback {
    fn as_raw(self) -> *mut _cef_resource_skip_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<ResourceSkipCallback> for *mut _cef_resource_skip_callback_t {
    fn as_wrapper(self) -> ResourceSkipCallback {
        ResourceSkipCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_resource_skip_callback_t> for ResourceSkipCallback {
    fn into(self) -> *mut _cef_resource_skip_callback_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for ResourceSkipCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplResourceReadCallback: Sized {
    fn cont<'a>(&self, bytes_read: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_resource_read_callback_t {
        let mut object: _cef_resource_read_callback_t = unsafe { std::mem::zeroed() };
        impl_cef_resource_read_callback_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_resource_read_callback_t {
    use super::*;
    pub fn init_methods<I: ImplResourceReadCallback>(object: &mut _cef_resource_read_callback_t) {
        object.cont = Some(cont::<I>);
    }
    extern "C" fn cont<I: ImplResourceReadCallback>(
        self_: *mut _cef_resource_read_callback_t,
        bytes_read: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_bytes_read) = (self_, bytes_read);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_bytes_read = arg_bytes_read.as_raw();
        arg_self_.interface.cont(arg_bytes_read)
    }
}
#[doc = "See [_cef_resource_read_callback_t] for more documentation."]
#[derive(Clone)]
pub struct ResourceReadCallback(RefGuard<_cef_resource_read_callback_t>);
impl ImplResourceReadCallback for ResourceReadCallback {
    fn cont<'a>(&self, bytes_read: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .cont
                .map(|f| {
                    let arg_bytes_read = bytes_read;
                    let arg_self_ = self.as_raw();
                    let arg_bytes_read = arg_bytes_read;
                    let result = f(arg_self_, arg_bytes_read);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_resource_read_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ResourceReadCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_resource_read_callback_t> for &ResourceReadCallback {
    fn as_raw(self) -> *mut _cef_resource_read_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_resource_read_callback_t> for &mut ResourceReadCallback {
    fn as_raw(self) -> *mut _cef_resource_read_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<ResourceReadCallback> for *mut _cef_resource_read_callback_t {
    fn as_wrapper(self) -> ResourceReadCallback {
        ResourceReadCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_resource_read_callback_t> for ResourceReadCallback {
    fn into(self) -> *mut _cef_resource_read_callback_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for ResourceReadCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplResourceHandler: Sized {
    fn open<'a>(
        &self,
        request: &'a mut Request,
        handle_request: *mut ::std::os::raw::c_int,
        callback: &'a mut Callback,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn process_request<'a>(
        &self,
        request: &'a mut Request,
        callback: &'a mut Callback,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_response_headers<'a>(
        &self,
        response: &'a mut Response,
        response_length: *mut i64,
        redirect_url: &'a mut CefStringUtf16,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn skip<'a>(
        &self,
        bytes_to_skip: i64,
        bytes_skipped: *mut i64,
        callback: &'a mut ResourceSkipCallback,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn read<'a>(
        &self,
        data_out: *mut ::std::os::raw::c_void,
        bytes_to_read: ::std::os::raw::c_int,
        bytes_read: *mut ::std::os::raw::c_int,
        callback: &'a mut ResourceReadCallback,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn read_response<'a>(
        &self,
        data_out: *mut ::std::os::raw::c_void,
        bytes_to_read: ::std::os::raw::c_int,
        bytes_read: *mut ::std::os::raw::c_int,
        callback: &'a mut Callback,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn cancel<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_resource_handler_t {
        let mut object: _cef_resource_handler_t = unsafe { std::mem::zeroed() };
        impl_cef_resource_handler_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_resource_handler_t {
    use super::*;
    pub fn init_methods<I: ImplResourceHandler>(object: &mut _cef_resource_handler_t) {
        object.open = Some(open::<I>);
        object.process_request = Some(process_request::<I>);
        object.get_response_headers = Some(get_response_headers::<I>);
        object.skip = Some(skip::<I>);
        object.read = Some(read::<I>);
        object.read_response = Some(read_response::<I>);
        object.cancel = Some(cancel::<I>);
    }
    extern "C" fn open<I: ImplResourceHandler>(
        self_: *mut _cef_resource_handler_t,
        request: *mut _cef_request_t,
        handle_request: *mut ::std::os::raw::c_int,
        callback: *mut _cef_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_request, arg_handle_request, arg_callback) =
            (self_, request, handle_request, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_request = &mut Request(unsafe { RefGuard::from_raw_add_ref(arg_request) });
        let mut arg_handle_request =
            WrapParamRef::<::std::os::raw::c_int>::from(arg_handle_request);
        let arg_handle_request = arg_handle_request.as_mut();
        let arg_callback = &mut Callback(unsafe { RefGuard::from_raw_add_ref(arg_callback) });
        arg_self_
            .interface
            .open(arg_request, arg_handle_request, arg_callback)
            .into()
    }
    extern "C" fn process_request<I: ImplResourceHandler>(
        self_: *mut _cef_resource_handler_t,
        request: *mut _cef_request_t,
        callback: *mut _cef_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_request, arg_callback) = (self_, request, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_request = &mut Request(unsafe { RefGuard::from_raw_add_ref(arg_request) });
        let arg_callback = &mut Callback(unsafe { RefGuard::from_raw_add_ref(arg_callback) });
        arg_self_
            .interface
            .process_request(arg_request, arg_callback)
            .into()
    }
    extern "C" fn get_response_headers<I: ImplResourceHandler>(
        self_: *mut _cef_resource_handler_t,
        response: *mut _cef_response_t,
        response_length: *mut i64,
        redirect_url: *mut _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_response, arg_response_length, arg_redirect_url) =
            (self_, response, response_length, redirect_url);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_response = &mut Response(unsafe { RefGuard::from_raw_add_ref(arg_response) });
        let mut arg_response_length = WrapParamRef::<i64>::from(arg_response_length);
        let arg_response_length = arg_response_length.as_mut();
        let mut arg_redirect_url = WrapParamRef::<CefStringUtf16>::from(arg_redirect_url);
        let arg_redirect_url = arg_redirect_url.as_mut();
        arg_self_.interface.get_response_headers(
            arg_response,
            arg_response_length,
            arg_redirect_url,
        )
    }
    extern "C" fn skip<I: ImplResourceHandler>(
        self_: *mut _cef_resource_handler_t,
        bytes_to_skip: i64,
        bytes_skipped: *mut i64,
        callback: *mut _cef_resource_skip_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_bytes_to_skip, arg_bytes_skipped, arg_callback) =
            (self_, bytes_to_skip, bytes_skipped, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_bytes_to_skip = arg_bytes_to_skip.as_raw();
        let mut arg_bytes_skipped = WrapParamRef::<i64>::from(arg_bytes_skipped);
        let arg_bytes_skipped = arg_bytes_skipped.as_mut();
        let arg_callback =
            &mut ResourceSkipCallback(unsafe { RefGuard::from_raw_add_ref(arg_callback) });
        arg_self_
            .interface
            .skip(arg_bytes_to_skip, arg_bytes_skipped, arg_callback)
            .into()
    }
    extern "C" fn read<I: ImplResourceHandler>(
        self_: *mut _cef_resource_handler_t,
        data_out: *mut ::std::os::raw::c_void,
        bytes_to_read: ::std::os::raw::c_int,
        bytes_read: *mut ::std::os::raw::c_int,
        callback: *mut _cef_resource_read_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_data_out, arg_bytes_to_read, arg_bytes_read, arg_callback) =
            (self_, data_out, bytes_to_read, bytes_read, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_bytes_to_read = arg_bytes_to_read.as_raw();
        let mut arg_bytes_read = WrapParamRef::<::std::os::raw::c_int>::from(arg_bytes_read);
        let arg_bytes_read = arg_bytes_read.as_mut();
        let arg_callback =
            &mut ResourceReadCallback(unsafe { RefGuard::from_raw_add_ref(arg_callback) });
        arg_self_
            .interface
            .read(
                arg_data_out,
                arg_bytes_to_read,
                arg_bytes_read,
                arg_callback,
            )
            .into()
    }
    extern "C" fn read_response<I: ImplResourceHandler>(
        self_: *mut _cef_resource_handler_t,
        data_out: *mut ::std::os::raw::c_void,
        bytes_to_read: ::std::os::raw::c_int,
        bytes_read: *mut ::std::os::raw::c_int,
        callback: *mut _cef_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_data_out, arg_bytes_to_read, arg_bytes_read, arg_callback) =
            (self_, data_out, bytes_to_read, bytes_read, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_bytes_to_read = arg_bytes_to_read.as_raw();
        let mut arg_bytes_read = WrapParamRef::<::std::os::raw::c_int>::from(arg_bytes_read);
        let arg_bytes_read = arg_bytes_read.as_mut();
        let arg_callback = &mut Callback(unsafe { RefGuard::from_raw_add_ref(arg_callback) });
        arg_self_
            .interface
            .read_response(
                arg_data_out,
                arg_bytes_to_read,
                arg_bytes_read,
                arg_callback,
            )
            .into()
    }
    extern "C" fn cancel<I: ImplResourceHandler>(self_: *mut _cef_resource_handler_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.cancel()
    }
}
#[doc = "See [_cef_resource_handler_t] for more documentation."]
#[derive(Clone)]
pub struct ResourceHandler(RefGuard<_cef_resource_handler_t>);
impl ImplResourceHandler for ResourceHandler {
    fn open<'a>(
        &self,
        request: &'a mut Request,
        handle_request: *mut ::std::os::raw::c_int,
        callback: &'a mut Callback,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .open
                .map(|f| {
                    let (arg_request, arg_handle_request, arg_callback) =
                        (request, handle_request, callback);
                    let arg_self_ = self.as_raw();
                    let arg_request = arg_request.as_raw();
                    let arg_handle_request = arg_handle_request as *mut _;
                    let arg_callback = arg_callback.as_raw();
                    let result = f(arg_self_, arg_request, arg_handle_request, arg_callback);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn process_request<'a>(
        &self,
        request: &'a mut Request,
        callback: &'a mut Callback,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .process_request
                .map(|f| {
                    let (arg_request, arg_callback) = (request, callback);
                    let arg_self_ = self.as_raw();
                    let arg_request = arg_request.as_raw();
                    let arg_callback = arg_callback.as_raw();
                    let result = f(arg_self_, arg_request, arg_callback);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_response_headers<'a>(
        &self,
        response: &'a mut Response,
        response_length: *mut i64,
        redirect_url: &'a mut CefStringUtf16,
    ) {
        unsafe {
            self.0
                .get_response_headers
                .map(|f| {
                    let (arg_response, arg_response_length, arg_redirect_url) =
                        (response, response_length, redirect_url);
                    let arg_self_ = self.as_raw();
                    let arg_response = arg_response.as_raw();
                    let arg_response_length = arg_response_length as *mut _;
                    let arg_redirect_url = arg_redirect_url.as_raw();
                    let result = f(
                        arg_self_,
                        arg_response,
                        arg_response_length,
                        arg_redirect_url,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn skip<'a>(
        &self,
        bytes_to_skip: i64,
        bytes_skipped: *mut i64,
        callback: &'a mut ResourceSkipCallback,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .skip
                .map(|f| {
                    let (arg_bytes_to_skip, arg_bytes_skipped, arg_callback) =
                        (bytes_to_skip, bytes_skipped, callback);
                    let arg_self_ = self.as_raw();
                    let arg_bytes_to_skip = arg_bytes_to_skip;
                    let arg_bytes_skipped = arg_bytes_skipped as *mut _;
                    let arg_callback = arg_callback.as_raw();
                    let result = f(
                        arg_self_,
                        arg_bytes_to_skip,
                        arg_bytes_skipped,
                        arg_callback,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn read<'a>(
        &self,
        data_out: *mut ::std::os::raw::c_void,
        bytes_to_read: ::std::os::raw::c_int,
        bytes_read: *mut ::std::os::raw::c_int,
        callback: &'a mut ResourceReadCallback,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .read
                .map(|f| {
                    let (arg_data_out, arg_bytes_to_read, arg_bytes_read, arg_callback) =
                        (data_out, bytes_to_read, bytes_read, callback);
                    let arg_self_ = self.as_raw();
                    let arg_data_out = arg_data_out as *mut _;
                    let arg_bytes_to_read = arg_bytes_to_read;
                    let arg_bytes_read = arg_bytes_read as *mut _;
                    let arg_callback = arg_callback.as_raw();
                    let result = f(
                        arg_self_,
                        arg_data_out,
                        arg_bytes_to_read,
                        arg_bytes_read,
                        arg_callback,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn read_response<'a>(
        &self,
        data_out: *mut ::std::os::raw::c_void,
        bytes_to_read: ::std::os::raw::c_int,
        bytes_read: *mut ::std::os::raw::c_int,
        callback: &'a mut Callback,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .read_response
                .map(|f| {
                    let (arg_data_out, arg_bytes_to_read, arg_bytes_read, arg_callback) =
                        (data_out, bytes_to_read, bytes_read, callback);
                    let arg_self_ = self.as_raw();
                    let arg_data_out = arg_data_out as *mut _;
                    let arg_bytes_to_read = arg_bytes_to_read;
                    let arg_bytes_read = arg_bytes_read as *mut _;
                    let arg_callback = arg_callback.as_raw();
                    let result = f(
                        arg_self_,
                        arg_data_out,
                        arg_bytes_to_read,
                        arg_bytes_read,
                        arg_callback,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn cancel<'a>(&self) {
        unsafe {
            self.0
                .cancel
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_resource_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ResourceHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_resource_handler_t> for &ResourceHandler {
    fn as_raw(self) -> *mut _cef_resource_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_resource_handler_t> for &mut ResourceHandler {
    fn as_raw(self) -> *mut _cef_resource_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<ResourceHandler> for *mut _cef_resource_handler_t {
    fn as_wrapper(self) -> ResourceHandler {
        ResourceHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_resource_handler_t> for ResourceHandler {
    fn into(self) -> *mut _cef_resource_handler_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for ResourceHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplResponseFilter: Sized {
    fn init_filter<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn filter<'a>(
        &self,
        data_in: Option<&'a mut &'a mut [u8]>,
        data_in_read: *mut usize,
        data_out: Option<&'a mut &'a mut [u8]>,
        data_out_written: *mut usize,
    ) -> ResponseFilterStatus {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_response_filter_t {
        let mut object: _cef_response_filter_t = unsafe { std::mem::zeroed() };
        impl_cef_response_filter_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_response_filter_t {
    use super::*;
    pub fn init_methods<I: ImplResponseFilter>(object: &mut _cef_response_filter_t) {
        object.init_filter = Some(init_filter::<I>);
        object.filter = Some(filter::<I>);
    }
    extern "C" fn init_filter<I: ImplResponseFilter>(
        self_: *mut _cef_response_filter_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.init_filter().into()
    }
    extern "C" fn filter<I: ImplResponseFilter>(
        self_: *mut _cef_response_filter_t,
        data_in: *mut ::std::os::raw::c_void,
        data_in_size: usize,
        data_in_read: *mut usize,
        data_out: *mut ::std::os::raw::c_void,
        data_out_size: usize,
        data_out_written: *mut usize,
    ) -> cef_response_filter_status_t {
        let (
            arg_self_,
            arg_data_in,
            arg_data_in_size,
            arg_data_in_read,
            arg_data_out,
            arg_data_out_size,
            arg_data_out_written,
        ) = (
            self_,
            data_in,
            data_in_size,
            data_in_read,
            data_out,
            data_out_size,
            data_out_written,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut out_data_in = (!arg_data_in.is_null() && arg_data_in_size > 0).then(|| unsafe {
            std::slice::from_raw_parts_mut(arg_data_in as *mut _, arg_data_in_size)
        });
        let arg_buffer = out_buffer.as_mut();
        let mut arg_data_in_read = WrapParamRef::<usize>::from(arg_data_in_read);
        let arg_data_in_read = arg_data_in_read.as_mut();
        let mut out_data_out = (!arg_data_out.is_null() && arg_data_out_size > 0).then(|| unsafe {
            std::slice::from_raw_parts_mut(arg_data_out as *mut _, arg_data_out_size)
        });
        let arg_buffer = out_buffer.as_mut();
        let mut arg_data_out_written = WrapParamRef::<usize>::from(arg_data_out_written);
        let arg_data_out_written = arg_data_out_written.as_mut();
        arg_self_
            .interface
            .filter(
                arg_data_in,
                arg_data_in_read,
                arg_data_out,
                arg_data_out_written,
            )
            .into()
    }
}
#[doc = "See [_cef_response_filter_t] for more documentation."]
#[derive(Clone)]
pub struct ResponseFilter(RefGuard<_cef_response_filter_t>);
impl ImplResponseFilter for ResponseFilter {
    fn init_filter<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .init_filter
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn filter<'a>(
        &self,
        data_in: Option<&'a mut &'a mut [u8]>,
        data_in_read: *mut usize,
        data_out: Option<&'a mut &'a mut [u8]>,
        data_out_written: *mut usize,
    ) -> ResponseFilterStatus {
        unsafe {
            self.0
                .filter
                .map(|f| {
                    let (arg_data_in, arg_data_in_read, arg_data_out, arg_data_out_written) =
                        (data_in, data_in_read, data_out, data_out_written);
                    let arg_self_ = self.as_raw();
                    let arg_data_in_size = arg_data_in
                        .as_ref()
                        .map(|slice| slice.len())
                        .unwrap_or_default();
                    let mut out_data_in = arg_data_in;
                    let arg_data_in = out_data_in
                        .as_mut()
                        .and_then(|slice| {
                            if slice.is_empty() {
                                None
                            } else {
                                Some(slice.as_mut_ptr() as *mut _)
                            }
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_data_in_read = arg_data_in_read as *mut _;
                    let arg_data_out_size = arg_data_out
                        .as_ref()
                        .map(|slice| slice.len())
                        .unwrap_or_default();
                    let mut out_data_out = arg_data_out;
                    let arg_data_out = out_data_out
                        .as_mut()
                        .and_then(|slice| {
                            if slice.is_empty() {
                                None
                            } else {
                                Some(slice.as_mut_ptr() as *mut _)
                            }
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_data_out_written = arg_data_out_written as *mut _;
                    let result = f(
                        arg_self_,
                        arg_data_in,
                        arg_data_in_size,
                        arg_data_in_read,
                        arg_data_out,
                        arg_data_out_size,
                        arg_data_out_written,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_response_filter_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ResponseFilter {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_response_filter_t> for &ResponseFilter {
    fn as_raw(self) -> *mut _cef_response_filter_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_response_filter_t> for &mut ResponseFilter {
    fn as_raw(self) -> *mut _cef_response_filter_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<ResponseFilter> for *mut _cef_response_filter_t {
    fn as_wrapper(self) -> ResponseFilter {
        ResponseFilter(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_response_filter_t> for ResponseFilter {
    fn into(self) -> *mut _cef_response_filter_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for ResponseFilter {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplResourceRequestHandler: Sized {
    fn get_cookie_access_filter<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        request: &'a mut Request,
    ) -> CookieAccessFilter {
        unsafe { std::mem::zeroed() }
    }
    fn on_before_resource_load<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        request: &'a mut Request,
        callback: &'a mut Callback,
    ) -> ReturnValue {
        unsafe { std::mem::zeroed() }
    }
    fn get_resource_handler<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        request: &'a mut Request,
    ) -> ResourceHandler {
        unsafe { std::mem::zeroed() }
    }
    fn on_resource_redirect<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        request: &'a mut Request,
        response: &'a mut Response,
        new_url: &'a mut CefStringUtf16,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn on_resource_response<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        request: &'a mut Request,
        response: &'a mut Response,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_resource_response_filter<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        request: &'a mut Request,
        response: &'a mut Response,
    ) -> ResponseFilter {
        unsafe { std::mem::zeroed() }
    }
    fn on_resource_load_complete<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        request: &'a mut Request,
        response: &'a mut Response,
        status: UrlrequestStatus,
        received_content_length: i64,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn on_protocol_execution<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        request: &'a mut Request,
        allow_os_execution: *mut ::std::os::raw::c_int,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_resource_request_handler_t {
        let mut object: _cef_resource_request_handler_t = unsafe { std::mem::zeroed() };
        impl_cef_resource_request_handler_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_resource_request_handler_t {
    use super::*;
    pub fn init_methods<I: ImplResourceRequestHandler>(
        object: &mut _cef_resource_request_handler_t,
    ) {
        object.get_cookie_access_filter = Some(get_cookie_access_filter::<I>);
        object.on_before_resource_load = Some(on_before_resource_load::<I>);
        object.get_resource_handler = Some(get_resource_handler::<I>);
        object.on_resource_redirect = Some(on_resource_redirect::<I>);
        object.on_resource_response = Some(on_resource_response::<I>);
        object.get_resource_response_filter = Some(get_resource_response_filter::<I>);
        object.on_resource_load_complete = Some(on_resource_load_complete::<I>);
        object.on_protocol_execution = Some(on_protocol_execution::<I>);
    }
    extern "C" fn get_cookie_access_filter<I: ImplResourceRequestHandler>(
        self_: *mut _cef_resource_request_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        request: *mut _cef_request_t,
    ) -> *mut _cef_cookie_access_filter_t {
        let (arg_self_, arg_browser, arg_frame, arg_request) = (self_, browser, frame, request);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_frame) });
        let arg_request = &mut Request(unsafe { RefGuard::from_raw_add_ref(arg_request) });
        arg_self_
            .interface
            .get_cookie_access_filter(arg_browser, arg_frame, arg_request)
            .into()
    }
    extern "C" fn on_before_resource_load<I: ImplResourceRequestHandler>(
        self_: *mut _cef_resource_request_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        request: *mut _cef_request_t,
        callback: *mut _cef_callback_t,
    ) -> cef_return_value_t {
        let (arg_self_, arg_browser, arg_frame, arg_request, arg_callback) =
            (self_, browser, frame, request, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_frame) });
        let arg_request = &mut Request(unsafe { RefGuard::from_raw_add_ref(arg_request) });
        let arg_callback = &mut Callback(unsafe { RefGuard::from_raw_add_ref(arg_callback) });
        arg_self_
            .interface
            .on_before_resource_load(arg_browser, arg_frame, arg_request, arg_callback)
            .into()
    }
    extern "C" fn get_resource_handler<I: ImplResourceRequestHandler>(
        self_: *mut _cef_resource_request_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        request: *mut _cef_request_t,
    ) -> *mut _cef_resource_handler_t {
        let (arg_self_, arg_browser, arg_frame, arg_request) = (self_, browser, frame, request);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_frame) });
        let arg_request = &mut Request(unsafe { RefGuard::from_raw_add_ref(arg_request) });
        arg_self_
            .interface
            .get_resource_handler(arg_browser, arg_frame, arg_request)
            .into()
    }
    extern "C" fn on_resource_redirect<I: ImplResourceRequestHandler>(
        self_: *mut _cef_resource_request_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        request: *mut _cef_request_t,
        response: *mut _cef_response_t,
        new_url: *mut _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_browser, arg_frame, arg_request, arg_response, arg_new_url) =
            (self_, browser, frame, request, response, new_url);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_frame) });
        let arg_request = &mut Request(unsafe { RefGuard::from_raw_add_ref(arg_request) });
        let arg_response = &mut Response(unsafe { RefGuard::from_raw_add_ref(arg_response) });
        let mut arg_new_url = WrapParamRef::<CefStringUtf16>::from(arg_new_url);
        let arg_new_url = arg_new_url.as_mut();
        arg_self_.interface.on_resource_redirect(
            arg_browser,
            arg_frame,
            arg_request,
            arg_response,
            arg_new_url,
        )
    }
    extern "C" fn on_resource_response<I: ImplResourceRequestHandler>(
        self_: *mut _cef_resource_request_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        request: *mut _cef_request_t,
        response: *mut _cef_response_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_frame, arg_request, arg_response) =
            (self_, browser, frame, request, response);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_frame) });
        let arg_request = &mut Request(unsafe { RefGuard::from_raw_add_ref(arg_request) });
        let arg_response = &mut Response(unsafe { RefGuard::from_raw_add_ref(arg_response) });
        arg_self_
            .interface
            .on_resource_response(arg_browser, arg_frame, arg_request, arg_response)
            .into()
    }
    extern "C" fn get_resource_response_filter<I: ImplResourceRequestHandler>(
        self_: *mut _cef_resource_request_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        request: *mut _cef_request_t,
        response: *mut _cef_response_t,
    ) -> *mut _cef_response_filter_t {
        let (arg_self_, arg_browser, arg_frame, arg_request, arg_response) =
            (self_, browser, frame, request, response);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_frame) });
        let arg_request = &mut Request(unsafe { RefGuard::from_raw_add_ref(arg_request) });
        let arg_response = &mut Response(unsafe { RefGuard::from_raw_add_ref(arg_response) });
        arg_self_
            .interface
            .get_resource_response_filter(arg_browser, arg_frame, arg_request, arg_response)
            .into()
    }
    extern "C" fn on_resource_load_complete<I: ImplResourceRequestHandler>(
        self_: *mut _cef_resource_request_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        request: *mut _cef_request_t,
        response: *mut _cef_response_t,
        status: cef_urlrequest_status_t,
        received_content_length: i64,
    ) {
        let (
            arg_self_,
            arg_browser,
            arg_frame,
            arg_request,
            arg_response,
            arg_status,
            arg_received_content_length,
        ) = (
            self_,
            browser,
            frame,
            request,
            response,
            status,
            received_content_length,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_frame) });
        let arg_request = &mut Request(unsafe { RefGuard::from_raw_add_ref(arg_request) });
        let arg_response = &mut Response(unsafe { RefGuard::from_raw_add_ref(arg_response) });
        let arg_status = arg_status.as_raw();
        let arg_received_content_length = arg_received_content_length.as_raw();
        arg_self_.interface.on_resource_load_complete(
            arg_browser,
            arg_frame,
            arg_request,
            arg_response,
            arg_status,
            arg_received_content_length,
        )
    }
    extern "C" fn on_protocol_execution<I: ImplResourceRequestHandler>(
        self_: *mut _cef_resource_request_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        request: *mut _cef_request_t,
        allow_os_execution: *mut ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_browser, arg_frame, arg_request, arg_allow_os_execution) =
            (self_, browser, frame, request, allow_os_execution);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_frame) });
        let arg_request = &mut Request(unsafe { RefGuard::from_raw_add_ref(arg_request) });
        let mut arg_allow_os_execution =
            WrapParamRef::<::std::os::raw::c_int>::from(arg_allow_os_execution);
        let arg_allow_os_execution = arg_allow_os_execution.as_mut();
        arg_self_.interface.on_protocol_execution(
            arg_browser,
            arg_frame,
            arg_request,
            arg_allow_os_execution,
        )
    }
}
#[doc = "See [_cef_resource_request_handler_t] for more documentation."]
#[derive(Clone)]
pub struct ResourceRequestHandler(RefGuard<_cef_resource_request_handler_t>);
impl ImplResourceRequestHandler for ResourceRequestHandler {
    fn get_cookie_access_filter<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        request: &'a mut Request,
    ) -> CookieAccessFilter {
        unsafe {
            self.0
                .get_cookie_access_filter
                .map(|f| {
                    let (arg_browser, arg_frame, arg_request) = (browser, frame, request);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_frame = arg_frame.as_raw();
                    let arg_request = arg_request.as_raw();
                    let result = f(arg_self_, arg_browser, arg_frame, arg_request);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_before_resource_load<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        request: &'a mut Request,
        callback: &'a mut Callback,
    ) -> ReturnValue {
        unsafe {
            self.0
                .on_before_resource_load
                .map(|f| {
                    let (arg_browser, arg_frame, arg_request, arg_callback) =
                        (browser, frame, request, callback);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_frame = arg_frame.as_raw();
                    let arg_request = arg_request.as_raw();
                    let arg_callback = arg_callback.as_raw();
                    let result = f(arg_self_, arg_browser, arg_frame, arg_request, arg_callback);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_resource_handler<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        request: &'a mut Request,
    ) -> ResourceHandler {
        unsafe {
            self.0
                .get_resource_handler
                .map(|f| {
                    let (arg_browser, arg_frame, arg_request) = (browser, frame, request);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_frame = arg_frame.as_raw();
                    let arg_request = arg_request.as_raw();
                    let result = f(arg_self_, arg_browser, arg_frame, arg_request);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_resource_redirect<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        request: &'a mut Request,
        response: &'a mut Response,
        new_url: &'a mut CefStringUtf16,
    ) {
        unsafe {
            self.0
                .on_resource_redirect
                .map(|f| {
                    let (arg_browser, arg_frame, arg_request, arg_response, arg_new_url) =
                        (browser, frame, request, response, new_url);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_frame = arg_frame.as_raw();
                    let arg_request = arg_request.as_raw();
                    let arg_response = arg_response.as_raw();
                    let arg_new_url = arg_new_url.as_raw();
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_request,
                        arg_response,
                        arg_new_url,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_resource_response<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        request: &'a mut Request,
        response: &'a mut Response,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_resource_response
                .map(|f| {
                    let (arg_browser, arg_frame, arg_request, arg_response) =
                        (browser, frame, request, response);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_frame = arg_frame.as_raw();
                    let arg_request = arg_request.as_raw();
                    let arg_response = arg_response.as_raw();
                    let result = f(arg_self_, arg_browser, arg_frame, arg_request, arg_response);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_resource_response_filter<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        request: &'a mut Request,
        response: &'a mut Response,
    ) -> ResponseFilter {
        unsafe {
            self.0
                .get_resource_response_filter
                .map(|f| {
                    let (arg_browser, arg_frame, arg_request, arg_response) =
                        (browser, frame, request, response);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_frame = arg_frame.as_raw();
                    let arg_request = arg_request.as_raw();
                    let arg_response = arg_response.as_raw();
                    let result = f(arg_self_, arg_browser, arg_frame, arg_request, arg_response);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_resource_load_complete<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        request: &'a mut Request,
        response: &'a mut Response,
        status: UrlrequestStatus,
        received_content_length: i64,
    ) {
        unsafe {
            self.0
                .on_resource_load_complete
                .map(|f| {
                    let (
                        arg_browser,
                        arg_frame,
                        arg_request,
                        arg_response,
                        arg_status,
                        arg_received_content_length,
                    ) = (
                        browser,
                        frame,
                        request,
                        response,
                        status,
                        received_content_length,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_frame = arg_frame.as_raw();
                    let arg_request = arg_request.as_raw();
                    let arg_response = arg_response.as_raw();
                    let arg_status = arg_status.as_raw();
                    let arg_received_content_length = arg_received_content_length;
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_request,
                        arg_response,
                        arg_status,
                        arg_received_content_length,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_protocol_execution<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        request: &'a mut Request,
        allow_os_execution: *mut ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .on_protocol_execution
                .map(|f| {
                    let (arg_browser, arg_frame, arg_request, arg_allow_os_execution) =
                        (browser, frame, request, allow_os_execution);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_frame = arg_frame.as_raw();
                    let arg_request = arg_request.as_raw();
                    let arg_allow_os_execution = arg_allow_os_execution as *mut _;
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_request,
                        arg_allow_os_execution,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_resource_request_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ResourceRequestHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_resource_request_handler_t> for &ResourceRequestHandler {
    fn as_raw(self) -> *mut _cef_resource_request_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_resource_request_handler_t> for &mut ResourceRequestHandler {
    fn as_raw(self) -> *mut _cef_resource_request_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<ResourceRequestHandler> for *mut _cef_resource_request_handler_t {
    fn as_wrapper(self) -> ResourceRequestHandler {
        ResourceRequestHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_resource_request_handler_t> for ResourceRequestHandler {
    fn into(self) -> *mut _cef_resource_request_handler_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for ResourceRequestHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplCookieAccessFilter: Sized {
    fn can_send_cookie<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        request: &'a mut Request,
        cookie: &'a Cookie,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn can_save_cookie<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        request: &'a mut Request,
        response: &'a mut Response,
        cookie: &'a Cookie,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_cookie_access_filter_t {
        let mut object: _cef_cookie_access_filter_t = unsafe { std::mem::zeroed() };
        impl_cef_cookie_access_filter_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_cookie_access_filter_t {
    use super::*;
    pub fn init_methods<I: ImplCookieAccessFilter>(object: &mut _cef_cookie_access_filter_t) {
        object.can_send_cookie = Some(can_send_cookie::<I>);
        object.can_save_cookie = Some(can_save_cookie::<I>);
    }
    extern "C" fn can_send_cookie<I: ImplCookieAccessFilter>(
        self_: *mut _cef_cookie_access_filter_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        request: *mut _cef_request_t,
        cookie: *const _cef_cookie_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_frame, arg_request, arg_cookie) =
            (self_, browser, frame, request, cookie);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_frame) });
        let arg_request = &mut Request(unsafe { RefGuard::from_raw_add_ref(arg_request) });
        let arg_cookie = WrapParamRef::<Cookie>::from(arg_cookie);
        let arg_cookie = arg_cookie.as_ref();
        arg_self_
            .interface
            .can_send_cookie(arg_browser, arg_frame, arg_request, arg_cookie)
            .into()
    }
    extern "C" fn can_save_cookie<I: ImplCookieAccessFilter>(
        self_: *mut _cef_cookie_access_filter_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        request: *mut _cef_request_t,
        response: *mut _cef_response_t,
        cookie: *const _cef_cookie_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_frame, arg_request, arg_response, arg_cookie) =
            (self_, browser, frame, request, response, cookie);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_frame) });
        let arg_request = &mut Request(unsafe { RefGuard::from_raw_add_ref(arg_request) });
        let arg_response = &mut Response(unsafe { RefGuard::from_raw_add_ref(arg_response) });
        let arg_cookie = WrapParamRef::<Cookie>::from(arg_cookie);
        let arg_cookie = arg_cookie.as_ref();
        arg_self_
            .interface
            .can_save_cookie(
                arg_browser,
                arg_frame,
                arg_request,
                arg_response,
                arg_cookie,
            )
            .into()
    }
}
#[doc = "See [_cef_cookie_access_filter_t] for more documentation."]
#[derive(Clone)]
pub struct CookieAccessFilter(RefGuard<_cef_cookie_access_filter_t>);
impl ImplCookieAccessFilter for CookieAccessFilter {
    fn can_send_cookie<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        request: &'a mut Request,
        cookie: &'a Cookie,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .can_send_cookie
                .map(|f| {
                    let (arg_browser, arg_frame, arg_request, arg_cookie) =
                        (browser, frame, request, cookie);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_frame = arg_frame.as_raw();
                    let arg_request = arg_request.as_raw();
                    let mut arg_cookie: _cef_cookie_t = arg_cookie.clone().into();
                    let arg_cookie = &mut arg_cookie;
                    let result = f(arg_self_, arg_browser, arg_frame, arg_request, arg_cookie);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn can_save_cookie<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        request: &'a mut Request,
        response: &'a mut Response,
        cookie: &'a Cookie,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .can_save_cookie
                .map(|f| {
                    let (arg_browser, arg_frame, arg_request, arg_response, arg_cookie) =
                        (browser, frame, request, response, cookie);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_frame = arg_frame.as_raw();
                    let arg_request = arg_request.as_raw();
                    let arg_response = arg_response.as_raw();
                    let mut arg_cookie: _cef_cookie_t = arg_cookie.clone().into();
                    let arg_cookie = &mut arg_cookie;
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_request,
                        arg_response,
                        arg_cookie,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_cookie_access_filter_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for CookieAccessFilter {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_cookie_access_filter_t> for &CookieAccessFilter {
    fn as_raw(self) -> *mut _cef_cookie_access_filter_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_cookie_access_filter_t> for &mut CookieAccessFilter {
    fn as_raw(self) -> *mut _cef_cookie_access_filter_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<CookieAccessFilter> for *mut _cef_cookie_access_filter_t {
    fn as_wrapper(self) -> CookieAccessFilter {
        CookieAccessFilter(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_cookie_access_filter_t> for CookieAccessFilter {
    fn into(self) -> *mut _cef_cookie_access_filter_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for CookieAccessFilter {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplSslinfo: Sized {
    fn get_cert_status<'a>(&self) -> CertStatus {
        unsafe { std::mem::zeroed() }
    }
    fn get_x509certificate<'a>(&self) -> X509certificate {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_sslinfo_t {
        let mut object: _cef_sslinfo_t = unsafe { std::mem::zeroed() };
        impl_cef_sslinfo_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_sslinfo_t {
    use super::*;
    pub fn init_methods<I: ImplSslinfo>(object: &mut _cef_sslinfo_t) {
        object.get_cert_status = Some(get_cert_status::<I>);
        object.get_x509certificate = Some(get_x509certificate::<I>);
    }
    extern "C" fn get_cert_status<I: ImplSslinfo>(self_: *mut _cef_sslinfo_t) -> cef_cert_status_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_cert_status().into()
    }
    extern "C" fn get_x509certificate<I: ImplSslinfo>(
        self_: *mut _cef_sslinfo_t,
    ) -> *mut _cef_x509certificate_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_x509certificate().into()
    }
}
#[doc = "See [_cef_sslinfo_t] for more documentation."]
#[derive(Clone)]
pub struct Sslinfo(RefGuard<_cef_sslinfo_t>);
impl ImplSslinfo for Sslinfo {
    fn get_cert_status<'a>(&self) -> CertStatus {
        unsafe {
            self.0
                .get_cert_status
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_x509certificate<'a>(&self) -> X509certificate {
        unsafe {
            self.0
                .get_x509certificate
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_sslinfo_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Sslinfo {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_sslinfo_t> for &Sslinfo {
    fn as_raw(self) -> *mut _cef_sslinfo_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_sslinfo_t> for &mut Sslinfo {
    fn as_raw(self) -> *mut _cef_sslinfo_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<Sslinfo> for *mut _cef_sslinfo_t {
    fn as_wrapper(self) -> Sslinfo {
        Sslinfo(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_sslinfo_t> for Sslinfo {
    fn into(self) -> *mut _cef_sslinfo_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for Sslinfo {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplUnresponsiveProcessCallback: Sized {
    fn wait<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn terminate<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_unresponsive_process_callback_t {
        let mut object: _cef_unresponsive_process_callback_t = unsafe { std::mem::zeroed() };
        impl_cef_unresponsive_process_callback_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_unresponsive_process_callback_t {
    use super::*;
    pub fn init_methods<I: ImplUnresponsiveProcessCallback>(
        object: &mut _cef_unresponsive_process_callback_t,
    ) {
        object.wait = Some(wait::<I>);
        object.terminate = Some(terminate::<I>);
    }
    extern "C" fn wait<I: ImplUnresponsiveProcessCallback>(
        self_: *mut _cef_unresponsive_process_callback_t,
    ) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.wait()
    }
    extern "C" fn terminate<I: ImplUnresponsiveProcessCallback>(
        self_: *mut _cef_unresponsive_process_callback_t,
    ) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.terminate()
    }
}
#[doc = "See [_cef_unresponsive_process_callback_t] for more documentation."]
#[derive(Clone)]
pub struct UnresponsiveProcessCallback(RefGuard<_cef_unresponsive_process_callback_t>);
impl ImplUnresponsiveProcessCallback for UnresponsiveProcessCallback {
    fn wait<'a>(&self) {
        unsafe {
            self.0
                .wait
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn terminate<'a>(&self) {
        unsafe {
            self.0
                .terminate
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_unresponsive_process_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for UnresponsiveProcessCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_unresponsive_process_callback_t> for &UnresponsiveProcessCallback {
    fn as_raw(self) -> *mut _cef_unresponsive_process_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_unresponsive_process_callback_t> for &mut UnresponsiveProcessCallback {
    fn as_raw(self) -> *mut _cef_unresponsive_process_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<UnresponsiveProcessCallback> for *mut _cef_unresponsive_process_callback_t {
    fn as_wrapper(self) -> UnresponsiveProcessCallback {
        UnresponsiveProcessCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_unresponsive_process_callback_t> for UnresponsiveProcessCallback {
    fn into(self) -> *mut _cef_unresponsive_process_callback_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for UnresponsiveProcessCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplSelectClientCertificateCallback: Sized {
    fn select<'a>(&self, cert: &'a mut X509certificate) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_select_client_certificate_callback_t {
        let mut object: _cef_select_client_certificate_callback_t = unsafe { std::mem::zeroed() };
        impl_cef_select_client_certificate_callback_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_select_client_certificate_callback_t {
    use super::*;
    pub fn init_methods<I: ImplSelectClientCertificateCallback>(
        object: &mut _cef_select_client_certificate_callback_t,
    ) {
        object.select = Some(select::<I>);
    }
    extern "C" fn select<I: ImplSelectClientCertificateCallback>(
        self_: *mut _cef_select_client_certificate_callback_t,
        cert: *mut _cef_x509certificate_t,
    ) {
        let (arg_self_, arg_cert) = (self_, cert);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_cert = &mut X509certificate(unsafe { RefGuard::from_raw_add_ref(arg_cert) });
        arg_self_.interface.select(arg_cert)
    }
}
#[doc = "See [_cef_select_client_certificate_callback_t] for more documentation."]
#[derive(Clone)]
pub struct SelectClientCertificateCallback(RefGuard<_cef_select_client_certificate_callback_t>);
impl ImplSelectClientCertificateCallback for SelectClientCertificateCallback {
    fn select<'a>(&self, cert: &'a mut X509certificate) {
        unsafe {
            self.0
                .select
                .map(|f| {
                    let arg_cert = cert;
                    let arg_self_ = self.as_raw();
                    let arg_cert = arg_cert.as_raw();
                    let result = f(arg_self_, arg_cert);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_select_client_certificate_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for SelectClientCertificateCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_select_client_certificate_callback_t>
    for &SelectClientCertificateCallback
{
    fn as_raw(self) -> *mut _cef_select_client_certificate_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_select_client_certificate_callback_t>
    for &mut SelectClientCertificateCallback
{
    fn as_raw(self) -> *mut _cef_select_client_certificate_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<SelectClientCertificateCallback>
    for *mut _cef_select_client_certificate_callback_t
{
    fn as_wrapper(self) -> SelectClientCertificateCallback {
        SelectClientCertificateCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_select_client_certificate_callback_t> for SelectClientCertificateCallback {
    fn into(self) -> *mut _cef_select_client_certificate_callback_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for SelectClientCertificateCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplRequestHandler: Sized {
    fn on_before_browse<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        request: &'a mut Request,
        user_gesture: ::std::os::raw::c_int,
        is_redirect: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn on_open_urlfrom_tab<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        target_url: &'a CefStringUtf16,
        target_disposition: WindowOpenDisposition,
        user_gesture: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_resource_request_handler<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        request: &'a mut Request,
        is_navigation: ::std::os::raw::c_int,
        is_download: ::std::os::raw::c_int,
        request_initiator: &'a CefStringUtf16,
        disable_default_handling: *mut ::std::os::raw::c_int,
    ) -> ResourceRequestHandler {
        unsafe { std::mem::zeroed() }
    }
    fn get_auth_credentials<'a>(
        &self,
        browser: &'a mut Browser,
        origin_url: &'a CefStringUtf16,
        is_proxy: ::std::os::raw::c_int,
        host: &'a CefStringUtf16,
        port: ::std::os::raw::c_int,
        realm: &'a CefStringUtf16,
        scheme: &'a CefStringUtf16,
        callback: &'a mut AuthCallback,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn on_certificate_error<'a>(
        &self,
        browser: &'a mut Browser,
        cert_error: Errorcode,
        request_url: &'a CefStringUtf16,
        ssl_info: &'a mut Sslinfo,
        callback: &'a mut Callback,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn on_select_client_certificate<'a>(
        &self,
        browser: &'a mut Browser,
        is_proxy: ::std::os::raw::c_int,
        host: &'a CefStringUtf16,
        port: ::std::os::raw::c_int,
        certificates: Option<&'a [Option<X509certificate>]>,
        callback: &'a mut SelectClientCertificateCallback,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn on_render_view_ready<'a>(&self, browser: &'a mut Browser) {
        unsafe { std::mem::zeroed() }
    }
    fn on_render_process_unresponsive<'a>(
        &self,
        browser: &'a mut Browser,
        callback: &'a mut UnresponsiveProcessCallback,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn on_render_process_responsive<'a>(&self, browser: &'a mut Browser) {
        unsafe { std::mem::zeroed() }
    }
    fn on_render_process_terminated<'a>(
        &self,
        browser: &'a mut Browser,
        status: TerminationStatus,
        error_code: ::std::os::raw::c_int,
        error_string: &'a CefStringUtf16,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn on_document_available_in_main_frame<'a>(&self, browser: &'a mut Browser) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_request_handler_t {
        let mut object: _cef_request_handler_t = unsafe { std::mem::zeroed() };
        impl_cef_request_handler_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_request_handler_t {
    use super::*;
    pub fn init_methods<I: ImplRequestHandler>(object: &mut _cef_request_handler_t) {
        object.on_before_browse = Some(on_before_browse::<I>);
        object.on_open_urlfrom_tab = Some(on_open_urlfrom_tab::<I>);
        object.get_resource_request_handler = Some(get_resource_request_handler::<I>);
        object.get_auth_credentials = Some(get_auth_credentials::<I>);
        object.on_certificate_error = Some(on_certificate_error::<I>);
        object.on_select_client_certificate = Some(on_select_client_certificate::<I>);
        object.on_render_view_ready = Some(on_render_view_ready::<I>);
        object.on_render_process_unresponsive = Some(on_render_process_unresponsive::<I>);
        object.on_render_process_responsive = Some(on_render_process_responsive::<I>);
        object.on_render_process_terminated = Some(on_render_process_terminated::<I>);
        object.on_document_available_in_main_frame = Some(on_document_available_in_main_frame::<I>);
    }
    extern "C" fn on_before_browse<I: ImplRequestHandler>(
        self_: *mut _cef_request_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        request: *mut _cef_request_t,
        user_gesture: ::std::os::raw::c_int,
        is_redirect: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_frame, arg_request, arg_user_gesture, arg_is_redirect) =
            (self_, browser, frame, request, user_gesture, is_redirect);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_frame) });
        let arg_request = &mut Request(unsafe { RefGuard::from_raw_add_ref(arg_request) });
        let arg_user_gesture = arg_user_gesture.as_raw();
        let arg_is_redirect = arg_is_redirect.as_raw();
        arg_self_
            .interface
            .on_before_browse(
                arg_browser,
                arg_frame,
                arg_request,
                arg_user_gesture,
                arg_is_redirect,
            )
            .into()
    }
    extern "C" fn on_open_urlfrom_tab<I: ImplRequestHandler>(
        self_: *mut _cef_request_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        target_url: *const _cef_string_utf16_t,
        target_disposition: cef_window_open_disposition_t,
        user_gesture: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_browser,
            arg_frame,
            arg_target_url,
            arg_target_disposition,
            arg_user_gesture,
        ) = (
            self_,
            browser,
            frame,
            target_url,
            target_disposition,
            user_gesture,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_frame) });
        let arg_target_url = WrapParamRef::<CefStringUtf16>::from(arg_target_url);
        let arg_target_url = arg_target_url.as_ref();
        let arg_target_disposition = arg_target_disposition.as_raw();
        let arg_user_gesture = arg_user_gesture.as_raw();
        arg_self_
            .interface
            .on_open_urlfrom_tab(
                arg_browser,
                arg_frame,
                arg_target_url,
                arg_target_disposition,
                arg_user_gesture,
            )
            .into()
    }
    extern "C" fn get_resource_request_handler<I: ImplRequestHandler>(
        self_: *mut _cef_request_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        request: *mut _cef_request_t,
        is_navigation: ::std::os::raw::c_int,
        is_download: ::std::os::raw::c_int,
        request_initiator: *const _cef_string_utf16_t,
        disable_default_handling: *mut ::std::os::raw::c_int,
    ) -> *mut _cef_resource_request_handler_t {
        let (
            arg_self_,
            arg_browser,
            arg_frame,
            arg_request,
            arg_is_navigation,
            arg_is_download,
            arg_request_initiator,
            arg_disable_default_handling,
        ) = (
            self_,
            browser,
            frame,
            request,
            is_navigation,
            is_download,
            request_initiator,
            disable_default_handling,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_frame) });
        let arg_request = &mut Request(unsafe { RefGuard::from_raw_add_ref(arg_request) });
        let arg_is_navigation = arg_is_navigation.as_raw();
        let arg_is_download = arg_is_download.as_raw();
        let arg_request_initiator = WrapParamRef::<CefStringUtf16>::from(arg_request_initiator);
        let arg_request_initiator = arg_request_initiator.as_ref();
        let mut arg_disable_default_handling =
            WrapParamRef::<::std::os::raw::c_int>::from(arg_disable_default_handling);
        let arg_disable_default_handling = arg_disable_default_handling.as_mut();
        arg_self_
            .interface
            .get_resource_request_handler(
                arg_browser,
                arg_frame,
                arg_request,
                arg_is_navigation,
                arg_is_download,
                arg_request_initiator,
                arg_disable_default_handling,
            )
            .into()
    }
    extern "C" fn get_auth_credentials<I: ImplRequestHandler>(
        self_: *mut _cef_request_handler_t,
        browser: *mut _cef_browser_t,
        origin_url: *const _cef_string_utf16_t,
        is_proxy: ::std::os::raw::c_int,
        host: *const _cef_string_utf16_t,
        port: ::std::os::raw::c_int,
        realm: *const _cef_string_utf16_t,
        scheme: *const _cef_string_utf16_t,
        callback: *mut _cef_auth_callback_t,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_browser,
            arg_origin_url,
            arg_is_proxy,
            arg_host,
            arg_port,
            arg_realm,
            arg_scheme,
            arg_callback,
        ) = (
            self_, browser, origin_url, is_proxy, host, port, realm, scheme, callback,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_origin_url = WrapParamRef::<CefStringUtf16>::from(arg_origin_url);
        let arg_origin_url = arg_origin_url.as_ref();
        let arg_is_proxy = arg_is_proxy.as_raw();
        let arg_host = WrapParamRef::<CefStringUtf16>::from(arg_host);
        let arg_host = arg_host.as_ref();
        let arg_port = arg_port.as_raw();
        let arg_realm = WrapParamRef::<CefStringUtf16>::from(arg_realm);
        let arg_realm = arg_realm.as_ref();
        let arg_scheme = WrapParamRef::<CefStringUtf16>::from(arg_scheme);
        let arg_scheme = arg_scheme.as_ref();
        let arg_callback = &mut AuthCallback(unsafe { RefGuard::from_raw_add_ref(arg_callback) });
        arg_self_
            .interface
            .get_auth_credentials(
                arg_browser,
                arg_origin_url,
                arg_is_proxy,
                arg_host,
                arg_port,
                arg_realm,
                arg_scheme,
                arg_callback,
            )
            .into()
    }
    extern "C" fn on_certificate_error<I: ImplRequestHandler>(
        self_: *mut _cef_request_handler_t,
        browser: *mut _cef_browser_t,
        cert_error: cef_errorcode_t,
        request_url: *const _cef_string_utf16_t,
        ssl_info: *mut _cef_sslinfo_t,
        callback: *mut _cef_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_cert_error, arg_request_url, arg_ssl_info, arg_callback) =
            (self_, browser, cert_error, request_url, ssl_info, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_cert_error = arg_cert_error.as_raw();
        let arg_request_url = WrapParamRef::<CefStringUtf16>::from(arg_request_url);
        let arg_request_url = arg_request_url.as_ref();
        let arg_ssl_info = &mut Sslinfo(unsafe { RefGuard::from_raw_add_ref(arg_ssl_info) });
        let arg_callback = &mut Callback(unsafe { RefGuard::from_raw_add_ref(arg_callback) });
        arg_self_
            .interface
            .on_certificate_error(
                arg_browser,
                arg_cert_error,
                arg_request_url,
                arg_ssl_info,
                arg_callback,
            )
            .into()
    }
    extern "C" fn on_select_client_certificate<I: ImplRequestHandler>(
        self_: *mut _cef_request_handler_t,
        browser: *mut _cef_browser_t,
        is_proxy: ::std::os::raw::c_int,
        host: *const _cef_string_utf16_t,
        port: ::std::os::raw::c_int,
        certificates_count: usize,
        certificates: *const *mut _cef_x509certificate_t,
        callback: *mut _cef_select_client_certificate_callback_t,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_browser,
            arg_is_proxy,
            arg_host,
            arg_port,
            arg_certificates_count,
            arg_certificates,
            arg_callback,
        ) = (
            self_,
            browser,
            is_proxy,
            host,
            port,
            certificates_count,
            certificates,
            callback,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_is_proxy = arg_is_proxy.as_raw();
        let arg_host = WrapParamRef::<CefStringUtf16>::from(arg_host);
        let arg_host = arg_host.as_ref();
        let arg_port = arg_port.as_raw();
        let vec_certificates = unsafe { arg_certificates.as_ref() }.map(|arg| {
            let arg = unsafe {
                std::slice::from_raw_parts(std::ptr::from_ref(arg), arg_certificates_count)
            };
            arg.iter()
                .map(|arg| {
                    if arg.is_null() {
                        None
                    } else {
                        Some(X509certificate(unsafe { RefGuard::from_raw_add_ref(*arg) }))
                    }
                })
                .collect::<Vec<_>>()
        });
        let arg_certificates = vec_certificates.as_ref().map(|arg| arg.as_slice());
        let arg_callback = &mut SelectClientCertificateCallback(unsafe {
            RefGuard::from_raw_add_ref(arg_callback)
        });
        arg_self_
            .interface
            .on_select_client_certificate(
                arg_browser,
                arg_is_proxy,
                arg_host,
                arg_port,
                arg_certificates,
                arg_callback,
            )
            .into()
    }
    extern "C" fn on_render_view_ready<I: ImplRequestHandler>(
        self_: *mut _cef_request_handler_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        arg_self_.interface.on_render_view_ready(arg_browser)
    }
    extern "C" fn on_render_process_unresponsive<I: ImplRequestHandler>(
        self_: *mut _cef_request_handler_t,
        browser: *mut _cef_browser_t,
        callback: *mut _cef_unresponsive_process_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_callback) = (self_, browser, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_callback =
            &mut UnresponsiveProcessCallback(unsafe { RefGuard::from_raw_add_ref(arg_callback) });
        arg_self_
            .interface
            .on_render_process_unresponsive(arg_browser, arg_callback)
            .into()
    }
    extern "C" fn on_render_process_responsive<I: ImplRequestHandler>(
        self_: *mut _cef_request_handler_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        arg_self_
            .interface
            .on_render_process_responsive(arg_browser)
    }
    extern "C" fn on_render_process_terminated<I: ImplRequestHandler>(
        self_: *mut _cef_request_handler_t,
        browser: *mut _cef_browser_t,
        status: cef_termination_status_t,
        error_code: ::std::os::raw::c_int,
        error_string: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_browser, arg_status, arg_error_code, arg_error_string) =
            (self_, browser, status, error_code, error_string);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_status = arg_status.as_raw();
        let arg_error_code = arg_error_code.as_raw();
        let arg_error_string = WrapParamRef::<CefStringUtf16>::from(arg_error_string);
        let arg_error_string = arg_error_string.as_ref();
        arg_self_.interface.on_render_process_terminated(
            arg_browser,
            arg_status,
            arg_error_code,
            arg_error_string,
        )
    }
    extern "C" fn on_document_available_in_main_frame<I: ImplRequestHandler>(
        self_: *mut _cef_request_handler_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        arg_self_
            .interface
            .on_document_available_in_main_frame(arg_browser)
    }
}
#[doc = "See [_cef_request_handler_t] for more documentation."]
#[derive(Clone)]
pub struct RequestHandler(RefGuard<_cef_request_handler_t>);
impl ImplRequestHandler for RequestHandler {
    fn on_before_browse<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        request: &'a mut Request,
        user_gesture: ::std::os::raw::c_int,
        is_redirect: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_before_browse
                .map(|f| {
                    let (arg_browser, arg_frame, arg_request, arg_user_gesture, arg_is_redirect) =
                        (browser, frame, request, user_gesture, is_redirect);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_frame = arg_frame.as_raw();
                    let arg_request = arg_request.as_raw();
                    let arg_user_gesture = arg_user_gesture;
                    let arg_is_redirect = arg_is_redirect;
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_request,
                        arg_user_gesture,
                        arg_is_redirect,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_open_urlfrom_tab<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        target_url: &'a CefStringUtf16,
        target_disposition: WindowOpenDisposition,
        user_gesture: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_open_urlfrom_tab
                .map(|f| {
                    let (
                        arg_browser,
                        arg_frame,
                        arg_target_url,
                        arg_target_disposition,
                        arg_user_gesture,
                    ) = (browser, frame, target_url, target_disposition, user_gesture);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_frame = arg_frame.as_raw();
                    let arg_target_url = arg_target_url.as_raw();
                    let arg_target_disposition = arg_target_disposition.as_raw();
                    let arg_user_gesture = arg_user_gesture;
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_target_url,
                        arg_target_disposition,
                        arg_user_gesture,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_resource_request_handler<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        request: &'a mut Request,
        is_navigation: ::std::os::raw::c_int,
        is_download: ::std::os::raw::c_int,
        request_initiator: &'a CefStringUtf16,
        disable_default_handling: *mut ::std::os::raw::c_int,
    ) -> ResourceRequestHandler {
        unsafe {
            self.0
                .get_resource_request_handler
                .map(|f| {
                    let (
                        arg_browser,
                        arg_frame,
                        arg_request,
                        arg_is_navigation,
                        arg_is_download,
                        arg_request_initiator,
                        arg_disable_default_handling,
                    ) = (
                        browser,
                        frame,
                        request,
                        is_navigation,
                        is_download,
                        request_initiator,
                        disable_default_handling,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_frame = arg_frame.as_raw();
                    let arg_request = arg_request.as_raw();
                    let arg_is_navigation = arg_is_navigation;
                    let arg_is_download = arg_is_download;
                    let arg_request_initiator = arg_request_initiator.as_raw();
                    let arg_disable_default_handling = arg_disable_default_handling as *mut _;
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_request,
                        arg_is_navigation,
                        arg_is_download,
                        arg_request_initiator,
                        arg_disable_default_handling,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_auth_credentials<'a>(
        &self,
        browser: &'a mut Browser,
        origin_url: &'a CefStringUtf16,
        is_proxy: ::std::os::raw::c_int,
        host: &'a CefStringUtf16,
        port: ::std::os::raw::c_int,
        realm: &'a CefStringUtf16,
        scheme: &'a CefStringUtf16,
        callback: &'a mut AuthCallback,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_auth_credentials
                .map(|f| {
                    let (
                        arg_browser,
                        arg_origin_url,
                        arg_is_proxy,
                        arg_host,
                        arg_port,
                        arg_realm,
                        arg_scheme,
                        arg_callback,
                    ) = (
                        browser, origin_url, is_proxy, host, port, realm, scheme, callback,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_origin_url = arg_origin_url.as_raw();
                    let arg_is_proxy = arg_is_proxy;
                    let arg_host = arg_host.as_raw();
                    let arg_port = arg_port;
                    let arg_realm = arg_realm.as_raw();
                    let arg_scheme = arg_scheme.as_raw();
                    let arg_callback = arg_callback.as_raw();
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_origin_url,
                        arg_is_proxy,
                        arg_host,
                        arg_port,
                        arg_realm,
                        arg_scheme,
                        arg_callback,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_certificate_error<'a>(
        &self,
        browser: &'a mut Browser,
        cert_error: Errorcode,
        request_url: &'a CefStringUtf16,
        ssl_info: &'a mut Sslinfo,
        callback: &'a mut Callback,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_certificate_error
                .map(|f| {
                    let (arg_browser, arg_cert_error, arg_request_url, arg_ssl_info, arg_callback) =
                        (browser, cert_error, request_url, ssl_info, callback);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_cert_error = arg_cert_error.as_raw();
                    let arg_request_url = arg_request_url.as_raw();
                    let arg_ssl_info = arg_ssl_info.as_raw();
                    let arg_callback = arg_callback.as_raw();
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_cert_error,
                        arg_request_url,
                        arg_ssl_info,
                        arg_callback,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_select_client_certificate<'a>(
        &self,
        browser: &'a mut Browser,
        is_proxy: ::std::os::raw::c_int,
        host: &'a CefStringUtf16,
        port: ::std::os::raw::c_int,
        certificates: Option<&'a [Option<X509certificate>]>,
        callback: &'a mut SelectClientCertificateCallback,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_select_client_certificate
                .map(|f| {
                    let (
                        arg_browser,
                        arg_is_proxy,
                        arg_host,
                        arg_port,
                        arg_certificates,
                        arg_callback,
                    ) = (browser, is_proxy, host, port, certificates, callback);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_is_proxy = arg_is_proxy;
                    let arg_host = arg_host.as_raw();
                    let arg_port = arg_port;
                    let mut arg_certificates_count = arg_certificates
                        .map(|slice| slice.len())
                        .unwrap_or_default();
                    let vec_certificates = arg_certificates
                        .as_ref()
                        .map(|slice| {
                            slice
                                .iter()
                                .map(|elem| {
                                    elem.as_ref()
                                        .map(|elem| elem.as_raw())
                                        .unwrap_or(std::ptr::null_mut())
                                })
                                .collect::<Vec<_>>()
                        })
                        .unwrap_or_default();
                    let arg_certificates = if vec_certificates.is_empty() {
                        std::ptr::null()
                    } else {
                        vec_certificates.as_ptr()
                    };
                    let arg_callback = arg_callback.as_raw();
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_is_proxy,
                        arg_host,
                        arg_port,
                        arg_certificates_count,
                        arg_certificates,
                        arg_callback,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_render_view_ready<'a>(&self, browser: &'a mut Browser) {
        unsafe {
            self.0
                .on_render_view_ready
                .map(|f| {
                    let arg_browser = browser;
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let result = f(arg_self_, arg_browser);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_render_process_unresponsive<'a>(
        &self,
        browser: &'a mut Browser,
        callback: &'a mut UnresponsiveProcessCallback,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_render_process_unresponsive
                .map(|f| {
                    let (arg_browser, arg_callback) = (browser, callback);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_callback = arg_callback.as_raw();
                    let result = f(arg_self_, arg_browser, arg_callback);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_render_process_responsive<'a>(&self, browser: &'a mut Browser) {
        unsafe {
            self.0
                .on_render_process_responsive
                .map(|f| {
                    let arg_browser = browser;
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let result = f(arg_self_, arg_browser);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_render_process_terminated<'a>(
        &self,
        browser: &'a mut Browser,
        status: TerminationStatus,
        error_code: ::std::os::raw::c_int,
        error_string: &'a CefStringUtf16,
    ) {
        unsafe {
            self.0
                .on_render_process_terminated
                .map(|f| {
                    let (arg_browser, arg_status, arg_error_code, arg_error_string) =
                        (browser, status, error_code, error_string);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_status = arg_status.as_raw();
                    let arg_error_code = arg_error_code;
                    let arg_error_string = arg_error_string.as_raw();
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_status,
                        arg_error_code,
                        arg_error_string,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_document_available_in_main_frame<'a>(&self, browser: &'a mut Browser) {
        unsafe {
            self.0
                .on_document_available_in_main_frame
                .map(|f| {
                    let arg_browser = browser;
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let result = f(arg_self_, arg_browser);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_request_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for RequestHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_request_handler_t> for &RequestHandler {
    fn as_raw(self) -> *mut _cef_request_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_request_handler_t> for &mut RequestHandler {
    fn as_raw(self) -> *mut _cef_request_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<RequestHandler> for *mut _cef_request_handler_t {
    fn as_wrapper(self) -> RequestHandler {
        RequestHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_request_handler_t> for RequestHandler {
    fn into(self) -> *mut _cef_request_handler_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for RequestHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplClient: Sized {
    fn get_audio_handler<'a>(&self) -> AudioHandler {
        unsafe { std::mem::zeroed() }
    }
    fn get_command_handler<'a>(&self) -> CommandHandler {
        unsafe { std::mem::zeroed() }
    }
    fn get_context_menu_handler<'a>(&self) -> ContextMenuHandler {
        unsafe { std::mem::zeroed() }
    }
    fn get_dialog_handler<'a>(&self) -> DialogHandler {
        unsafe { std::mem::zeroed() }
    }
    fn get_display_handler<'a>(&self) -> DisplayHandler {
        unsafe { std::mem::zeroed() }
    }
    fn get_download_handler<'a>(&self) -> DownloadHandler {
        unsafe { std::mem::zeroed() }
    }
    fn get_drag_handler<'a>(&self) -> DragHandler {
        unsafe { std::mem::zeroed() }
    }
    fn get_find_handler<'a>(&self) -> FindHandler {
        unsafe { std::mem::zeroed() }
    }
    fn get_focus_handler<'a>(&self) -> FocusHandler {
        unsafe { std::mem::zeroed() }
    }
    fn get_frame_handler<'a>(&self) -> FrameHandler {
        unsafe { std::mem::zeroed() }
    }
    fn get_permission_handler<'a>(&self) -> PermissionHandler {
        unsafe { std::mem::zeroed() }
    }
    fn get_jsdialog_handler<'a>(&self) -> JsdialogHandler {
        unsafe { std::mem::zeroed() }
    }
    fn get_keyboard_handler<'a>(&self) -> KeyboardHandler {
        unsafe { std::mem::zeroed() }
    }
    fn get_life_span_handler<'a>(&self) -> LifeSpanHandler {
        unsafe { std::mem::zeroed() }
    }
    fn get_load_handler<'a>(&self) -> LoadHandler {
        unsafe { std::mem::zeroed() }
    }
    fn get_print_handler<'a>(&self) -> PrintHandler {
        unsafe { std::mem::zeroed() }
    }
    fn get_render_handler<'a>(&self) -> RenderHandler {
        unsafe { std::mem::zeroed() }
    }
    fn get_request_handler<'a>(&self) -> RequestHandler {
        unsafe { std::mem::zeroed() }
    }
    fn on_process_message_received<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        source_process: ProcessId,
        message: &'a mut ProcessMessage,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_client_t {
        let mut object: _cef_client_t = unsafe { std::mem::zeroed() };
        impl_cef_client_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_client_t {
    use super::*;
    pub fn init_methods<I: ImplClient>(object: &mut _cef_client_t) {
        object.get_audio_handler = Some(get_audio_handler::<I>);
        object.get_command_handler = Some(get_command_handler::<I>);
        object.get_context_menu_handler = Some(get_context_menu_handler::<I>);
        object.get_dialog_handler = Some(get_dialog_handler::<I>);
        object.get_display_handler = Some(get_display_handler::<I>);
        object.get_download_handler = Some(get_download_handler::<I>);
        object.get_drag_handler = Some(get_drag_handler::<I>);
        object.get_find_handler = Some(get_find_handler::<I>);
        object.get_focus_handler = Some(get_focus_handler::<I>);
        object.get_frame_handler = Some(get_frame_handler::<I>);
        object.get_permission_handler = Some(get_permission_handler::<I>);
        object.get_jsdialog_handler = Some(get_jsdialog_handler::<I>);
        object.get_keyboard_handler = Some(get_keyboard_handler::<I>);
        object.get_life_span_handler = Some(get_life_span_handler::<I>);
        object.get_load_handler = Some(get_load_handler::<I>);
        object.get_print_handler = Some(get_print_handler::<I>);
        object.get_render_handler = Some(get_render_handler::<I>);
        object.get_request_handler = Some(get_request_handler::<I>);
        object.on_process_message_received = Some(on_process_message_received::<I>);
    }
    extern "C" fn get_audio_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_audio_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_audio_handler().into()
    }
    extern "C" fn get_command_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_command_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_command_handler().into()
    }
    extern "C" fn get_context_menu_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_context_menu_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_context_menu_handler().into()
    }
    extern "C" fn get_dialog_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_dialog_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_dialog_handler().into()
    }
    extern "C" fn get_display_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_display_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_display_handler().into()
    }
    extern "C" fn get_download_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_download_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_download_handler().into()
    }
    extern "C" fn get_drag_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_drag_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_drag_handler().into()
    }
    extern "C" fn get_find_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_find_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_find_handler().into()
    }
    extern "C" fn get_focus_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_focus_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_focus_handler().into()
    }
    extern "C" fn get_frame_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_frame_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_frame_handler().into()
    }
    extern "C" fn get_permission_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_permission_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_permission_handler().into()
    }
    extern "C" fn get_jsdialog_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_jsdialog_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_jsdialog_handler().into()
    }
    extern "C" fn get_keyboard_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_keyboard_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_keyboard_handler().into()
    }
    extern "C" fn get_life_span_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_life_span_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_life_span_handler().into()
    }
    extern "C" fn get_load_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_load_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_load_handler().into()
    }
    extern "C" fn get_print_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_print_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_print_handler().into()
    }
    extern "C" fn get_render_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_render_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_render_handler().into()
    }
    extern "C" fn get_request_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_request_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_request_handler().into()
    }
    extern "C" fn on_process_message_received<I: ImplClient>(
        self_: *mut _cef_client_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        source_process: cef_process_id_t,
        message: *mut _cef_process_message_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_frame, arg_source_process, arg_message) =
            (self_, browser, frame, source_process, message);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_frame) });
        let arg_source_process = arg_source_process.as_raw();
        let arg_message = &mut ProcessMessage(unsafe { RefGuard::from_raw_add_ref(arg_message) });
        arg_self_
            .interface
            .on_process_message_received(arg_browser, arg_frame, arg_source_process, arg_message)
            .into()
    }
}
#[doc = "See [_cef_client_t] for more documentation."]
#[derive(Clone)]
pub struct Client(RefGuard<_cef_client_t>);
impl ImplClient for Client {
    fn get_audio_handler<'a>(&self) -> AudioHandler {
        unsafe {
            self.0
                .get_audio_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_command_handler<'a>(&self) -> CommandHandler {
        unsafe {
            self.0
                .get_command_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_context_menu_handler<'a>(&self) -> ContextMenuHandler {
        unsafe {
            self.0
                .get_context_menu_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_dialog_handler<'a>(&self) -> DialogHandler {
        unsafe {
            self.0
                .get_dialog_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_display_handler<'a>(&self) -> DisplayHandler {
        unsafe {
            self.0
                .get_display_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_download_handler<'a>(&self) -> DownloadHandler {
        unsafe {
            self.0
                .get_download_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_drag_handler<'a>(&self) -> DragHandler {
        unsafe {
            self.0
                .get_drag_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_find_handler<'a>(&self) -> FindHandler {
        unsafe {
            self.0
                .get_find_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_focus_handler<'a>(&self) -> FocusHandler {
        unsafe {
            self.0
                .get_focus_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_frame_handler<'a>(&self) -> FrameHandler {
        unsafe {
            self.0
                .get_frame_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_permission_handler<'a>(&self) -> PermissionHandler {
        unsafe {
            self.0
                .get_permission_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_jsdialog_handler<'a>(&self) -> JsdialogHandler {
        unsafe {
            self.0
                .get_jsdialog_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_keyboard_handler<'a>(&self) -> KeyboardHandler {
        unsafe {
            self.0
                .get_keyboard_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_life_span_handler<'a>(&self) -> LifeSpanHandler {
        unsafe {
            self.0
                .get_life_span_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_load_handler<'a>(&self) -> LoadHandler {
        unsafe {
            self.0
                .get_load_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_print_handler<'a>(&self) -> PrintHandler {
        unsafe {
            self.0
                .get_print_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_render_handler<'a>(&self) -> RenderHandler {
        unsafe {
            self.0
                .get_render_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_request_handler<'a>(&self) -> RequestHandler {
        unsafe {
            self.0
                .get_request_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_process_message_received<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        source_process: ProcessId,
        message: &'a mut ProcessMessage,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_process_message_received
                .map(|f| {
                    let (arg_browser, arg_frame, arg_source_process, arg_message) =
                        (browser, frame, source_process, message);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_frame = arg_frame.as_raw();
                    let arg_source_process = arg_source_process.as_raw();
                    let arg_message = arg_message.as_raw();
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_source_process,
                        arg_message,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_client_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Client {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_client_t> for &Client {
    fn as_raw(self) -> *mut _cef_client_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_client_t> for &mut Client {
    fn as_raw(self) -> *mut _cef_client_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<Client> for *mut _cef_client_t {
    fn as_wrapper(self) -> Client {
        Client(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_client_t> for Client {
    fn into(self) -> *mut _cef_client_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for Client {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplCommandLine: Sized {
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_read_only<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn copy<'a>(&self) -> CommandLine {
        unsafe { std::mem::zeroed() }
    }
    fn init_from_argv<'a>(
        &self,
        argc: ::std::os::raw::c_int,
        argv: *const *const ::std::os::raw::c_char,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn init_from_string<'a>(&self, command_line: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn reset<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn get_argv<'a>(&self, argv: &'a mut CefStringList) {
        unsafe { std::mem::zeroed() }
    }
    fn get_command_line_string<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_program<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn set_program<'a>(&self, program: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn has_switches<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn has_switch<'a>(&self, name: &'a CefStringUtf16) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_switch_value<'a>(&self, name: &'a CefStringUtf16) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_switches<'a>(&self, switches: &'a mut CefStringMap) {
        unsafe { std::mem::zeroed() }
    }
    fn append_switch<'a>(&self, name: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn append_switch_with_value<'a>(&self, name: &'a CefStringUtf16, value: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn has_arguments<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_arguments<'a>(&self, arguments: &'a mut CefStringList) {
        unsafe { std::mem::zeroed() }
    }
    fn append_argument<'a>(&self, argument: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn prepend_wrapper<'a>(&self, wrapper: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_command_line_t {
        let mut object: _cef_command_line_t = unsafe { std::mem::zeroed() };
        impl_cef_command_line_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_command_line_t {
    use super::*;
    pub fn init_methods<I: ImplCommandLine>(object: &mut _cef_command_line_t) {
        object.is_valid = Some(is_valid::<I>);
        object.is_read_only = Some(is_read_only::<I>);
        object.copy = Some(copy::<I>);
        object.init_from_argv = Some(init_from_argv::<I>);
        object.init_from_string = Some(init_from_string::<I>);
        object.reset = Some(reset::<I>);
        object.get_argv = Some(get_argv::<I>);
        object.get_command_line_string = Some(get_command_line_string::<I>);
        object.get_program = Some(get_program::<I>);
        object.set_program = Some(set_program::<I>);
        object.has_switches = Some(has_switches::<I>);
        object.has_switch = Some(has_switch::<I>);
        object.get_switch_value = Some(get_switch_value::<I>);
        object.get_switches = Some(get_switches::<I>);
        object.append_switch = Some(append_switch::<I>);
        object.append_switch_with_value = Some(append_switch_with_value::<I>);
        object.has_arguments = Some(has_arguments::<I>);
        object.get_arguments = Some(get_arguments::<I>);
        object.append_argument = Some(append_argument::<I>);
        object.prepend_wrapper = Some(prepend_wrapper::<I>);
    }
    extern "C" fn is_valid<I: ImplCommandLine>(
        self_: *mut _cef_command_line_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_valid().into()
    }
    extern "C" fn is_read_only<I: ImplCommandLine>(
        self_: *mut _cef_command_line_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_read_only().into()
    }
    extern "C" fn copy<I: ImplCommandLine>(
        self_: *mut _cef_command_line_t,
    ) -> *mut _cef_command_line_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.copy().into()
    }
    extern "C" fn init_from_argv<I: ImplCommandLine>(
        self_: *mut _cef_command_line_t,
        argc: ::std::os::raw::c_int,
        argv: *const *const ::std::os::raw::c_char,
    ) {
        let (arg_self_, arg_argc, arg_argv) = (self_, argc, argv);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_argc = arg_argc.as_raw();
        let arg_argv = WrapParamRef::<::std::os::raw::c_char>::from(arg_argv);
        let arg_argv = arg_argv.as_ref();
        arg_self_.interface.init_from_argv(arg_argc, arg_argv)
    }
    extern "C" fn init_from_string<I: ImplCommandLine>(
        self_: *mut _cef_command_line_t,
        command_line: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_command_line) = (self_, command_line);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_line = WrapParamRef::<CefStringUtf16>::from(arg_command_line);
        let arg_command_line = arg_command_line.as_ref();
        arg_self_.interface.init_from_string(arg_command_line)
    }
    extern "C" fn reset<I: ImplCommandLine>(self_: *mut _cef_command_line_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.reset()
    }
    extern "C" fn get_argv<I: ImplCommandLine>(
        self_: *mut _cef_command_line_t,
        argv: *mut _cef_string_list_t,
    ) {
        let (arg_self_, arg_argv) = (self_, argv);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_argv = WrapParamRef::<CefStringList>::from(arg_argv);
        let arg_argv = arg_argv.as_mut();
        arg_self_.interface.get_argv(arg_argv)
    }
    extern "C" fn get_command_line_string<I: ImplCommandLine>(
        self_: *mut _cef_command_line_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_command_line_string().into()
    }
    extern "C" fn get_program<I: ImplCommandLine>(
        self_: *mut _cef_command_line_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_program().into()
    }
    extern "C" fn set_program<I: ImplCommandLine>(
        self_: *mut _cef_command_line_t,
        program: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_program) = (self_, program);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_program = WrapParamRef::<CefStringUtf16>::from(arg_program);
        let arg_program = arg_program.as_ref();
        arg_self_.interface.set_program(arg_program)
    }
    extern "C" fn has_switches<I: ImplCommandLine>(
        self_: *mut _cef_command_line_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.has_switches().into()
    }
    extern "C" fn has_switch<I: ImplCommandLine>(
        self_: *mut _cef_command_line_t,
        name: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_name) = (self_, name);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = WrapParamRef::<CefStringUtf16>::from(arg_name);
        let arg_name = arg_name.as_ref();
        arg_self_.interface.has_switch(arg_name).into()
    }
    extern "C" fn get_switch_value<I: ImplCommandLine>(
        self_: *mut _cef_command_line_t,
        name: *const _cef_string_utf16_t,
    ) -> *mut _cef_string_utf16_t {
        let (arg_self_, arg_name) = (self_, name);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = WrapParamRef::<CefStringUtf16>::from(arg_name);
        let arg_name = arg_name.as_ref();
        arg_self_.interface.get_switch_value(arg_name).into()
    }
    extern "C" fn get_switches<I: ImplCommandLine>(
        self_: *mut _cef_command_line_t,
        switches: *mut _cef_string_map_t,
    ) {
        let (arg_self_, arg_switches) = (self_, switches);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_switches = WrapParamRef::<CefStringMap>::from(arg_switches);
        let arg_switches = arg_switches.as_mut();
        arg_self_.interface.get_switches(arg_switches)
    }
    extern "C" fn append_switch<I: ImplCommandLine>(
        self_: *mut _cef_command_line_t,
        name: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_name) = (self_, name);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = WrapParamRef::<CefStringUtf16>::from(arg_name);
        let arg_name = arg_name.as_ref();
        arg_self_.interface.append_switch(arg_name)
    }
    extern "C" fn append_switch_with_value<I: ImplCommandLine>(
        self_: *mut _cef_command_line_t,
        name: *const _cef_string_utf16_t,
        value: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_name, arg_value) = (self_, name, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = WrapParamRef::<CefStringUtf16>::from(arg_name);
        let arg_name = arg_name.as_ref();
        let arg_value = WrapParamRef::<CefStringUtf16>::from(arg_value);
        let arg_value = arg_value.as_ref();
        arg_self_
            .interface
            .append_switch_with_value(arg_name, arg_value)
    }
    extern "C" fn has_arguments<I: ImplCommandLine>(
        self_: *mut _cef_command_line_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.has_arguments().into()
    }
    extern "C" fn get_arguments<I: ImplCommandLine>(
        self_: *mut _cef_command_line_t,
        arguments: *mut _cef_string_list_t,
    ) {
        let (arg_self_, arg_arguments) = (self_, arguments);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_arguments = WrapParamRef::<CefStringList>::from(arg_arguments);
        let arg_arguments = arg_arguments.as_mut();
        arg_self_.interface.get_arguments(arg_arguments)
    }
    extern "C" fn append_argument<I: ImplCommandLine>(
        self_: *mut _cef_command_line_t,
        argument: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_argument) = (self_, argument);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_argument = WrapParamRef::<CefStringUtf16>::from(arg_argument);
        let arg_argument = arg_argument.as_ref();
        arg_self_.interface.append_argument(arg_argument)
    }
    extern "C" fn prepend_wrapper<I: ImplCommandLine>(
        self_: *mut _cef_command_line_t,
        wrapper: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_wrapper) = (self_, wrapper);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_wrapper = WrapParamRef::<CefStringUtf16>::from(arg_wrapper);
        let arg_wrapper = arg_wrapper.as_ref();
        arg_self_.interface.prepend_wrapper(arg_wrapper)
    }
}
#[doc = "See [_cef_command_line_t] for more documentation."]
#[derive(Clone)]
pub struct CommandLine(RefGuard<_cef_command_line_t>);
impl ImplCommandLine for CommandLine {
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_read_only<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_read_only
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn copy<'a>(&self) -> CommandLine {
        unsafe {
            self.0
                .copy
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn init_from_argv<'a>(
        &self,
        argc: ::std::os::raw::c_int,
        argv: *const *const ::std::os::raw::c_char,
    ) {
        unsafe {
            self.0
                .init_from_argv
                .map(|f| {
                    let (arg_argc, arg_argv) = (argc, argv);
                    let arg_self_ = self.as_raw();
                    let arg_argc = arg_argc;
                    let arg_argv = arg_argv as *const _;
                    let result = f(arg_self_, arg_argc, arg_argv);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn init_from_string<'a>(&self, command_line: &'a CefStringUtf16) {
        unsafe {
            self.0
                .init_from_string
                .map(|f| {
                    let arg_command_line = command_line;
                    let arg_self_ = self.as_raw();
                    let arg_command_line = arg_command_line.as_raw();
                    let result = f(arg_self_, arg_command_line);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn reset<'a>(&self) {
        unsafe {
            self.0
                .reset
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_argv<'a>(&self, argv: &'a mut CefStringList) {
        unsafe {
            self.0
                .get_argv
                .map(|f| {
                    let arg_argv = argv;
                    let arg_self_ = self.as_raw();
                    let arg_argv = arg_argv.as_raw();
                    let result = f(arg_self_, arg_argv);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_command_line_string<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_command_line_string
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_program<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_program
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_program<'a>(&self, program: &'a CefStringUtf16) {
        unsafe {
            self.0
                .set_program
                .map(|f| {
                    let arg_program = program;
                    let arg_self_ = self.as_raw();
                    let arg_program = arg_program.as_raw();
                    let result = f(arg_self_, arg_program);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn has_switches<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_switches
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn has_switch<'a>(&self, name: &'a CefStringUtf16) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_switch
                .map(|f| {
                    let arg_name = name;
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.as_raw();
                    let result = f(arg_self_, arg_name);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_switch_value<'a>(&self, name: &'a CefStringUtf16) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_switch_value
                .map(|f| {
                    let arg_name = name;
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.as_raw();
                    let result = f(arg_self_, arg_name);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_switches<'a>(&self, switches: &'a mut CefStringMap) {
        unsafe {
            self.0
                .get_switches
                .map(|f| {
                    let arg_switches = switches;
                    let arg_self_ = self.as_raw();
                    let arg_switches = arg_switches.as_raw();
                    let result = f(arg_self_, arg_switches);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn append_switch<'a>(&self, name: &'a CefStringUtf16) {
        unsafe {
            self.0
                .append_switch
                .map(|f| {
                    let arg_name = name;
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.as_raw();
                    let result = f(arg_self_, arg_name);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn append_switch_with_value<'a>(&self, name: &'a CefStringUtf16, value: &'a CefStringUtf16) {
        unsafe {
            self.0
                .append_switch_with_value
                .map(|f| {
                    let (arg_name, arg_value) = (name, value);
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.as_raw();
                    let arg_value = arg_value.as_raw();
                    let result = f(arg_self_, arg_name, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn has_arguments<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_arguments
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_arguments<'a>(&self, arguments: &'a mut CefStringList) {
        unsafe {
            self.0
                .get_arguments
                .map(|f| {
                    let arg_arguments = arguments;
                    let arg_self_ = self.as_raw();
                    let arg_arguments = arg_arguments.as_raw();
                    let result = f(arg_self_, arg_arguments);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn append_argument<'a>(&self, argument: &'a CefStringUtf16) {
        unsafe {
            self.0
                .append_argument
                .map(|f| {
                    let arg_argument = argument;
                    let arg_self_ = self.as_raw();
                    let arg_argument = arg_argument.as_raw();
                    let result = f(arg_self_, arg_argument);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn prepend_wrapper<'a>(&self, wrapper: &'a CefStringUtf16) {
        unsafe {
            self.0
                .prepend_wrapper
                .map(|f| {
                    let arg_wrapper = wrapper;
                    let arg_self_ = self.as_raw();
                    let arg_wrapper = arg_wrapper.as_raw();
                    let result = f(arg_self_, arg_wrapper);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_command_line_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for CommandLine {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_command_line_t> for &CommandLine {
    fn as_raw(self) -> *mut _cef_command_line_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_command_line_t> for &mut CommandLine {
    fn as_raw(self) -> *mut _cef_command_line_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<CommandLine> for *mut _cef_command_line_t {
    fn as_wrapper(self) -> CommandLine {
        CommandLine(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_command_line_t> for CommandLine {
    fn into(self) -> *mut _cef_command_line_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for CommandLine {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplRequestContextHandler: Sized {
    fn on_request_context_initialized<'a>(&self, request_context: &'a mut RequestContext) {
        unsafe { std::mem::zeroed() }
    }
    fn get_resource_request_handler<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        request: &'a mut Request,
        is_navigation: ::std::os::raw::c_int,
        is_download: ::std::os::raw::c_int,
        request_initiator: &'a CefStringUtf16,
        disable_default_handling: *mut ::std::os::raw::c_int,
    ) -> ResourceRequestHandler {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_request_context_handler_t {
        let mut object: _cef_request_context_handler_t = unsafe { std::mem::zeroed() };
        impl_cef_request_context_handler_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_request_context_handler_t {
    use super::*;
    pub fn init_methods<I: ImplRequestContextHandler>(object: &mut _cef_request_context_handler_t) {
        object.on_request_context_initialized = Some(on_request_context_initialized::<I>);
        object.get_resource_request_handler = Some(get_resource_request_handler::<I>);
    }
    extern "C" fn on_request_context_initialized<I: ImplRequestContextHandler>(
        self_: *mut _cef_request_context_handler_t,
        request_context: *mut _cef_request_context_t,
    ) {
        let (arg_self_, arg_request_context) = (self_, request_context);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_request_context =
            &mut RequestContext(unsafe { RefGuard::from_raw_add_ref(arg_request_context) });
        arg_self_
            .interface
            .on_request_context_initialized(arg_request_context)
    }
    extern "C" fn get_resource_request_handler<I: ImplRequestContextHandler>(
        self_: *mut _cef_request_context_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        request: *mut _cef_request_t,
        is_navigation: ::std::os::raw::c_int,
        is_download: ::std::os::raw::c_int,
        request_initiator: *const _cef_string_utf16_t,
        disable_default_handling: *mut ::std::os::raw::c_int,
    ) -> *mut _cef_resource_request_handler_t {
        let (
            arg_self_,
            arg_browser,
            arg_frame,
            arg_request,
            arg_is_navigation,
            arg_is_download,
            arg_request_initiator,
            arg_disable_default_handling,
        ) = (
            self_,
            browser,
            frame,
            request,
            is_navigation,
            is_download,
            request_initiator,
            disable_default_handling,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_frame) });
        let arg_request = &mut Request(unsafe { RefGuard::from_raw_add_ref(arg_request) });
        let arg_is_navigation = arg_is_navigation.as_raw();
        let arg_is_download = arg_is_download.as_raw();
        let arg_request_initiator = WrapParamRef::<CefStringUtf16>::from(arg_request_initiator);
        let arg_request_initiator = arg_request_initiator.as_ref();
        let mut arg_disable_default_handling =
            WrapParamRef::<::std::os::raw::c_int>::from(arg_disable_default_handling);
        let arg_disable_default_handling = arg_disable_default_handling.as_mut();
        arg_self_
            .interface
            .get_resource_request_handler(
                arg_browser,
                arg_frame,
                arg_request,
                arg_is_navigation,
                arg_is_download,
                arg_request_initiator,
                arg_disable_default_handling,
            )
            .into()
    }
}
#[doc = "See [_cef_request_context_handler_t] for more documentation."]
#[derive(Clone)]
pub struct RequestContextHandler(RefGuard<_cef_request_context_handler_t>);
impl ImplRequestContextHandler for RequestContextHandler {
    fn on_request_context_initialized<'a>(&self, request_context: &'a mut RequestContext) {
        unsafe {
            self.0
                .on_request_context_initialized
                .map(|f| {
                    let arg_request_context = request_context;
                    let arg_self_ = self.as_raw();
                    let arg_request_context = arg_request_context.as_raw();
                    let result = f(arg_self_, arg_request_context);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_resource_request_handler<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        request: &'a mut Request,
        is_navigation: ::std::os::raw::c_int,
        is_download: ::std::os::raw::c_int,
        request_initiator: &'a CefStringUtf16,
        disable_default_handling: *mut ::std::os::raw::c_int,
    ) -> ResourceRequestHandler {
        unsafe {
            self.0
                .get_resource_request_handler
                .map(|f| {
                    let (
                        arg_browser,
                        arg_frame,
                        arg_request,
                        arg_is_navigation,
                        arg_is_download,
                        arg_request_initiator,
                        arg_disable_default_handling,
                    ) = (
                        browser,
                        frame,
                        request,
                        is_navigation,
                        is_download,
                        request_initiator,
                        disable_default_handling,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_frame = arg_frame.as_raw();
                    let arg_request = arg_request.as_raw();
                    let arg_is_navigation = arg_is_navigation;
                    let arg_is_download = arg_is_download;
                    let arg_request_initiator = arg_request_initiator.as_raw();
                    let arg_disable_default_handling = arg_disable_default_handling as *mut _;
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_request,
                        arg_is_navigation,
                        arg_is_download,
                        arg_request_initiator,
                        arg_disable_default_handling,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_request_context_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for RequestContextHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_request_context_handler_t> for &RequestContextHandler {
    fn as_raw(self) -> *mut _cef_request_context_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_request_context_handler_t> for &mut RequestContextHandler {
    fn as_raw(self) -> *mut _cef_request_context_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<RequestContextHandler> for *mut _cef_request_context_handler_t {
    fn as_wrapper(self) -> RequestContextHandler {
        RequestContextHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_request_context_handler_t> for RequestContextHandler {
    fn into(self) -> *mut _cef_request_context_handler_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for RequestContextHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplBrowserProcessHandler: Sized {
    fn on_register_custom_preferences<'a>(
        &self,
        type_: PreferencesType,
        registrar: &'a mut PreferenceRegistrar,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn on_context_initialized<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn on_before_child_process_launch<'a>(&self, command_line: &'a mut CommandLine) {
        unsafe { std::mem::zeroed() }
    }
    fn on_already_running_app_relaunch<'a>(
        &self,
        command_line: &'a mut CommandLine,
        current_directory: &'a CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn on_schedule_message_pump_work<'a>(&self, delay_ms: i64) {
        unsafe { std::mem::zeroed() }
    }
    fn get_default_client<'a>(&self) -> Client {
        unsafe { std::mem::zeroed() }
    }
    fn get_default_request_context_handler<'a>(&self) -> RequestContextHandler {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_browser_process_handler_t {
        let mut object: _cef_browser_process_handler_t = unsafe { std::mem::zeroed() };
        impl_cef_browser_process_handler_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_browser_process_handler_t {
    use super::*;
    pub fn init_methods<I: ImplBrowserProcessHandler>(object: &mut _cef_browser_process_handler_t) {
        object.on_register_custom_preferences = Some(on_register_custom_preferences::<I>);
        object.on_context_initialized = Some(on_context_initialized::<I>);
        object.on_before_child_process_launch = Some(on_before_child_process_launch::<I>);
        object.on_already_running_app_relaunch = Some(on_already_running_app_relaunch::<I>);
        object.on_schedule_message_pump_work = Some(on_schedule_message_pump_work::<I>);
        object.get_default_client = Some(get_default_client::<I>);
        object.get_default_request_context_handler = Some(get_default_request_context_handler::<I>);
    }
    extern "C" fn on_register_custom_preferences<I: ImplBrowserProcessHandler>(
        self_: *mut _cef_browser_process_handler_t,
        type_: cef_preferences_type_t,
        registrar: *mut _cef_preference_registrar_t,
    ) {
        let (arg_self_, arg_type_, arg_registrar) = (self_, type_, registrar);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_type_ = arg_type_.as_raw();
        let mut arg_registrar = WrapParamRef::<PreferenceRegistrar>::from(arg_registrar);
        let arg_registrar = arg_registrar.as_mut();
        arg_self_
            .interface
            .on_register_custom_preferences(arg_type_, arg_registrar)
    }
    extern "C" fn on_context_initialized<I: ImplBrowserProcessHandler>(
        self_: *mut _cef_browser_process_handler_t,
    ) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.on_context_initialized()
    }
    extern "C" fn on_before_child_process_launch<I: ImplBrowserProcessHandler>(
        self_: *mut _cef_browser_process_handler_t,
        command_line: *mut _cef_command_line_t,
    ) {
        let (arg_self_, arg_command_line) = (self_, command_line);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_line =
            &mut CommandLine(unsafe { RefGuard::from_raw_add_ref(arg_command_line) });
        arg_self_
            .interface
            .on_before_child_process_launch(arg_command_line)
    }
    extern "C" fn on_already_running_app_relaunch<I: ImplBrowserProcessHandler>(
        self_: *mut _cef_browser_process_handler_t,
        command_line: *mut _cef_command_line_t,
        current_directory: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_line, arg_current_directory) =
            (self_, command_line, current_directory);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_line =
            &mut CommandLine(unsafe { RefGuard::from_raw_add_ref(arg_command_line) });
        let arg_current_directory = WrapParamRef::<CefStringUtf16>::from(arg_current_directory);
        let arg_current_directory = arg_current_directory.as_ref();
        arg_self_
            .interface
            .on_already_running_app_relaunch(arg_command_line, arg_current_directory)
            .into()
    }
    extern "C" fn on_schedule_message_pump_work<I: ImplBrowserProcessHandler>(
        self_: *mut _cef_browser_process_handler_t,
        delay_ms: i64,
    ) {
        let (arg_self_, arg_delay_ms) = (self_, delay_ms);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_delay_ms = arg_delay_ms.as_raw();
        arg_self_
            .interface
            .on_schedule_message_pump_work(arg_delay_ms)
    }
    extern "C" fn get_default_client<I: ImplBrowserProcessHandler>(
        self_: *mut _cef_browser_process_handler_t,
    ) -> *mut _cef_client_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_default_client().into()
    }
    extern "C" fn get_default_request_context_handler<I: ImplBrowserProcessHandler>(
        self_: *mut _cef_browser_process_handler_t,
    ) -> *mut _cef_request_context_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_
            .interface
            .get_default_request_context_handler()
            .into()
    }
}
#[doc = "See [_cef_browser_process_handler_t] for more documentation."]
#[derive(Clone)]
pub struct BrowserProcessHandler(RefGuard<_cef_browser_process_handler_t>);
impl ImplBrowserProcessHandler for BrowserProcessHandler {
    fn on_register_custom_preferences<'a>(
        &self,
        type_: PreferencesType,
        registrar: &'a mut PreferenceRegistrar,
    ) {
        unsafe {
            self.0
                .on_register_custom_preferences
                .map(|f| {
                    let (arg_type_, arg_registrar) = (type_, registrar);
                    let arg_self_ = self.as_raw();
                    let arg_type_ = arg_type_.as_raw();
                    let arg_registrar = arg_registrar.as_raw();
                    let result = f(arg_self_, arg_type_, arg_registrar);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_context_initialized<'a>(&self) {
        unsafe {
            self.0
                .on_context_initialized
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_before_child_process_launch<'a>(&self, command_line: &'a mut CommandLine) {
        unsafe {
            self.0
                .on_before_child_process_launch
                .map(|f| {
                    let arg_command_line = command_line;
                    let arg_self_ = self.as_raw();
                    let arg_command_line = arg_command_line.as_raw();
                    let result = f(arg_self_, arg_command_line);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_already_running_app_relaunch<'a>(
        &self,
        command_line: &'a mut CommandLine,
        current_directory: &'a CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_already_running_app_relaunch
                .map(|f| {
                    let (arg_command_line, arg_current_directory) =
                        (command_line, current_directory);
                    let arg_self_ = self.as_raw();
                    let arg_command_line = arg_command_line.as_raw();
                    let arg_current_directory = arg_current_directory.as_raw();
                    let result = f(arg_self_, arg_command_line, arg_current_directory);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_schedule_message_pump_work<'a>(&self, delay_ms: i64) {
        unsafe {
            self.0
                .on_schedule_message_pump_work
                .map(|f| {
                    let arg_delay_ms = delay_ms;
                    let arg_self_ = self.as_raw();
                    let arg_delay_ms = arg_delay_ms;
                    let result = f(arg_self_, arg_delay_ms);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_default_client<'a>(&self) -> Client {
        unsafe {
            self.0
                .get_default_client
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_default_request_context_handler<'a>(&self) -> RequestContextHandler {
        unsafe {
            self.0
                .get_default_request_context_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_browser_process_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for BrowserProcessHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_browser_process_handler_t> for &BrowserProcessHandler {
    fn as_raw(self) -> *mut _cef_browser_process_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_browser_process_handler_t> for &mut BrowserProcessHandler {
    fn as_raw(self) -> *mut _cef_browser_process_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<BrowserProcessHandler> for *mut _cef_browser_process_handler_t {
    fn as_wrapper(self) -> BrowserProcessHandler {
        BrowserProcessHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_browser_process_handler_t> for BrowserProcessHandler {
    fn into(self) -> *mut _cef_browser_process_handler_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for BrowserProcessHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplTask: Sized {
    fn execute<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_task_t {
        let mut object: _cef_task_t = unsafe { std::mem::zeroed() };
        impl_cef_task_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_task_t {
    use super::*;
    pub fn init_methods<I: ImplTask>(object: &mut _cef_task_t) {
        object.execute = Some(execute::<I>);
    }
    extern "C" fn execute<I: ImplTask>(self_: *mut _cef_task_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.execute()
    }
}
#[doc = "See [_cef_task_t] for more documentation."]
#[derive(Clone)]
pub struct Task(RefGuard<_cef_task_t>);
impl ImplTask for Task {
    fn execute<'a>(&self) {
        unsafe {
            self.0
                .execute
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_task_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Task {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_task_t> for &Task {
    fn as_raw(self) -> *mut _cef_task_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_task_t> for &mut Task {
    fn as_raw(self) -> *mut _cef_task_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<Task> for *mut _cef_task_t {
    fn as_wrapper(self) -> Task {
        Task(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_task_t> for Task {
    fn into(self) -> *mut _cef_task_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for Task {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplTaskRunner: Sized {
    fn is_same<'a>(&self, that: &'a mut TaskRunner) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn belongs_to_current_thread<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn belongs_to_thread<'a>(&self, thread_id: ThreadId) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn post_task<'a>(&self, task: &'a mut Task) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn post_delayed_task<'a>(&self, task: &'a mut Task, delay_ms: i64) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_task_runner_t {
        let mut object: _cef_task_runner_t = unsafe { std::mem::zeroed() };
        impl_cef_task_runner_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_task_runner_t {
    use super::*;
    pub fn init_methods<I: ImplTaskRunner>(object: &mut _cef_task_runner_t) {
        object.is_same = Some(is_same::<I>);
        object.belongs_to_current_thread = Some(belongs_to_current_thread::<I>);
        object.belongs_to_thread = Some(belongs_to_thread::<I>);
        object.post_task = Some(post_task::<I>);
        object.post_delayed_task = Some(post_delayed_task::<I>);
    }
    extern "C" fn is_same<I: ImplTaskRunner>(
        self_: *mut _cef_task_runner_t,
        that: *mut _cef_task_runner_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_that) = (self_, that);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_that = &mut TaskRunner(unsafe { RefGuard::from_raw_add_ref(arg_that) });
        arg_self_.interface.is_same(arg_that).into()
    }
    extern "C" fn belongs_to_current_thread<I: ImplTaskRunner>(
        self_: *mut _cef_task_runner_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.belongs_to_current_thread().into()
    }
    extern "C" fn belongs_to_thread<I: ImplTaskRunner>(
        self_: *mut _cef_task_runner_t,
        thread_id: cef_thread_id_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_thread_id) = (self_, thread_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_thread_id = arg_thread_id.as_raw();
        arg_self_.interface.belongs_to_thread(arg_thread_id).into()
    }
    extern "C" fn post_task<I: ImplTaskRunner>(
        self_: *mut _cef_task_runner_t,
        task: *mut _cef_task_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_task) = (self_, task);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_task = &mut Task(unsafe { RefGuard::from_raw_add_ref(arg_task) });
        arg_self_.interface.post_task(arg_task).into()
    }
    extern "C" fn post_delayed_task<I: ImplTaskRunner>(
        self_: *mut _cef_task_runner_t,
        task: *mut _cef_task_t,
        delay_ms: i64,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_task, arg_delay_ms) = (self_, task, delay_ms);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_task = &mut Task(unsafe { RefGuard::from_raw_add_ref(arg_task) });
        let arg_delay_ms = arg_delay_ms.as_raw();
        arg_self_
            .interface
            .post_delayed_task(arg_task, arg_delay_ms)
            .into()
    }
}
#[doc = "See [_cef_task_runner_t] for more documentation."]
#[derive(Clone)]
pub struct TaskRunner(RefGuard<_cef_task_runner_t>);
impl ImplTaskRunner for TaskRunner {
    fn is_same<'a>(&self, that: &'a mut TaskRunner) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_same
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.as_raw();
                    let arg_that = arg_that.as_raw();
                    let result = f(arg_self_, arg_that);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn belongs_to_current_thread<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .belongs_to_current_thread
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn belongs_to_thread<'a>(&self, thread_id: ThreadId) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .belongs_to_thread
                .map(|f| {
                    let arg_thread_id = thread_id;
                    let arg_self_ = self.as_raw();
                    let arg_thread_id = arg_thread_id.as_raw();
                    let result = f(arg_self_, arg_thread_id);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn post_task<'a>(&self, task: &'a mut Task) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .post_task
                .map(|f| {
                    let arg_task = task;
                    let arg_self_ = self.as_raw();
                    let arg_task = arg_task.as_raw();
                    let result = f(arg_self_, arg_task);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn post_delayed_task<'a>(&self, task: &'a mut Task, delay_ms: i64) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .post_delayed_task
                .map(|f| {
                    let (arg_task, arg_delay_ms) = (task, delay_ms);
                    let arg_self_ = self.as_raw();
                    let arg_task = arg_task.as_raw();
                    let arg_delay_ms = arg_delay_ms;
                    let result = f(arg_self_, arg_task, arg_delay_ms);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_task_runner_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for TaskRunner {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_task_runner_t> for &TaskRunner {
    fn as_raw(self) -> *mut _cef_task_runner_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_task_runner_t> for &mut TaskRunner {
    fn as_raw(self) -> *mut _cef_task_runner_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<TaskRunner> for *mut _cef_task_runner_t {
    fn as_wrapper(self) -> TaskRunner {
        TaskRunner(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_task_runner_t> for TaskRunner {
    fn into(self) -> *mut _cef_task_runner_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for TaskRunner {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplV8context: Sized {
    fn get_task_runner<'a>(&self) -> TaskRunner {
        unsafe { std::mem::zeroed() }
    }
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_browser<'a>(&self) -> Browser {
        unsafe { std::mem::zeroed() }
    }
    fn get_frame<'a>(&self) -> Frame {
        unsafe { std::mem::zeroed() }
    }
    fn get_global<'a>(&self) -> V8value {
        unsafe { std::mem::zeroed() }
    }
    fn enter<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn exit<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_same<'a>(&self, that: &'a mut V8context) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn eval<'a>(
        &self,
        code: &'a CefStringUtf16,
        script_url: &'a CefStringUtf16,
        start_line: ::std::os::raw::c_int,
        retval: _cef_v8value_t,
        exception: _cef_v8exception_t,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_v8context_t {
        let mut object: _cef_v8context_t = unsafe { std::mem::zeroed() };
        impl_cef_v8context_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_v8context_t {
    use super::*;
    pub fn init_methods<I: ImplV8context>(object: &mut _cef_v8context_t) {
        object.get_task_runner = Some(get_task_runner::<I>);
        object.is_valid = Some(is_valid::<I>);
        object.get_browser = Some(get_browser::<I>);
        object.get_frame = Some(get_frame::<I>);
        object.get_global = Some(get_global::<I>);
        object.enter = Some(enter::<I>);
        object.exit = Some(exit::<I>);
        object.is_same = Some(is_same::<I>);
        object.eval = Some(eval::<I>);
    }
    extern "C" fn get_task_runner<I: ImplV8context>(
        self_: *mut _cef_v8context_t,
    ) -> *mut _cef_task_runner_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_task_runner().into()
    }
    extern "C" fn is_valid<I: ImplV8context>(
        self_: *mut _cef_v8context_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_valid().into()
    }
    extern "C" fn get_browser<I: ImplV8context>(
        self_: *mut _cef_v8context_t,
    ) -> *mut _cef_browser_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_browser().into()
    }
    extern "C" fn get_frame<I: ImplV8context>(self_: *mut _cef_v8context_t) -> *mut _cef_frame_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_frame().into()
    }
    extern "C" fn get_global<I: ImplV8context>(
        self_: *mut _cef_v8context_t,
    ) -> *mut _cef_v8value_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_global().into()
    }
    extern "C" fn enter<I: ImplV8context>(self_: *mut _cef_v8context_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.enter().into()
    }
    extern "C" fn exit<I: ImplV8context>(self_: *mut _cef_v8context_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.exit().into()
    }
    extern "C" fn is_same<I: ImplV8context>(
        self_: *mut _cef_v8context_t,
        that: *mut _cef_v8context_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_that) = (self_, that);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_that = &mut V8context(unsafe { RefGuard::from_raw_add_ref(arg_that) });
        arg_self_.interface.is_same(arg_that).into()
    }
    extern "C" fn eval<I: ImplV8context>(
        self_: *mut _cef_v8context_t,
        code: *const _cef_string_utf16_t,
        script_url: *const _cef_string_utf16_t,
        start_line: ::std::os::raw::c_int,
        retval: *mut *mut _cef_v8value_t,
        exception: *mut *mut _cef_v8exception_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_code, arg_script_url, arg_start_line, arg_retval, arg_exception) =
            (self_, code, script_url, start_line, retval, exception);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_code = WrapParamRef::<CefStringUtf16>::from(arg_code);
        let arg_code = arg_code.as_ref();
        let arg_script_url = WrapParamRef::<CefStringUtf16>::from(arg_script_url);
        let arg_script_url = arg_script_url.as_ref();
        let arg_start_line = arg_start_line.as_raw();
        let mut arg_retval = WrapParamRef::<V8value>::from(arg_retval);
        let arg_retval = arg_retval.as_mut();
        let mut arg_exception = WrapParamRef::<V8exception>::from(arg_exception);
        let arg_exception = arg_exception.as_mut();
        arg_self_
            .interface
            .eval(
                arg_code,
                arg_script_url,
                arg_start_line,
                arg_retval,
                arg_exception,
            )
            .into()
    }
}
#[doc = "See [_cef_v8context_t] for more documentation."]
#[derive(Clone)]
pub struct V8context(RefGuard<_cef_v8context_t>);
impl ImplV8context for V8context {
    fn get_task_runner<'a>(&self) -> TaskRunner {
        unsafe {
            self.0
                .get_task_runner
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_browser<'a>(&self) -> Browser {
        unsafe {
            self.0
                .get_browser
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_frame<'a>(&self) -> Frame {
        unsafe {
            self.0
                .get_frame
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_global<'a>(&self) -> V8value {
        unsafe {
            self.0
                .get_global
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn enter<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .enter
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn exit<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .exit
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_same<'a>(&self, that: &'a mut V8context) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_same
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.as_raw();
                    let arg_that = arg_that.as_raw();
                    let result = f(arg_self_, arg_that);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn eval<'a>(
        &self,
        code: &'a CefStringUtf16,
        script_url: &'a CefStringUtf16,
        start_line: ::std::os::raw::c_int,
        retval: _cef_v8value_t,
        exception: _cef_v8exception_t,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .eval
                .map(|f| {
                    let (arg_code, arg_script_url, arg_start_line, arg_retval, arg_exception) =
                        (code, script_url, start_line, retval, exception);
                    let arg_self_ = self.as_raw();
                    let arg_code = arg_code.as_raw();
                    let arg_script_url = arg_script_url.as_raw();
                    let arg_start_line = arg_start_line;
                    let arg_retval = arg_retval.as_raw();
                    let arg_exception = arg_exception.as_raw();
                    let result = f(
                        arg_self_,
                        arg_code,
                        arg_script_url,
                        arg_start_line,
                        arg_retval,
                        arg_exception,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_v8context_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for V8context {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_v8context_t> for &V8context {
    fn as_raw(self) -> *mut _cef_v8context_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_v8context_t> for &mut V8context {
    fn as_raw(self) -> *mut _cef_v8context_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<V8context> for *mut _cef_v8context_t {
    fn as_wrapper(self) -> V8context {
        V8context(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_v8context_t> for V8context {
    fn into(self) -> *mut _cef_v8context_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for V8context {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplV8handler: Sized {
    fn execute<'a>(
        &self,
        name: &'a CefStringUtf16,
        object: &'a mut V8value,
        arguments: Option<&'a [Option<V8value>]>,
        retval: _cef_v8value_t,
        exception: &'a mut CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_v8handler_t {
        let mut object: _cef_v8handler_t = unsafe { std::mem::zeroed() };
        impl_cef_v8handler_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_v8handler_t {
    use super::*;
    pub fn init_methods<I: ImplV8handler>(object: &mut _cef_v8handler_t) {
        object.execute = Some(execute::<I>);
    }
    extern "C" fn execute<I: ImplV8handler>(
        self_: *mut _cef_v8handler_t,
        name: *const _cef_string_utf16_t,
        object: *mut _cef_v8value_t,
        arguments_count: usize,
        arguments: *const *mut _cef_v8value_t,
        retval: *mut *mut _cef_v8value_t,
        exception: *mut _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_name,
            arg_object,
            arg_arguments_count,
            arg_arguments,
            arg_retval,
            arg_exception,
        ) = (
            self_,
            name,
            object,
            arguments_count,
            arguments,
            retval,
            exception,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = WrapParamRef::<CefStringUtf16>::from(arg_name);
        let arg_name = arg_name.as_ref();
        let arg_object = &mut V8value(unsafe { RefGuard::from_raw_add_ref(arg_object) });
        let vec_arguments = unsafe { arg_arguments.as_ref() }.map(|arg| {
            let arg =
                unsafe { std::slice::from_raw_parts(std::ptr::from_ref(arg), arg_arguments_count) };
            arg.iter()
                .map(|arg| {
                    if arg.is_null() {
                        None
                    } else {
                        Some(V8value(unsafe { RefGuard::from_raw_add_ref(*arg) }))
                    }
                })
                .collect::<Vec<_>>()
        });
        let arg_arguments = vec_arguments.as_ref().map(|arg| arg.as_slice());
        let mut arg_retval = WrapParamRef::<V8value>::from(arg_retval);
        let arg_retval = arg_retval.as_mut();
        let mut arg_exception = WrapParamRef::<CefStringUtf16>::from(arg_exception);
        let arg_exception = arg_exception.as_mut();
        arg_self_
            .interface
            .execute(
                arg_name,
                arg_object,
                arg_arguments,
                arg_retval,
                arg_exception,
            )
            .into()
    }
}
#[doc = "See [_cef_v8handler_t] for more documentation."]
#[derive(Clone)]
pub struct V8handler(RefGuard<_cef_v8handler_t>);
impl ImplV8handler for V8handler {
    fn execute<'a>(
        &self,
        name: &'a CefStringUtf16,
        object: &'a mut V8value,
        arguments: Option<&'a [Option<V8value>]>,
        retval: _cef_v8value_t,
        exception: &'a mut CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .execute
                .map(|f| {
                    let (arg_name, arg_object, arg_arguments, arg_retval, arg_exception) =
                        (name, object, arguments, retval, exception);
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.as_raw();
                    let arg_object = arg_object.as_raw();
                    let mut arg_arguments_count =
                        arg_arguments.map(|slice| slice.len()).unwrap_or_default();
                    let vec_arguments = arg_arguments
                        .as_ref()
                        .map(|slice| {
                            slice
                                .iter()
                                .map(|elem| {
                                    elem.as_ref()
                                        .map(|elem| elem.as_raw())
                                        .unwrap_or(std::ptr::null_mut())
                                })
                                .collect::<Vec<_>>()
                        })
                        .unwrap_or_default();
                    let arg_arguments = if vec_arguments.is_empty() {
                        std::ptr::null()
                    } else {
                        vec_arguments.as_ptr()
                    };
                    let arg_retval = arg_retval.as_raw();
                    let arg_exception = arg_exception.as_raw();
                    let result = f(
                        arg_self_,
                        arg_name,
                        arg_object,
                        arg_arguments_count,
                        arg_arguments,
                        arg_retval,
                        arg_exception,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_v8handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for V8handler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_v8handler_t> for &V8handler {
    fn as_raw(self) -> *mut _cef_v8handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_v8handler_t> for &mut V8handler {
    fn as_raw(self) -> *mut _cef_v8handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<V8handler> for *mut _cef_v8handler_t {
    fn as_wrapper(self) -> V8handler {
        V8handler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_v8handler_t> for V8handler {
    fn into(self) -> *mut _cef_v8handler_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for V8handler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplV8accessor: Sized {
    fn get<'a>(
        &self,
        name: &'a CefStringUtf16,
        object: &'a mut V8value,
        retval: _cef_v8value_t,
        exception: &'a mut CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set<'a>(
        &self,
        name: &'a CefStringUtf16,
        object: &'a mut V8value,
        value: &'a mut V8value,
        exception: &'a mut CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_v8accessor_t {
        let mut object: _cef_v8accessor_t = unsafe { std::mem::zeroed() };
        impl_cef_v8accessor_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_v8accessor_t {
    use super::*;
    pub fn init_methods<I: ImplV8accessor>(object: &mut _cef_v8accessor_t) {
        object.get = Some(get::<I>);
        object.set = Some(set::<I>);
    }
    extern "C" fn get<I: ImplV8accessor>(
        self_: *mut _cef_v8accessor_t,
        name: *const _cef_string_utf16_t,
        object: *mut _cef_v8value_t,
        retval: *mut *mut _cef_v8value_t,
        exception: *mut _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_name, arg_object, arg_retval, arg_exception) =
            (self_, name, object, retval, exception);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = WrapParamRef::<CefStringUtf16>::from(arg_name);
        let arg_name = arg_name.as_ref();
        let arg_object = &mut V8value(unsafe { RefGuard::from_raw_add_ref(arg_object) });
        let mut arg_retval = WrapParamRef::<V8value>::from(arg_retval);
        let arg_retval = arg_retval.as_mut();
        let mut arg_exception = WrapParamRef::<CefStringUtf16>::from(arg_exception);
        let arg_exception = arg_exception.as_mut();
        arg_self_
            .interface
            .get(arg_name, arg_object, arg_retval, arg_exception)
            .into()
    }
    extern "C" fn set<I: ImplV8accessor>(
        self_: *mut _cef_v8accessor_t,
        name: *const _cef_string_utf16_t,
        object: *mut _cef_v8value_t,
        value: *mut _cef_v8value_t,
        exception: *mut _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_name, arg_object, arg_value, arg_exception) =
            (self_, name, object, value, exception);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = WrapParamRef::<CefStringUtf16>::from(arg_name);
        let arg_name = arg_name.as_ref();
        let arg_object = &mut V8value(unsafe { RefGuard::from_raw_add_ref(arg_object) });
        let arg_value = &mut V8value(unsafe { RefGuard::from_raw_add_ref(arg_value) });
        let mut arg_exception = WrapParamRef::<CefStringUtf16>::from(arg_exception);
        let arg_exception = arg_exception.as_mut();
        arg_self_
            .interface
            .set(arg_name, arg_object, arg_value, arg_exception)
            .into()
    }
}
#[doc = "See [_cef_v8accessor_t] for more documentation."]
#[derive(Clone)]
pub struct V8accessor(RefGuard<_cef_v8accessor_t>);
impl ImplV8accessor for V8accessor {
    fn get<'a>(
        &self,
        name: &'a CefStringUtf16,
        object: &'a mut V8value,
        retval: _cef_v8value_t,
        exception: &'a mut CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get
                .map(|f| {
                    let (arg_name, arg_object, arg_retval, arg_exception) =
                        (name, object, retval, exception);
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.as_raw();
                    let arg_object = arg_object.as_raw();
                    let arg_retval = arg_retval.as_raw();
                    let arg_exception = arg_exception.as_raw();
                    let result = f(arg_self_, arg_name, arg_object, arg_retval, arg_exception);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set<'a>(
        &self,
        name: &'a CefStringUtf16,
        object: &'a mut V8value,
        value: &'a mut V8value,
        exception: &'a mut CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set
                .map(|f| {
                    let (arg_name, arg_object, arg_value, arg_exception) =
                        (name, object, value, exception);
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.as_raw();
                    let arg_object = arg_object.as_raw();
                    let arg_value = arg_value.as_raw();
                    let arg_exception = arg_exception.as_raw();
                    let result = f(arg_self_, arg_name, arg_object, arg_value, arg_exception);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_v8accessor_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for V8accessor {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_v8accessor_t> for &V8accessor {
    fn as_raw(self) -> *mut _cef_v8accessor_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_v8accessor_t> for &mut V8accessor {
    fn as_raw(self) -> *mut _cef_v8accessor_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<V8accessor> for *mut _cef_v8accessor_t {
    fn as_wrapper(self) -> V8accessor {
        V8accessor(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_v8accessor_t> for V8accessor {
    fn into(self) -> *mut _cef_v8accessor_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for V8accessor {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplV8interceptor: Sized {
    fn get_byname<'a>(
        &self,
        name: &'a CefStringUtf16,
        object: &'a mut V8value,
        retval: _cef_v8value_t,
        exception: &'a mut CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_byindex<'a>(
        &self,
        index: ::std::os::raw::c_int,
        object: &'a mut V8value,
        retval: _cef_v8value_t,
        exception: &'a mut CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_byname<'a>(
        &self,
        name: &'a CefStringUtf16,
        object: &'a mut V8value,
        value: &'a mut V8value,
        exception: &'a mut CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_byindex<'a>(
        &self,
        index: ::std::os::raw::c_int,
        object: &'a mut V8value,
        value: &'a mut V8value,
        exception: &'a mut CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_v8interceptor_t {
        let mut object: _cef_v8interceptor_t = unsafe { std::mem::zeroed() };
        impl_cef_v8interceptor_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_v8interceptor_t {
    use super::*;
    pub fn init_methods<I: ImplV8interceptor>(object: &mut _cef_v8interceptor_t) {
        object.get_byname = Some(get_byname::<I>);
        object.get_byindex = Some(get_byindex::<I>);
        object.set_byname = Some(set_byname::<I>);
        object.set_byindex = Some(set_byindex::<I>);
    }
    extern "C" fn get_byname<I: ImplV8interceptor>(
        self_: *mut _cef_v8interceptor_t,
        name: *const _cef_string_utf16_t,
        object: *mut _cef_v8value_t,
        retval: *mut *mut _cef_v8value_t,
        exception: *mut _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_name, arg_object, arg_retval, arg_exception) =
            (self_, name, object, retval, exception);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = WrapParamRef::<CefStringUtf16>::from(arg_name);
        let arg_name = arg_name.as_ref();
        let arg_object = &mut V8value(unsafe { RefGuard::from_raw_add_ref(arg_object) });
        let mut arg_retval = WrapParamRef::<V8value>::from(arg_retval);
        let arg_retval = arg_retval.as_mut();
        let mut arg_exception = WrapParamRef::<CefStringUtf16>::from(arg_exception);
        let arg_exception = arg_exception.as_mut();
        arg_self_
            .interface
            .get_byname(arg_name, arg_object, arg_retval, arg_exception)
            .into()
    }
    extern "C" fn get_byindex<I: ImplV8interceptor>(
        self_: *mut _cef_v8interceptor_t,
        index: ::std::os::raw::c_int,
        object: *mut _cef_v8value_t,
        retval: *mut *mut _cef_v8value_t,
        exception: *mut _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_object, arg_retval, arg_exception) =
            (self_, index, object, retval, exception);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_object = &mut V8value(unsafe { RefGuard::from_raw_add_ref(arg_object) });
        let mut arg_retval = WrapParamRef::<V8value>::from(arg_retval);
        let arg_retval = arg_retval.as_mut();
        let mut arg_exception = WrapParamRef::<CefStringUtf16>::from(arg_exception);
        let arg_exception = arg_exception.as_mut();
        arg_self_
            .interface
            .get_byindex(arg_index, arg_object, arg_retval, arg_exception)
            .into()
    }
    extern "C" fn set_byname<I: ImplV8interceptor>(
        self_: *mut _cef_v8interceptor_t,
        name: *const _cef_string_utf16_t,
        object: *mut _cef_v8value_t,
        value: *mut _cef_v8value_t,
        exception: *mut _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_name, arg_object, arg_value, arg_exception) =
            (self_, name, object, value, exception);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = WrapParamRef::<CefStringUtf16>::from(arg_name);
        let arg_name = arg_name.as_ref();
        let arg_object = &mut V8value(unsafe { RefGuard::from_raw_add_ref(arg_object) });
        let arg_value = &mut V8value(unsafe { RefGuard::from_raw_add_ref(arg_value) });
        let mut arg_exception = WrapParamRef::<CefStringUtf16>::from(arg_exception);
        let arg_exception = arg_exception.as_mut();
        arg_self_
            .interface
            .set_byname(arg_name, arg_object, arg_value, arg_exception)
            .into()
    }
    extern "C" fn set_byindex<I: ImplV8interceptor>(
        self_: *mut _cef_v8interceptor_t,
        index: ::std::os::raw::c_int,
        object: *mut _cef_v8value_t,
        value: *mut _cef_v8value_t,
        exception: *mut _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_object, arg_value, arg_exception) =
            (self_, index, object, value, exception);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_object = &mut V8value(unsafe { RefGuard::from_raw_add_ref(arg_object) });
        let arg_value = &mut V8value(unsafe { RefGuard::from_raw_add_ref(arg_value) });
        let mut arg_exception = WrapParamRef::<CefStringUtf16>::from(arg_exception);
        let arg_exception = arg_exception.as_mut();
        arg_self_
            .interface
            .set_byindex(arg_index, arg_object, arg_value, arg_exception)
            .into()
    }
}
#[doc = "See [_cef_v8interceptor_t] for more documentation."]
#[derive(Clone)]
pub struct V8interceptor(RefGuard<_cef_v8interceptor_t>);
impl ImplV8interceptor for V8interceptor {
    fn get_byname<'a>(
        &self,
        name: &'a CefStringUtf16,
        object: &'a mut V8value,
        retval: _cef_v8value_t,
        exception: &'a mut CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_byname
                .map(|f| {
                    let (arg_name, arg_object, arg_retval, arg_exception) =
                        (name, object, retval, exception);
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.as_raw();
                    let arg_object = arg_object.as_raw();
                    let arg_retval = arg_retval.as_raw();
                    let arg_exception = arg_exception.as_raw();
                    let result = f(arg_self_, arg_name, arg_object, arg_retval, arg_exception);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_byindex<'a>(
        &self,
        index: ::std::os::raw::c_int,
        object: &'a mut V8value,
        retval: _cef_v8value_t,
        exception: &'a mut CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_byindex
                .map(|f| {
                    let (arg_index, arg_object, arg_retval, arg_exception) =
                        (index, object, retval, exception);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_object = arg_object.as_raw();
                    let arg_retval = arg_retval.as_raw();
                    let arg_exception = arg_exception.as_raw();
                    let result = f(arg_self_, arg_index, arg_object, arg_retval, arg_exception);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_byname<'a>(
        &self,
        name: &'a CefStringUtf16,
        object: &'a mut V8value,
        value: &'a mut V8value,
        exception: &'a mut CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_byname
                .map(|f| {
                    let (arg_name, arg_object, arg_value, arg_exception) =
                        (name, object, value, exception);
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.as_raw();
                    let arg_object = arg_object.as_raw();
                    let arg_value = arg_value.as_raw();
                    let arg_exception = arg_exception.as_raw();
                    let result = f(arg_self_, arg_name, arg_object, arg_value, arg_exception);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_byindex<'a>(
        &self,
        index: ::std::os::raw::c_int,
        object: &'a mut V8value,
        value: &'a mut V8value,
        exception: &'a mut CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_byindex
                .map(|f| {
                    let (arg_index, arg_object, arg_value, arg_exception) =
                        (index, object, value, exception);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_object = arg_object.as_raw();
                    let arg_value = arg_value.as_raw();
                    let arg_exception = arg_exception.as_raw();
                    let result = f(arg_self_, arg_index, arg_object, arg_value, arg_exception);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_v8interceptor_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for V8interceptor {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_v8interceptor_t> for &V8interceptor {
    fn as_raw(self) -> *mut _cef_v8interceptor_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_v8interceptor_t> for &mut V8interceptor {
    fn as_raw(self) -> *mut _cef_v8interceptor_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<V8interceptor> for *mut _cef_v8interceptor_t {
    fn as_wrapper(self) -> V8interceptor {
        V8interceptor(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_v8interceptor_t> for V8interceptor {
    fn into(self) -> *mut _cef_v8interceptor_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for V8interceptor {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplV8exception: Sized {
    fn get_message<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_source_line<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_script_resource_name<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_line_number<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_start_position<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_end_position<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_start_column<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_end_column<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_v8exception_t {
        let mut object: _cef_v8exception_t = unsafe { std::mem::zeroed() };
        impl_cef_v8exception_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_v8exception_t {
    use super::*;
    pub fn init_methods<I: ImplV8exception>(object: &mut _cef_v8exception_t) {
        object.get_message = Some(get_message::<I>);
        object.get_source_line = Some(get_source_line::<I>);
        object.get_script_resource_name = Some(get_script_resource_name::<I>);
        object.get_line_number = Some(get_line_number::<I>);
        object.get_start_position = Some(get_start_position::<I>);
        object.get_end_position = Some(get_end_position::<I>);
        object.get_start_column = Some(get_start_column::<I>);
        object.get_end_column = Some(get_end_column::<I>);
    }
    extern "C" fn get_message<I: ImplV8exception>(
        self_: *mut _cef_v8exception_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_message().into()
    }
    extern "C" fn get_source_line<I: ImplV8exception>(
        self_: *mut _cef_v8exception_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_source_line().into()
    }
    extern "C" fn get_script_resource_name<I: ImplV8exception>(
        self_: *mut _cef_v8exception_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_script_resource_name().into()
    }
    extern "C" fn get_line_number<I: ImplV8exception>(
        self_: *mut _cef_v8exception_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_line_number().into()
    }
    extern "C" fn get_start_position<I: ImplV8exception>(
        self_: *mut _cef_v8exception_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_start_position().into()
    }
    extern "C" fn get_end_position<I: ImplV8exception>(
        self_: *mut _cef_v8exception_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_end_position().into()
    }
    extern "C" fn get_start_column<I: ImplV8exception>(
        self_: *mut _cef_v8exception_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_start_column().into()
    }
    extern "C" fn get_end_column<I: ImplV8exception>(
        self_: *mut _cef_v8exception_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_end_column().into()
    }
}
#[doc = "See [_cef_v8exception_t] for more documentation."]
#[derive(Clone)]
pub struct V8exception(RefGuard<_cef_v8exception_t>);
impl ImplV8exception for V8exception {
    fn get_message<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_message
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_source_line<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_source_line
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_script_resource_name<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_script_resource_name
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_line_number<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_line_number
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_start_position<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_start_position
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_end_position<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_end_position
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_start_column<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_start_column
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_end_column<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_end_column
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_v8exception_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for V8exception {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_v8exception_t> for &V8exception {
    fn as_raw(self) -> *mut _cef_v8exception_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_v8exception_t> for &mut V8exception {
    fn as_raw(self) -> *mut _cef_v8exception_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<V8exception> for *mut _cef_v8exception_t {
    fn as_wrapper(self) -> V8exception {
        V8exception(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_v8exception_t> for V8exception {
    fn into(self) -> *mut _cef_v8exception_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for V8exception {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplV8arrayBufferReleaseCallback: Sized {
    fn release_buffer<'a>(&self, buffer: *mut ::std::os::raw::c_void) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_v8array_buffer_release_callback_t {
        let mut object: _cef_v8array_buffer_release_callback_t = unsafe { std::mem::zeroed() };
        impl_cef_v8array_buffer_release_callback_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_v8array_buffer_release_callback_t {
    use super::*;
    pub fn init_methods<I: ImplV8arrayBufferReleaseCallback>(
        object: &mut _cef_v8array_buffer_release_callback_t,
    ) {
        object.release_buffer = Some(release_buffer::<I>);
    }
    extern "C" fn release_buffer<I: ImplV8arrayBufferReleaseCallback>(
        self_: *mut _cef_v8array_buffer_release_callback_t,
        buffer: *mut ::std::os::raw::c_void,
    ) {
        let (arg_self_, arg_buffer) = (self_, buffer);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.release_buffer(arg_buffer)
    }
}
#[doc = "See [_cef_v8array_buffer_release_callback_t] for more documentation."]
#[derive(Clone)]
pub struct V8arrayBufferReleaseCallback(RefGuard<_cef_v8array_buffer_release_callback_t>);
impl ImplV8arrayBufferReleaseCallback for V8arrayBufferReleaseCallback {
    fn release_buffer<'a>(&self, buffer: *mut ::std::os::raw::c_void) {
        unsafe {
            self.0
                .release_buffer
                .map(|f| {
                    let arg_buffer = buffer;
                    let arg_self_ = self.as_raw();
                    let arg_buffer = arg_buffer as *mut _;
                    let result = f(arg_self_, arg_buffer);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_v8array_buffer_release_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for V8arrayBufferReleaseCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_v8array_buffer_release_callback_t> for &V8arrayBufferReleaseCallback {
    fn as_raw(self) -> *mut _cef_v8array_buffer_release_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_v8array_buffer_release_callback_t>
    for &mut V8arrayBufferReleaseCallback
{
    fn as_raw(self) -> *mut _cef_v8array_buffer_release_callback_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<V8arrayBufferReleaseCallback>
    for *mut _cef_v8array_buffer_release_callback_t
{
    fn as_wrapper(self) -> V8arrayBufferReleaseCallback {
        V8arrayBufferReleaseCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_v8array_buffer_release_callback_t> for V8arrayBufferReleaseCallback {
    fn into(self) -> *mut _cef_v8array_buffer_release_callback_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for V8arrayBufferReleaseCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplV8value: Sized {
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_undefined<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_null<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_bool<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_int<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_uint<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_double<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_date<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_string<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_object<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_array<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_array_buffer<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_function<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_promise<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_same<'a>(&self, that: &'a mut V8value) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_bool_value<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_int_value<'a>(&self) -> i32 {
        unsafe { std::mem::zeroed() }
    }
    fn get_uint_value<'a>(&self) -> u32 {
        unsafe { std::mem::zeroed() }
    }
    fn get_double_value<'a>(&self) -> f64 {
        unsafe { std::mem::zeroed() }
    }
    fn get_date_value<'a>(&self) -> Basetime {
        unsafe { std::mem::zeroed() }
    }
    fn get_string_value<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn is_user_created<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn has_exception<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_exception<'a>(&self) -> V8exception {
        unsafe { std::mem::zeroed() }
    }
    fn clear_exception<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn will_rethrow_exceptions<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_rethrow_exceptions<'a>(&self, rethrow: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn has_value_bykey<'a>(&self, key: &'a CefStringUtf16) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn has_value_byindex<'a>(&self, index: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn delete_value_bykey<'a>(&self, key: &'a CefStringUtf16) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn delete_value_byindex<'a>(&self, index: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_value_bykey<'a>(&self, key: &'a CefStringUtf16) -> V8value {
        unsafe { std::mem::zeroed() }
    }
    fn get_value_byindex<'a>(&self, index: ::std::os::raw::c_int) -> V8value {
        unsafe { std::mem::zeroed() }
    }
    fn set_value_bykey<'a>(
        &self,
        key: &'a CefStringUtf16,
        value: &'a mut V8value,
        attribute: V8Propertyattribute,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_value_byindex<'a>(
        &self,
        index: ::std::os::raw::c_int,
        value: &'a mut V8value,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_value_byaccessor<'a>(
        &self,
        key: &'a CefStringUtf16,
        attribute: V8Propertyattribute,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_keys<'a>(&self, keys: &'a mut CefStringList) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_user_data<'a>(&self, user_data: &'a mut BaseRefCounted) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_user_data<'a>(&self) -> BaseRefCounted {
        unsafe { std::mem::zeroed() }
    }
    fn get_externally_allocated_memory<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn adjust_externally_allocated_memory<'a>(
        &self,
        change_in_bytes: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_array_length<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_array_buffer_release_callback<'a>(&self) -> V8arrayBufferReleaseCallback {
        unsafe { std::mem::zeroed() }
    }
    fn neuter_array_buffer<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_array_buffer_byte_length<'a>(&self) -> usize {
        unsafe { std::mem::zeroed() }
    }
    fn get_array_buffer_data<'a>(&self) -> *mut ::std::os::raw::c_void {
        unsafe { std::mem::zeroed() }
    }
    fn get_function_name<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_function_handler<'a>(&self) -> V8handler {
        unsafe { std::mem::zeroed() }
    }
    fn execute_function<'a>(
        &self,
        object: &'a mut V8value,
        arguments: Option<&'a [Option<V8value>]>,
    ) -> V8value {
        unsafe { std::mem::zeroed() }
    }
    fn execute_function_with_context<'a>(
        &self,
        context: &'a mut V8context,
        object: &'a mut V8value,
        arguments: Option<&'a [Option<V8value>]>,
    ) -> V8value {
        unsafe { std::mem::zeroed() }
    }
    fn resolve_promise<'a>(&self, arg: &'a mut V8value) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn reject_promise<'a>(&self, error_msg: &'a CefStringUtf16) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_v8value_t {
        let mut object: _cef_v8value_t = unsafe { std::mem::zeroed() };
        impl_cef_v8value_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_v8value_t {
    use super::*;
    pub fn init_methods<I: ImplV8value>(object: &mut _cef_v8value_t) {
        object.is_valid = Some(is_valid::<I>);
        object.is_undefined = Some(is_undefined::<I>);
        object.is_null = Some(is_null::<I>);
        object.is_bool = Some(is_bool::<I>);
        object.is_int = Some(is_int::<I>);
        object.is_uint = Some(is_uint::<I>);
        object.is_double = Some(is_double::<I>);
        object.is_date = Some(is_date::<I>);
        object.is_string = Some(is_string::<I>);
        object.is_object = Some(is_object::<I>);
        object.is_array = Some(is_array::<I>);
        object.is_array_buffer = Some(is_array_buffer::<I>);
        object.is_function = Some(is_function::<I>);
        object.is_promise = Some(is_promise::<I>);
        object.is_same = Some(is_same::<I>);
        object.get_bool_value = Some(get_bool_value::<I>);
        object.get_int_value = Some(get_int_value::<I>);
        object.get_uint_value = Some(get_uint_value::<I>);
        object.get_double_value = Some(get_double_value::<I>);
        object.get_date_value = Some(get_date_value::<I>);
        object.get_string_value = Some(get_string_value::<I>);
        object.is_user_created = Some(is_user_created::<I>);
        object.has_exception = Some(has_exception::<I>);
        object.get_exception = Some(get_exception::<I>);
        object.clear_exception = Some(clear_exception::<I>);
        object.will_rethrow_exceptions = Some(will_rethrow_exceptions::<I>);
        object.set_rethrow_exceptions = Some(set_rethrow_exceptions::<I>);
        object.has_value_bykey = Some(has_value_bykey::<I>);
        object.has_value_byindex = Some(has_value_byindex::<I>);
        object.delete_value_bykey = Some(delete_value_bykey::<I>);
        object.delete_value_byindex = Some(delete_value_byindex::<I>);
        object.get_value_bykey = Some(get_value_bykey::<I>);
        object.get_value_byindex = Some(get_value_byindex::<I>);
        object.set_value_bykey = Some(set_value_bykey::<I>);
        object.set_value_byindex = Some(set_value_byindex::<I>);
        object.set_value_byaccessor = Some(set_value_byaccessor::<I>);
        object.get_keys = Some(get_keys::<I>);
        object.set_user_data = Some(set_user_data::<I>);
        object.get_user_data = Some(get_user_data::<I>);
        object.get_externally_allocated_memory = Some(get_externally_allocated_memory::<I>);
        object.adjust_externally_allocated_memory = Some(adjust_externally_allocated_memory::<I>);
        object.get_array_length = Some(get_array_length::<I>);
        object.get_array_buffer_release_callback = Some(get_array_buffer_release_callback::<I>);
        object.neuter_array_buffer = Some(neuter_array_buffer::<I>);
        object.get_array_buffer_byte_length = Some(get_array_buffer_byte_length::<I>);
        object.get_array_buffer_data = Some(get_array_buffer_data::<I>);
        object.get_function_name = Some(get_function_name::<I>);
        object.get_function_handler = Some(get_function_handler::<I>);
        object.execute_function = Some(execute_function::<I>);
        object.execute_function_with_context = Some(execute_function_with_context::<I>);
        object.resolve_promise = Some(resolve_promise::<I>);
        object.reject_promise = Some(reject_promise::<I>);
    }
    extern "C" fn is_valid<I: ImplV8value>(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_valid().into()
    }
    extern "C" fn is_undefined<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_undefined().into()
    }
    extern "C" fn is_null<I: ImplV8value>(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_null().into()
    }
    extern "C" fn is_bool<I: ImplV8value>(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_bool().into()
    }
    extern "C" fn is_int<I: ImplV8value>(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_int().into()
    }
    extern "C" fn is_uint<I: ImplV8value>(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_uint().into()
    }
    extern "C" fn is_double<I: ImplV8value>(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_double().into()
    }
    extern "C" fn is_date<I: ImplV8value>(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_date().into()
    }
    extern "C" fn is_string<I: ImplV8value>(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_string().into()
    }
    extern "C" fn is_object<I: ImplV8value>(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_object().into()
    }
    extern "C" fn is_array<I: ImplV8value>(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_array().into()
    }
    extern "C" fn is_array_buffer<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_array_buffer().into()
    }
    extern "C" fn is_function<I: ImplV8value>(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_function().into()
    }
    extern "C" fn is_promise<I: ImplV8value>(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_promise().into()
    }
    extern "C" fn is_same<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
        that: *mut _cef_v8value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_that) = (self_, that);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_that = &mut V8value(unsafe { RefGuard::from_raw_add_ref(arg_that) });
        arg_self_.interface.is_same(arg_that).into()
    }
    extern "C" fn get_bool_value<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_bool_value().into()
    }
    extern "C" fn get_int_value<I: ImplV8value>(self_: *mut _cef_v8value_t) -> i32 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_int_value().into()
    }
    extern "C" fn get_uint_value<I: ImplV8value>(self_: *mut _cef_v8value_t) -> u32 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_uint_value().into()
    }
    extern "C" fn get_double_value<I: ImplV8value>(self_: *mut _cef_v8value_t) -> f64 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_double_value().into()
    }
    extern "C" fn get_date_value<I: ImplV8value>(self_: *mut _cef_v8value_t) -> _cef_basetime_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_date_value().into()
    }
    extern "C" fn get_string_value<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_string_value().into()
    }
    extern "C" fn is_user_created<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_user_created().into()
    }
    extern "C" fn has_exception<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.has_exception().into()
    }
    extern "C" fn get_exception<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
    ) -> *mut _cef_v8exception_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_exception().into()
    }
    extern "C" fn clear_exception<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.clear_exception().into()
    }
    extern "C" fn will_rethrow_exceptions<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.will_rethrow_exceptions().into()
    }
    extern "C" fn set_rethrow_exceptions<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
        rethrow: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_rethrow) = (self_, rethrow);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_rethrow = arg_rethrow.as_raw();
        arg_self_
            .interface
            .set_rethrow_exceptions(arg_rethrow)
            .into()
    }
    extern "C" fn has_value_bykey<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
        key: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_key) = (self_, key);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = WrapParamRef::<CefStringUtf16>::from(arg_key);
        let arg_key = arg_key.as_ref();
        arg_self_.interface.has_value_bykey(arg_key).into()
    }
    extern "C" fn has_value_byindex<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
        index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        arg_self_.interface.has_value_byindex(arg_index).into()
    }
    extern "C" fn delete_value_bykey<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
        key: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_key) = (self_, key);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = WrapParamRef::<CefStringUtf16>::from(arg_key);
        let arg_key = arg_key.as_ref();
        arg_self_.interface.delete_value_bykey(arg_key).into()
    }
    extern "C" fn delete_value_byindex<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
        index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        arg_self_.interface.delete_value_byindex(arg_index).into()
    }
    extern "C" fn get_value_bykey<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
        key: *const _cef_string_utf16_t,
    ) -> *mut _cef_v8value_t {
        let (arg_self_, arg_key) = (self_, key);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = WrapParamRef::<CefStringUtf16>::from(arg_key);
        let arg_key = arg_key.as_ref();
        arg_self_.interface.get_value_bykey(arg_key).into()
    }
    extern "C" fn get_value_byindex<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
        index: ::std::os::raw::c_int,
    ) -> *mut _cef_v8value_t {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        arg_self_.interface.get_value_byindex(arg_index).into()
    }
    extern "C" fn set_value_bykey<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
        key: *const _cef_string_utf16_t,
        value: *mut _cef_v8value_t,
        attribute: cef_v8_propertyattribute_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_key, arg_value, arg_attribute) = (self_, key, value, attribute);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = WrapParamRef::<CefStringUtf16>::from(arg_key);
        let arg_key = arg_key.as_ref();
        let arg_value = &mut V8value(unsafe { RefGuard::from_raw_add_ref(arg_value) });
        let arg_attribute = arg_attribute.as_raw();
        arg_self_
            .interface
            .set_value_bykey(arg_key, arg_value, arg_attribute)
            .into()
    }
    extern "C" fn set_value_byindex<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
        index: ::std::os::raw::c_int,
        value: *mut _cef_v8value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_value) = (self_, index, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        let arg_value = &mut V8value(unsafe { RefGuard::from_raw_add_ref(arg_value) });
        arg_self_
            .interface
            .set_value_byindex(arg_index, arg_value)
            .into()
    }
    extern "C" fn set_value_byaccessor<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
        key: *const _cef_string_utf16_t,
        attribute: cef_v8_propertyattribute_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_key, arg_attribute) = (self_, key, attribute);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key = WrapParamRef::<CefStringUtf16>::from(arg_key);
        let arg_key = arg_key.as_ref();
        let arg_attribute = arg_attribute.as_raw();
        arg_self_
            .interface
            .set_value_byaccessor(arg_key, arg_attribute)
            .into()
    }
    extern "C" fn get_keys<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
        keys: *mut _cef_string_list_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_keys) = (self_, keys);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_keys = WrapParamRef::<CefStringList>::from(arg_keys);
        let arg_keys = arg_keys.as_mut();
        arg_self_.interface.get_keys(arg_keys).into()
    }
    extern "C" fn set_user_data<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
        user_data: *mut _cef_base_ref_counted_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_user_data) = (self_, user_data);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_user_data =
            &mut BaseRefCounted(unsafe { RefGuard::from_raw_add_ref(arg_user_data) });
        arg_self_.interface.set_user_data(arg_user_data).into()
    }
    extern "C" fn get_user_data<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
    ) -> *mut _cef_base_ref_counted_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_user_data().into()
    }
    extern "C" fn get_externally_allocated_memory<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_externally_allocated_memory().into()
    }
    extern "C" fn adjust_externally_allocated_memory<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
        change_in_bytes: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_change_in_bytes) = (self_, change_in_bytes);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_change_in_bytes = arg_change_in_bytes.as_raw();
        arg_self_
            .interface
            .adjust_externally_allocated_memory(arg_change_in_bytes)
            .into()
    }
    extern "C" fn get_array_length<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_array_length().into()
    }
    extern "C" fn get_array_buffer_release_callback<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
    ) -> *mut _cef_v8array_buffer_release_callback_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_
            .interface
            .get_array_buffer_release_callback()
            .into()
    }
    extern "C" fn neuter_array_buffer<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.neuter_array_buffer().into()
    }
    extern "C" fn get_array_buffer_byte_length<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
    ) -> usize {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_array_buffer_byte_length().into()
    }
    extern "C" fn get_array_buffer_data<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
    ) -> *mut ::std::os::raw::c_void {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_array_buffer_data().into()
    }
    extern "C" fn get_function_name<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_function_name().into()
    }
    extern "C" fn get_function_handler<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
    ) -> *mut _cef_v8handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_function_handler().into()
    }
    extern "C" fn execute_function<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
        object: *mut _cef_v8value_t,
        arguments_count: usize,
        arguments: *const *mut _cef_v8value_t,
    ) -> *mut _cef_v8value_t {
        let (arg_self_, arg_object, arg_arguments_count, arg_arguments) =
            (self_, object, arguments_count, arguments);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_object = &mut V8value(unsafe { RefGuard::from_raw_add_ref(arg_object) });
        let vec_arguments = unsafe { arg_arguments.as_ref() }.map(|arg| {
            let arg =
                unsafe { std::slice::from_raw_parts(std::ptr::from_ref(arg), arg_arguments_count) };
            arg.iter()
                .map(|arg| {
                    if arg.is_null() {
                        None
                    } else {
                        Some(V8value(unsafe { RefGuard::from_raw_add_ref(*arg) }))
                    }
                })
                .collect::<Vec<_>>()
        });
        let arg_arguments = vec_arguments.as_ref().map(|arg| arg.as_slice());
        arg_self_
            .interface
            .execute_function(arg_object, arg_arguments)
            .into()
    }
    extern "C" fn execute_function_with_context<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
        context: *mut _cef_v8context_t,
        object: *mut _cef_v8value_t,
        arguments_count: usize,
        arguments: *const *mut _cef_v8value_t,
    ) -> *mut _cef_v8value_t {
        let (arg_self_, arg_context, arg_object, arg_arguments_count, arg_arguments) =
            (self_, context, object, arguments_count, arguments);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_context = &mut V8context(unsafe { RefGuard::from_raw_add_ref(arg_context) });
        let arg_object = &mut V8value(unsafe { RefGuard::from_raw_add_ref(arg_object) });
        let vec_arguments = unsafe { arg_arguments.as_ref() }.map(|arg| {
            let arg =
                unsafe { std::slice::from_raw_parts(std::ptr::from_ref(arg), arg_arguments_count) };
            arg.iter()
                .map(|arg| {
                    if arg.is_null() {
                        None
                    } else {
                        Some(V8value(unsafe { RefGuard::from_raw_add_ref(*arg) }))
                    }
                })
                .collect::<Vec<_>>()
        });
        let arg_arguments = vec_arguments.as_ref().map(|arg| arg.as_slice());
        arg_self_
            .interface
            .execute_function_with_context(arg_context, arg_object, arg_arguments)
            .into()
    }
    extern "C" fn resolve_promise<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
        arg: *mut _cef_v8value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_arg) = (self_, arg);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_arg = &mut V8value(unsafe { RefGuard::from_raw_add_ref(arg_arg) });
        arg_self_.interface.resolve_promise(arg_arg).into()
    }
    extern "C" fn reject_promise<I: ImplV8value>(
        self_: *mut _cef_v8value_t,
        error_msg: *const _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_error_msg) = (self_, error_msg);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_error_msg = WrapParamRef::<CefStringUtf16>::from(arg_error_msg);
        let arg_error_msg = arg_error_msg.as_ref();
        arg_self_.interface.reject_promise(arg_error_msg).into()
    }
}
#[doc = "See [_cef_v8value_t] for more documentation."]
#[derive(Clone)]
pub struct V8value(RefGuard<_cef_v8value_t>);
impl ImplV8value for V8value {
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_undefined<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_undefined
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_null<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_null
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_bool<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_bool
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_int<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_int
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_uint<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_uint
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_double<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_double
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_date<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_date
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_string<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_string
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_object<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_object
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_array<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_array
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_array_buffer<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_array_buffer
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_function<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_function
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_promise<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_promise
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_same<'a>(&self, that: &'a mut V8value) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_same
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.as_raw();
                    let arg_that = arg_that.as_raw();
                    let result = f(arg_self_, arg_that);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_bool_value<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_bool_value
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_int_value<'a>(&self) -> i32 {
        unsafe {
            self.0
                .get_int_value
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_uint_value<'a>(&self) -> u32 {
        unsafe {
            self.0
                .get_uint_value
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_double_value<'a>(&self) -> f64 {
        unsafe {
            self.0
                .get_double_value
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_date_value<'a>(&self) -> Basetime {
        unsafe {
            self.0
                .get_date_value
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_string_value<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_string_value
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_user_created<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_user_created
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn has_exception<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_exception
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_exception<'a>(&self) -> V8exception {
        unsafe {
            self.0
                .get_exception
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn clear_exception<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .clear_exception
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn will_rethrow_exceptions<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .will_rethrow_exceptions
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_rethrow_exceptions<'a>(&self, rethrow: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_rethrow_exceptions
                .map(|f| {
                    let arg_rethrow = rethrow;
                    let arg_self_ = self.as_raw();
                    let arg_rethrow = arg_rethrow;
                    let result = f(arg_self_, arg_rethrow);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn has_value_bykey<'a>(&self, key: &'a CefStringUtf16) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_value_bykey
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.as_raw();
                    let result = f(arg_self_, arg_key);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn has_value_byindex<'a>(&self, index: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_value_byindex
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn delete_value_bykey<'a>(&self, key: &'a CefStringUtf16) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .delete_value_bykey
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.as_raw();
                    let result = f(arg_self_, arg_key);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn delete_value_byindex<'a>(&self, index: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .delete_value_byindex
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_value_bykey<'a>(&self, key: &'a CefStringUtf16) -> V8value {
        unsafe {
            self.0
                .get_value_bykey
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.as_raw();
                    let result = f(arg_self_, arg_key);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_value_byindex<'a>(&self, index: ::std::os::raw::c_int) -> V8value {
        unsafe {
            self.0
                .get_value_byindex
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_value_bykey<'a>(
        &self,
        key: &'a CefStringUtf16,
        value: &'a mut V8value,
        attribute: V8Propertyattribute,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_value_bykey
                .map(|f| {
                    let (arg_key, arg_value, arg_attribute) = (key, value, attribute);
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.as_raw();
                    let arg_value = arg_value.as_raw();
                    let arg_attribute = arg_attribute.as_raw();
                    let result = f(arg_self_, arg_key, arg_value, arg_attribute);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_value_byindex<'a>(
        &self,
        index: ::std::os::raw::c_int,
        value: &'a mut V8value,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_value_byindex
                .map(|f| {
                    let (arg_index, arg_value) = (index, value);
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let arg_value = arg_value.as_raw();
                    let result = f(arg_self_, arg_index, arg_value);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_value_byaccessor<'a>(
        &self,
        key: &'a CefStringUtf16,
        attribute: V8Propertyattribute,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_value_byaccessor
                .map(|f| {
                    let (arg_key, arg_attribute) = (key, attribute);
                    let arg_self_ = self.as_raw();
                    let arg_key = arg_key.as_raw();
                    let arg_attribute = arg_attribute.as_raw();
                    let result = f(arg_self_, arg_key, arg_attribute);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_keys<'a>(&self, keys: &'a mut CefStringList) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_keys
                .map(|f| {
                    let arg_keys = keys;
                    let arg_self_ = self.as_raw();
                    let arg_keys = arg_keys.as_raw();
                    let result = f(arg_self_, arg_keys);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_user_data<'a>(&self, user_data: &'a mut BaseRefCounted) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_user_data
                .map(|f| {
                    let arg_user_data = user_data;
                    let arg_self_ = self.as_raw();
                    let arg_user_data = arg_user_data.as_raw();
                    let result = f(arg_self_, arg_user_data);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_user_data<'a>(&self) -> BaseRefCounted {
        unsafe {
            self.0
                .get_user_data
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_externally_allocated_memory<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_externally_allocated_memory
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn adjust_externally_allocated_memory<'a>(
        &self,
        change_in_bytes: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .adjust_externally_allocated_memory
                .map(|f| {
                    let arg_change_in_bytes = change_in_bytes;
                    let arg_self_ = self.as_raw();
                    let arg_change_in_bytes = arg_change_in_bytes;
                    let result = f(arg_self_, arg_change_in_bytes);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_array_length<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_array_length
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_array_buffer_release_callback<'a>(&self) -> V8arrayBufferReleaseCallback {
        unsafe {
            self.0
                .get_array_buffer_release_callback
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn neuter_array_buffer<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .neuter_array_buffer
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_array_buffer_byte_length<'a>(&self) -> usize {
        unsafe {
            self.0
                .get_array_buffer_byte_length
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_array_buffer_data<'a>(&self) -> *mut ::std::os::raw::c_void {
        unsafe {
            self.0
                .get_array_buffer_data
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_function_name<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_function_name
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_function_handler<'a>(&self) -> V8handler {
        unsafe {
            self.0
                .get_function_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn execute_function<'a>(
        &self,
        object: &'a mut V8value,
        arguments: Option<&'a [Option<V8value>]>,
    ) -> V8value {
        unsafe {
            self.0
                .execute_function
                .map(|f| {
                    let (arg_object, arg_arguments) = (object, arguments);
                    let arg_self_ = self.as_raw();
                    let arg_object = arg_object.as_raw();
                    let mut arg_arguments_count =
                        arg_arguments.map(|slice| slice.len()).unwrap_or_default();
                    let vec_arguments = arg_arguments
                        .as_ref()
                        .map(|slice| {
                            slice
                                .iter()
                                .map(|elem| {
                                    elem.as_ref()
                                        .map(|elem| elem.as_raw())
                                        .unwrap_or(std::ptr::null_mut())
                                })
                                .collect::<Vec<_>>()
                        })
                        .unwrap_or_default();
                    let arg_arguments = if vec_arguments.is_empty() {
                        std::ptr::null()
                    } else {
                        vec_arguments.as_ptr()
                    };
                    let result = f(arg_self_, arg_object, arg_arguments_count, arg_arguments);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn execute_function_with_context<'a>(
        &self,
        context: &'a mut V8context,
        object: &'a mut V8value,
        arguments: Option<&'a [Option<V8value>]>,
    ) -> V8value {
        unsafe {
            self.0
                .execute_function_with_context
                .map(|f| {
                    let (arg_context, arg_object, arg_arguments) = (context, object, arguments);
                    let arg_self_ = self.as_raw();
                    let arg_context = arg_context.as_raw();
                    let arg_object = arg_object.as_raw();
                    let mut arg_arguments_count =
                        arg_arguments.map(|slice| slice.len()).unwrap_or_default();
                    let vec_arguments = arg_arguments
                        .as_ref()
                        .map(|slice| {
                            slice
                                .iter()
                                .map(|elem| {
                                    elem.as_ref()
                                        .map(|elem| elem.as_raw())
                                        .unwrap_or(std::ptr::null_mut())
                                })
                                .collect::<Vec<_>>()
                        })
                        .unwrap_or_default();
                    let arg_arguments = if vec_arguments.is_empty() {
                        std::ptr::null()
                    } else {
                        vec_arguments.as_ptr()
                    };
                    let result = f(
                        arg_self_,
                        arg_context,
                        arg_object,
                        arg_arguments_count,
                        arg_arguments,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn resolve_promise<'a>(&self, arg: &'a mut V8value) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .resolve_promise
                .map(|f| {
                    let arg_arg = arg;
                    let arg_self_ = self.as_raw();
                    let arg_arg = arg_arg.as_raw();
                    let result = f(arg_self_, arg_arg);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn reject_promise<'a>(&self, error_msg: &'a CefStringUtf16) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .reject_promise
                .map(|f| {
                    let arg_error_msg = error_msg;
                    let arg_self_ = self.as_raw();
                    let arg_error_msg = arg_error_msg.as_raw();
                    let result = f(arg_self_, arg_error_msg);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_v8value_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for V8value {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_v8value_t> for &V8value {
    fn as_raw(self) -> *mut _cef_v8value_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_v8value_t> for &mut V8value {
    fn as_raw(self) -> *mut _cef_v8value_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<V8value> for *mut _cef_v8value_t {
    fn as_wrapper(self) -> V8value {
        V8value(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_v8value_t> for V8value {
    fn into(self) -> *mut _cef_v8value_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for V8value {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplV8stackTrace: Sized {
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_frame_count<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_frame<'a>(&self, index: ::std::os::raw::c_int) -> V8stackFrame {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_v8stack_trace_t {
        let mut object: _cef_v8stack_trace_t = unsafe { std::mem::zeroed() };
        impl_cef_v8stack_trace_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_v8stack_trace_t {
    use super::*;
    pub fn init_methods<I: ImplV8stackTrace>(object: &mut _cef_v8stack_trace_t) {
        object.is_valid = Some(is_valid::<I>);
        object.get_frame_count = Some(get_frame_count::<I>);
        object.get_frame = Some(get_frame::<I>);
    }
    extern "C" fn is_valid<I: ImplV8stackTrace>(
        self_: *mut _cef_v8stack_trace_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_valid().into()
    }
    extern "C" fn get_frame_count<I: ImplV8stackTrace>(
        self_: *mut _cef_v8stack_trace_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_frame_count().into()
    }
    extern "C" fn get_frame<I: ImplV8stackTrace>(
        self_: *mut _cef_v8stack_trace_t,
        index: ::std::os::raw::c_int,
    ) -> *mut _cef_v8stack_frame_t {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        arg_self_.interface.get_frame(arg_index).into()
    }
}
#[doc = "See [_cef_v8stack_trace_t] for more documentation."]
#[derive(Clone)]
pub struct V8stackTrace(RefGuard<_cef_v8stack_trace_t>);
impl ImplV8stackTrace for V8stackTrace {
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_frame_count<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_frame_count
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_frame<'a>(&self, index: ::std::os::raw::c_int) -> V8stackFrame {
        unsafe {
            self.0
                .get_frame
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_v8stack_trace_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for V8stackTrace {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_v8stack_trace_t> for &V8stackTrace {
    fn as_raw(self) -> *mut _cef_v8stack_trace_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_v8stack_trace_t> for &mut V8stackTrace {
    fn as_raw(self) -> *mut _cef_v8stack_trace_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<V8stackTrace> for *mut _cef_v8stack_trace_t {
    fn as_wrapper(self) -> V8stackTrace {
        V8stackTrace(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_v8stack_trace_t> for V8stackTrace {
    fn into(self) -> *mut _cef_v8stack_trace_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for V8stackTrace {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplV8stackFrame: Sized {
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_script_name<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_script_name_or_source_url<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_function_name<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn get_line_number<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_column<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_eval<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_constructor<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_v8stack_frame_t {
        let mut object: _cef_v8stack_frame_t = unsafe { std::mem::zeroed() };
        impl_cef_v8stack_frame_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_v8stack_frame_t {
    use super::*;
    pub fn init_methods<I: ImplV8stackFrame>(object: &mut _cef_v8stack_frame_t) {
        object.is_valid = Some(is_valid::<I>);
        object.get_script_name = Some(get_script_name::<I>);
        object.get_script_name_or_source_url = Some(get_script_name_or_source_url::<I>);
        object.get_function_name = Some(get_function_name::<I>);
        object.get_line_number = Some(get_line_number::<I>);
        object.get_column = Some(get_column::<I>);
        object.is_eval = Some(is_eval::<I>);
        object.is_constructor = Some(is_constructor::<I>);
    }
    extern "C" fn is_valid<I: ImplV8stackFrame>(
        self_: *mut _cef_v8stack_frame_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_valid().into()
    }
    extern "C" fn get_script_name<I: ImplV8stackFrame>(
        self_: *mut _cef_v8stack_frame_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_script_name().into()
    }
    extern "C" fn get_script_name_or_source_url<I: ImplV8stackFrame>(
        self_: *mut _cef_v8stack_frame_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_script_name_or_source_url().into()
    }
    extern "C" fn get_function_name<I: ImplV8stackFrame>(
        self_: *mut _cef_v8stack_frame_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_function_name().into()
    }
    extern "C" fn get_line_number<I: ImplV8stackFrame>(
        self_: *mut _cef_v8stack_frame_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_line_number().into()
    }
    extern "C" fn get_column<I: ImplV8stackFrame>(
        self_: *mut _cef_v8stack_frame_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_column().into()
    }
    extern "C" fn is_eval<I: ImplV8stackFrame>(
        self_: *mut _cef_v8stack_frame_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_eval().into()
    }
    extern "C" fn is_constructor<I: ImplV8stackFrame>(
        self_: *mut _cef_v8stack_frame_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_constructor().into()
    }
}
#[doc = "See [_cef_v8stack_frame_t] for more documentation."]
#[derive(Clone)]
pub struct V8stackFrame(RefGuard<_cef_v8stack_frame_t>);
impl ImplV8stackFrame for V8stackFrame {
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_script_name<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_script_name
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_script_name_or_source_url<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_script_name_or_source_url
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_function_name<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_function_name
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_line_number<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_line_number
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_column<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_column
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_eval<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_eval
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_constructor<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_constructor
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_v8stack_frame_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for V8stackFrame {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_v8stack_frame_t> for &V8stackFrame {
    fn as_raw(self) -> *mut _cef_v8stack_frame_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_v8stack_frame_t> for &mut V8stackFrame {
    fn as_raw(self) -> *mut _cef_v8stack_frame_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<V8stackFrame> for *mut _cef_v8stack_frame_t {
    fn as_wrapper(self) -> V8stackFrame {
        V8stackFrame(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_v8stack_frame_t> for V8stackFrame {
    fn into(self) -> *mut _cef_v8stack_frame_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for V8stackFrame {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplRenderProcessHandler: Sized {
    fn on_web_kit_initialized<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn on_browser_created<'a>(
        &self,
        browser: &'a mut Browser,
        extra_info: &'a mut DictionaryValue,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn on_browser_destroyed<'a>(&self, browser: &'a mut Browser) {
        unsafe { std::mem::zeroed() }
    }
    fn get_load_handler<'a>(&self) -> LoadHandler {
        unsafe { std::mem::zeroed() }
    }
    fn on_context_created<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        context: &'a mut V8context,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn on_context_released<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        context: &'a mut V8context,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn on_uncaught_exception<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        context: &'a mut V8context,
        exception: &'a mut V8exception,
        stack_trace: &'a mut V8stackTrace,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn on_focused_node_changed<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        node: &'a mut Domnode,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn on_process_message_received<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        source_process: ProcessId,
        message: &'a mut ProcessMessage,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_render_process_handler_t {
        let mut object: _cef_render_process_handler_t = unsafe { std::mem::zeroed() };
        impl_cef_render_process_handler_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_render_process_handler_t {
    use super::*;
    pub fn init_methods<I: ImplRenderProcessHandler>(object: &mut _cef_render_process_handler_t) {
        object.on_web_kit_initialized = Some(on_web_kit_initialized::<I>);
        object.on_browser_created = Some(on_browser_created::<I>);
        object.on_browser_destroyed = Some(on_browser_destroyed::<I>);
        object.get_load_handler = Some(get_load_handler::<I>);
        object.on_context_created = Some(on_context_created::<I>);
        object.on_context_released = Some(on_context_released::<I>);
        object.on_uncaught_exception = Some(on_uncaught_exception::<I>);
        object.on_focused_node_changed = Some(on_focused_node_changed::<I>);
        object.on_process_message_received = Some(on_process_message_received::<I>);
    }
    extern "C" fn on_web_kit_initialized<I: ImplRenderProcessHandler>(
        self_: *mut _cef_render_process_handler_t,
    ) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.on_web_kit_initialized()
    }
    extern "C" fn on_browser_created<I: ImplRenderProcessHandler>(
        self_: *mut _cef_render_process_handler_t,
        browser: *mut _cef_browser_t,
        extra_info: *mut _cef_dictionary_value_t,
    ) {
        let (arg_self_, arg_browser, arg_extra_info) = (self_, browser, extra_info);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_extra_info =
            &mut DictionaryValue(unsafe { RefGuard::from_raw_add_ref(arg_extra_info) });
        arg_self_
            .interface
            .on_browser_created(arg_browser, arg_extra_info)
    }
    extern "C" fn on_browser_destroyed<I: ImplRenderProcessHandler>(
        self_: *mut _cef_render_process_handler_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        arg_self_.interface.on_browser_destroyed(arg_browser)
    }
    extern "C" fn get_load_handler<I: ImplRenderProcessHandler>(
        self_: *mut _cef_render_process_handler_t,
    ) -> *mut _cef_load_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_load_handler().into()
    }
    extern "C" fn on_context_created<I: ImplRenderProcessHandler>(
        self_: *mut _cef_render_process_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        context: *mut _cef_v8context_t,
    ) {
        let (arg_self_, arg_browser, arg_frame, arg_context) = (self_, browser, frame, context);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_frame) });
        let arg_context = &mut V8context(unsafe { RefGuard::from_raw_add_ref(arg_context) });
        arg_self_
            .interface
            .on_context_created(arg_browser, arg_frame, arg_context)
    }
    extern "C" fn on_context_released<I: ImplRenderProcessHandler>(
        self_: *mut _cef_render_process_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        context: *mut _cef_v8context_t,
    ) {
        let (arg_self_, arg_browser, arg_frame, arg_context) = (self_, browser, frame, context);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_frame) });
        let arg_context = &mut V8context(unsafe { RefGuard::from_raw_add_ref(arg_context) });
        arg_self_
            .interface
            .on_context_released(arg_browser, arg_frame, arg_context)
    }
    extern "C" fn on_uncaught_exception<I: ImplRenderProcessHandler>(
        self_: *mut _cef_render_process_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        context: *mut _cef_v8context_t,
        exception: *mut _cef_v8exception_t,
        stack_trace: *mut _cef_v8stack_trace_t,
    ) {
        let (arg_self_, arg_browser, arg_frame, arg_context, arg_exception, arg_stack_trace) =
            (self_, browser, frame, context, exception, stack_trace);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_frame) });
        let arg_context = &mut V8context(unsafe { RefGuard::from_raw_add_ref(arg_context) });
        let arg_exception = &mut V8exception(unsafe { RefGuard::from_raw_add_ref(arg_exception) });
        let arg_stack_trace =
            &mut V8stackTrace(unsafe { RefGuard::from_raw_add_ref(arg_stack_trace) });
        arg_self_.interface.on_uncaught_exception(
            arg_browser,
            arg_frame,
            arg_context,
            arg_exception,
            arg_stack_trace,
        )
    }
    extern "C" fn on_focused_node_changed<I: ImplRenderProcessHandler>(
        self_: *mut _cef_render_process_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        node: *mut _cef_domnode_t,
    ) {
        let (arg_self_, arg_browser, arg_frame, arg_node) = (self_, browser, frame, node);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_frame) });
        let arg_node = &mut Domnode(unsafe { RefGuard::from_raw_add_ref(arg_node) });
        arg_self_
            .interface
            .on_focused_node_changed(arg_browser, arg_frame, arg_node)
    }
    extern "C" fn on_process_message_received<I: ImplRenderProcessHandler>(
        self_: *mut _cef_render_process_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        source_process: cef_process_id_t,
        message: *mut _cef_process_message_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_frame, arg_source_process, arg_message) =
            (self_, browser, frame, source_process, message);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_frame) });
        let arg_source_process = arg_source_process.as_raw();
        let arg_message = &mut ProcessMessage(unsafe { RefGuard::from_raw_add_ref(arg_message) });
        arg_self_
            .interface
            .on_process_message_received(arg_browser, arg_frame, arg_source_process, arg_message)
            .into()
    }
}
#[doc = "See [_cef_render_process_handler_t] for more documentation."]
#[derive(Clone)]
pub struct RenderProcessHandler(RefGuard<_cef_render_process_handler_t>);
impl ImplRenderProcessHandler for RenderProcessHandler {
    fn on_web_kit_initialized<'a>(&self) {
        unsafe {
            self.0
                .on_web_kit_initialized
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_browser_created<'a>(
        &self,
        browser: &'a mut Browser,
        extra_info: &'a mut DictionaryValue,
    ) {
        unsafe {
            self.0
                .on_browser_created
                .map(|f| {
                    let (arg_browser, arg_extra_info) = (browser, extra_info);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_extra_info = arg_extra_info.as_raw();
                    let result = f(arg_self_, arg_browser, arg_extra_info);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_browser_destroyed<'a>(&self, browser: &'a mut Browser) {
        unsafe {
            self.0
                .on_browser_destroyed
                .map(|f| {
                    let arg_browser = browser;
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let result = f(arg_self_, arg_browser);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_load_handler<'a>(&self) -> LoadHandler {
        unsafe {
            self.0
                .get_load_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_context_created<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        context: &'a mut V8context,
    ) {
        unsafe {
            self.0
                .on_context_created
                .map(|f| {
                    let (arg_browser, arg_frame, arg_context) = (browser, frame, context);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_frame = arg_frame.as_raw();
                    let arg_context = arg_context.as_raw();
                    let result = f(arg_self_, arg_browser, arg_frame, arg_context);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_context_released<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        context: &'a mut V8context,
    ) {
        unsafe {
            self.0
                .on_context_released
                .map(|f| {
                    let (arg_browser, arg_frame, arg_context) = (browser, frame, context);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_frame = arg_frame.as_raw();
                    let arg_context = arg_context.as_raw();
                    let result = f(arg_self_, arg_browser, arg_frame, arg_context);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_uncaught_exception<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        context: &'a mut V8context,
        exception: &'a mut V8exception,
        stack_trace: &'a mut V8stackTrace,
    ) {
        unsafe {
            self.0
                .on_uncaught_exception
                .map(|f| {
                    let (arg_browser, arg_frame, arg_context, arg_exception, arg_stack_trace) =
                        (browser, frame, context, exception, stack_trace);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_frame = arg_frame.as_raw();
                    let arg_context = arg_context.as_raw();
                    let arg_exception = arg_exception.as_raw();
                    let arg_stack_trace = arg_stack_trace.as_raw();
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_context,
                        arg_exception,
                        arg_stack_trace,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_focused_node_changed<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        node: &'a mut Domnode,
    ) {
        unsafe {
            self.0
                .on_focused_node_changed
                .map(|f| {
                    let (arg_browser, arg_frame, arg_node) = (browser, frame, node);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_frame = arg_frame.as_raw();
                    let arg_node = arg_node.as_raw();
                    let result = f(arg_self_, arg_browser, arg_frame, arg_node);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_process_message_received<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        source_process: ProcessId,
        message: &'a mut ProcessMessage,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_process_message_received
                .map(|f| {
                    let (arg_browser, arg_frame, arg_source_process, arg_message) =
                        (browser, frame, source_process, message);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_frame = arg_frame.as_raw();
                    let arg_source_process = arg_source_process.as_raw();
                    let arg_message = arg_message.as_raw();
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_source_process,
                        arg_message,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_render_process_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for RenderProcessHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_render_process_handler_t> for &RenderProcessHandler {
    fn as_raw(self) -> *mut _cef_render_process_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_render_process_handler_t> for &mut RenderProcessHandler {
    fn as_raw(self) -> *mut _cef_render_process_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<RenderProcessHandler> for *mut _cef_render_process_handler_t {
    fn as_wrapper(self) -> RenderProcessHandler {
        RenderProcessHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_render_process_handler_t> for RenderProcessHandler {
    fn into(self) -> *mut _cef_render_process_handler_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for RenderProcessHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplResourceBundleHandler: Sized {
    fn get_localized_string<'a>(
        &self,
        string_id: ::std::os::raw::c_int,
        string: &'a mut CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_data_resource<'a>(
        &self,
        resource_id: ::std::os::raw::c_int,
        data: Option<&'a mut &'a mut [u8]>,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_data_resource_for_scale<'a>(
        &self,
        resource_id: ::std::os::raw::c_int,
        scale_factor: ScaleFactor,
        data: Option<&'a mut &'a mut [u8]>,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_resource_bundle_handler_t {
        let mut object: _cef_resource_bundle_handler_t = unsafe { std::mem::zeroed() };
        impl_cef_resource_bundle_handler_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_resource_bundle_handler_t {
    use super::*;
    pub fn init_methods<I: ImplResourceBundleHandler>(object: &mut _cef_resource_bundle_handler_t) {
        object.get_localized_string = Some(get_localized_string::<I>);
        object.get_data_resource = Some(get_data_resource::<I>);
        object.get_data_resource_for_scale = Some(get_data_resource_for_scale::<I>);
    }
    extern "C" fn get_localized_string<I: ImplResourceBundleHandler>(
        self_: *mut _cef_resource_bundle_handler_t,
        string_id: ::std::os::raw::c_int,
        string: *mut _cef_string_utf16_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_string_id, arg_string) = (self_, string_id, string);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_string_id = arg_string_id.as_raw();
        let mut arg_string = WrapParamRef::<CefStringUtf16>::from(arg_string);
        let arg_string = arg_string.as_mut();
        arg_self_
            .interface
            .get_localized_string(arg_string_id, arg_string)
            .into()
    }
    extern "C" fn get_data_resource<I: ImplResourceBundleHandler>(
        self_: *mut _cef_resource_bundle_handler_t,
        resource_id: ::std::os::raw::c_int,
        data: *mut *mut ::std::os::raw::c_void,
        data_size: *mut usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_resource_id, arg_data, arg_data_size) =
            (self_, resource_id, data, data_size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_resource_id = arg_resource_id.as_raw();
        let mut out_data_size = unsafe { arg_data_size.as_mut() };
        let arg_data_size = out_data_size.unwrap_or_default();
        let mut out_data = (!arg_data.is_null() && arg_data_size > 0)
            .then(|| unsafe { std::slice::from_raw_parts_mut(arg_data as *mut _, arg_data_size) });
        let arg_buffer = out_buffer.as_mut();
        arg_self_
            .interface
            .get_data_resource(arg_resource_id, arg_data)
            .into()
    }
    extern "C" fn get_data_resource_for_scale<I: ImplResourceBundleHandler>(
        self_: *mut _cef_resource_bundle_handler_t,
        resource_id: ::std::os::raw::c_int,
        scale_factor: cef_scale_factor_t,
        data: *mut *mut ::std::os::raw::c_void,
        data_size: *mut usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_resource_id, arg_scale_factor, arg_data, arg_data_size) =
            (self_, resource_id, scale_factor, data, data_size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_resource_id = arg_resource_id.as_raw();
        let arg_scale_factor = arg_scale_factor.as_raw();
        let mut out_data_size = unsafe { arg_data_size.as_mut() };
        let arg_data_size = out_data_size.unwrap_or_default();
        let mut out_data = (!arg_data.is_null() && arg_data_size > 0)
            .then(|| unsafe { std::slice::from_raw_parts_mut(arg_data as *mut _, arg_data_size) });
        let arg_buffer = out_buffer.as_mut();
        arg_self_
            .interface
            .get_data_resource_for_scale(arg_resource_id, arg_scale_factor, arg_data)
            .into()
    }
}
#[doc = "See [_cef_resource_bundle_handler_t] for more documentation."]
#[derive(Clone)]
pub struct ResourceBundleHandler(RefGuard<_cef_resource_bundle_handler_t>);
impl ImplResourceBundleHandler for ResourceBundleHandler {
    fn get_localized_string<'a>(
        &self,
        string_id: ::std::os::raw::c_int,
        string: &'a mut CefStringUtf16,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_localized_string
                .map(|f| {
                    let (arg_string_id, arg_string) = (string_id, string);
                    let arg_self_ = self.as_raw();
                    let arg_string_id = arg_string_id;
                    let arg_string = arg_string.as_raw();
                    let result = f(arg_self_, arg_string_id, arg_string);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_data_resource<'a>(
        &self,
        resource_id: ::std::os::raw::c_int,
        data: Option<&'a mut &'a mut [u8]>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_data_resource
                .map(|f| {
                    let (arg_resource_id, arg_data) = (resource_id, data);
                    let arg_self_ = self.as_raw();
                    let arg_resource_id = arg_resource_id;
                    let mut out_data_size = arg_data
                        .as_ref()
                        .map(|slice| slice.len())
                        .unwrap_or_default();
                    let arg_data_size = &mut out_data_size;
                    let mut out_data = arg_data;
                    let arg_data = out_data
                        .as_mut()
                        .and_then(|slice| {
                            if slice.is_empty() {
                                None
                            } else {
                                Some(slice.as_mut_ptr() as *mut _)
                            }
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_resource_id, arg_data, arg_data_size);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_data_resource_for_scale<'a>(
        &self,
        resource_id: ::std::os::raw::c_int,
        scale_factor: ScaleFactor,
        data: Option<&'a mut &'a mut [u8]>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_data_resource_for_scale
                .map(|f| {
                    let (arg_resource_id, arg_scale_factor, arg_data) =
                        (resource_id, scale_factor, data);
                    let arg_self_ = self.as_raw();
                    let arg_resource_id = arg_resource_id;
                    let arg_scale_factor = arg_scale_factor.as_raw();
                    let mut out_data_size = arg_data
                        .as_ref()
                        .map(|slice| slice.len())
                        .unwrap_or_default();
                    let arg_data_size = &mut out_data_size;
                    let mut out_data = arg_data;
                    let arg_data = out_data
                        .as_mut()
                        .and_then(|slice| {
                            if slice.is_empty() {
                                None
                            } else {
                                Some(slice.as_mut_ptr() as *mut _)
                            }
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_resource_id,
                        arg_scale_factor,
                        arg_data,
                        arg_data_size,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_resource_bundle_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ResourceBundleHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_resource_bundle_handler_t> for &ResourceBundleHandler {
    fn as_raw(self) -> *mut _cef_resource_bundle_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_resource_bundle_handler_t> for &mut ResourceBundleHandler {
    fn as_raw(self) -> *mut _cef_resource_bundle_handler_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<ResourceBundleHandler> for *mut _cef_resource_bundle_handler_t {
    fn as_wrapper(self) -> ResourceBundleHandler {
        ResourceBundleHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_resource_bundle_handler_t> for ResourceBundleHandler {
    fn into(self) -> *mut _cef_resource_bundle_handler_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for ResourceBundleHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [_cef_scheme_registrar_t] for more documentation."]
#[repr(transparent)]
pub struct SchemeRegistrar(_cef_scheme_registrar_t);
impl From<_cef_scheme_registrar_t> for SchemeRegistrar {
    fn from(value: _cef_scheme_registrar_t) -> Self {
        Self(value)
    }
}
impl Into<*const _cef_scheme_registrar_t> for &SchemeRegistrar {
    fn into(self) -> *const _cef_scheme_registrar_t {
        self.as_ref() as *const _cef_scheme_registrar_t
    }
}
impl Into<*mut _cef_scheme_registrar_t> for &mut SchemeRegistrar {
    fn into(self) -> *mut _cef_scheme_registrar_t {
        self.as_mut() as *mut _cef_scheme_registrar_t
    }
}
impl Into<_cef_scheme_registrar_t> for SchemeRegistrar {
    fn into(self) -> _cef_scheme_registrar_t {
        self.0
    }
}
impl AsRef<_cef_scheme_registrar_t> for SchemeRegistrar {
    fn as_ref(&self) -> &_cef_scheme_registrar_t {
        &self.0
    }
}
impl AsMut<_cef_scheme_registrar_t> for SchemeRegistrar {
    fn as_mut(&mut self) -> &mut _cef_scheme_registrar_t {
        &mut self.0
    }
}
impl Default for SchemeRegistrar {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplSchemeHandlerFactory: Sized {
    fn create<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        scheme_name: &'a CefStringUtf16,
        request: &'a mut Request,
    ) -> ResourceHandler {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_scheme_handler_factory_t {
        let mut object: _cef_scheme_handler_factory_t = unsafe { std::mem::zeroed() };
        impl_cef_scheme_handler_factory_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_scheme_handler_factory_t {
    use super::*;
    pub fn init_methods<I: ImplSchemeHandlerFactory>(object: &mut _cef_scheme_handler_factory_t) {
        object.create = Some(create::<I>);
    }
    extern "C" fn create<I: ImplSchemeHandlerFactory>(
        self_: *mut _cef_scheme_handler_factory_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        scheme_name: *const _cef_string_utf16_t,
        request: *mut _cef_request_t,
    ) -> *mut _cef_resource_handler_t {
        let (arg_self_, arg_browser, arg_frame, arg_scheme_name, arg_request) =
            (self_, browser, frame, scheme_name, request);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        let arg_frame = &mut Frame(unsafe { RefGuard::from_raw_add_ref(arg_frame) });
        let arg_scheme_name = WrapParamRef::<CefStringUtf16>::from(arg_scheme_name);
        let arg_scheme_name = arg_scheme_name.as_ref();
        let arg_request = &mut Request(unsafe { RefGuard::from_raw_add_ref(arg_request) });
        arg_self_
            .interface
            .create(arg_browser, arg_frame, arg_scheme_name, arg_request)
            .into()
    }
}
#[doc = "See [_cef_scheme_handler_factory_t] for more documentation."]
#[derive(Clone)]
pub struct SchemeHandlerFactory(RefGuard<_cef_scheme_handler_factory_t>);
impl ImplSchemeHandlerFactory for SchemeHandlerFactory {
    fn create<'a>(
        &self,
        browser: &'a mut Browser,
        frame: &'a mut Frame,
        scheme_name: &'a CefStringUtf16,
        request: &'a mut Request,
    ) -> ResourceHandler {
        unsafe {
            self.0
                .create
                .map(|f| {
                    let (arg_browser, arg_frame, arg_scheme_name, arg_request) =
                        (browser, frame, scheme_name, request);
                    let arg_self_ = self.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let arg_frame = arg_frame.as_raw();
                    let arg_scheme_name = arg_scheme_name.as_raw();
                    let arg_request = arg_request.as_raw();
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_scheme_name,
                        arg_request,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_scheme_handler_factory_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for SchemeHandlerFactory {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_scheme_handler_factory_t> for &SchemeHandlerFactory {
    fn as_raw(self) -> *mut _cef_scheme_handler_factory_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_scheme_handler_factory_t> for &mut SchemeHandlerFactory {
    fn as_raw(self) -> *mut _cef_scheme_handler_factory_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<SchemeHandlerFactory> for *mut _cef_scheme_handler_factory_t {
    fn as_wrapper(self) -> SchemeHandlerFactory {
        SchemeHandlerFactory(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_scheme_handler_factory_t> for SchemeHandlerFactory {
    fn into(self) -> *mut _cef_scheme_handler_factory_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for SchemeHandlerFactory {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplApp: Sized {
    fn on_before_command_line_processing<'a>(
        &self,
        process_type: &'a CefStringUtf16,
        command_line: &'a mut CommandLine,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn on_register_custom_schemes<'a>(&self, registrar: &'a mut SchemeRegistrar) {
        unsafe { std::mem::zeroed() }
    }
    fn get_resource_bundle_handler<'a>(&self) -> ResourceBundleHandler {
        unsafe { std::mem::zeroed() }
    }
    fn get_browser_process_handler<'a>(&self) -> BrowserProcessHandler {
        unsafe { std::mem::zeroed() }
    }
    fn get_render_process_handler<'a>(&self) -> RenderProcessHandler {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_app_t {
        let mut object: _cef_app_t = unsafe { std::mem::zeroed() };
        impl_cef_app_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_app_t {
    use super::*;
    pub fn init_methods<I: ImplApp>(object: &mut _cef_app_t) {
        object.on_before_command_line_processing = Some(on_before_command_line_processing::<I>);
        object.on_register_custom_schemes = Some(on_register_custom_schemes::<I>);
        object.get_resource_bundle_handler = Some(get_resource_bundle_handler::<I>);
        object.get_browser_process_handler = Some(get_browser_process_handler::<I>);
        object.get_render_process_handler = Some(get_render_process_handler::<I>);
    }
    extern "C" fn on_before_command_line_processing<I: ImplApp>(
        self_: *mut _cef_app_t,
        process_type: *const _cef_string_utf16_t,
        command_line: *mut _cef_command_line_t,
    ) {
        let (arg_self_, arg_process_type, arg_command_line) = (self_, process_type, command_line);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_process_type = WrapParamRef::<CefStringUtf16>::from(arg_process_type);
        let arg_process_type = arg_process_type.as_ref();
        let arg_command_line =
            &mut CommandLine(unsafe { RefGuard::from_raw_add_ref(arg_command_line) });
        arg_self_
            .interface
            .on_before_command_line_processing(arg_process_type, arg_command_line)
    }
    extern "C" fn on_register_custom_schemes<I: ImplApp>(
        self_: *mut _cef_app_t,
        registrar: *mut _cef_scheme_registrar_t,
    ) {
        let (arg_self_, arg_registrar) = (self_, registrar);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_registrar = WrapParamRef::<SchemeRegistrar>::from(arg_registrar);
        let arg_registrar = arg_registrar.as_mut();
        arg_self_
            .interface
            .on_register_custom_schemes(arg_registrar)
    }
    extern "C" fn get_resource_bundle_handler<I: ImplApp>(
        self_: *mut _cef_app_t,
    ) -> *mut _cef_resource_bundle_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_resource_bundle_handler().into()
    }
    extern "C" fn get_browser_process_handler<I: ImplApp>(
        self_: *mut _cef_app_t,
    ) -> *mut _cef_browser_process_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_browser_process_handler().into()
    }
    extern "C" fn get_render_process_handler<I: ImplApp>(
        self_: *mut _cef_app_t,
    ) -> *mut _cef_render_process_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_render_process_handler().into()
    }
}
#[doc = "See [_cef_app_t] for more documentation."]
#[derive(Clone)]
pub struct App(RefGuard<_cef_app_t>);
impl ImplApp for App {
    fn on_before_command_line_processing<'a>(
        &self,
        process_type: &'a CefStringUtf16,
        command_line: &'a mut CommandLine,
    ) {
        unsafe {
            self.0
                .on_before_command_line_processing
                .map(|f| {
                    let (arg_process_type, arg_command_line) = (process_type, command_line);
                    let arg_self_ = self.as_raw();
                    let arg_process_type = arg_process_type.as_raw();
                    let arg_command_line = arg_command_line.as_raw();
                    let result = f(arg_self_, arg_process_type, arg_command_line);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_register_custom_schemes<'a>(&self, registrar: &'a mut SchemeRegistrar) {
        unsafe {
            self.0
                .on_register_custom_schemes
                .map(|f| {
                    let arg_registrar = registrar;
                    let arg_self_ = self.as_raw();
                    let arg_registrar = arg_registrar.as_raw();
                    let result = f(arg_self_, arg_registrar);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_resource_bundle_handler<'a>(&self) -> ResourceBundleHandler {
        unsafe {
            self.0
                .get_resource_bundle_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_browser_process_handler<'a>(&self) -> BrowserProcessHandler {
        unsafe {
            self.0
                .get_browser_process_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_render_process_handler<'a>(&self) -> RenderProcessHandler {
        unsafe {
            self.0
                .get_render_process_handler
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_app_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for App {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_app_t> for &App {
    fn as_raw(self) -> *mut _cef_app_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_app_t> for &mut App {
    fn as_raw(self) -> *mut _cef_app_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<App> for *mut _cef_app_t {
    fn as_wrapper(self) -> App {
        App(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_app_t> for App {
    fn into(self) -> *mut _cef_app_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for App {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplUrlrequest: Sized {
    fn get_request<'a>(&self) -> Request {
        unsafe { std::mem::zeroed() }
    }
    fn get_client<'a>(&self) -> UrlrequestClient {
        unsafe { std::mem::zeroed() }
    }
    fn get_request_status<'a>(&self) -> UrlrequestStatus {
        unsafe { std::mem::zeroed() }
    }
    fn get_request_error<'a>(&self) -> Errorcode {
        unsafe { std::mem::zeroed() }
    }
    fn get_response<'a>(&self) -> Response {
        unsafe { std::mem::zeroed() }
    }
    fn response_was_cached<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn cancel<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_urlrequest_t {
        let mut object: _cef_urlrequest_t = unsafe { std::mem::zeroed() };
        impl_cef_urlrequest_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_urlrequest_t {
    use super::*;
    pub fn init_methods<I: ImplUrlrequest>(object: &mut _cef_urlrequest_t) {
        object.get_request = Some(get_request::<I>);
        object.get_client = Some(get_client::<I>);
        object.get_request_status = Some(get_request_status::<I>);
        object.get_request_error = Some(get_request_error::<I>);
        object.get_response = Some(get_response::<I>);
        object.response_was_cached = Some(response_was_cached::<I>);
        object.cancel = Some(cancel::<I>);
    }
    extern "C" fn get_request<I: ImplUrlrequest>(
        self_: *mut _cef_urlrequest_t,
    ) -> *mut _cef_request_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_request().into()
    }
    extern "C" fn get_client<I: ImplUrlrequest>(
        self_: *mut _cef_urlrequest_t,
    ) -> *mut _cef_urlrequest_client_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_client().into()
    }
    extern "C" fn get_request_status<I: ImplUrlrequest>(
        self_: *mut _cef_urlrequest_t,
    ) -> cef_urlrequest_status_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_request_status().into()
    }
    extern "C" fn get_request_error<I: ImplUrlrequest>(
        self_: *mut _cef_urlrequest_t,
    ) -> cef_errorcode_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_request_error().into()
    }
    extern "C" fn get_response<I: ImplUrlrequest>(
        self_: *mut _cef_urlrequest_t,
    ) -> *mut _cef_response_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_response().into()
    }
    extern "C" fn response_was_cached<I: ImplUrlrequest>(
        self_: *mut _cef_urlrequest_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.response_was_cached().into()
    }
    extern "C" fn cancel<I: ImplUrlrequest>(self_: *mut _cef_urlrequest_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.cancel()
    }
}
#[doc = "See [_cef_urlrequest_t] for more documentation."]
#[derive(Clone)]
pub struct Urlrequest(RefGuard<_cef_urlrequest_t>);
impl ImplUrlrequest for Urlrequest {
    fn get_request<'a>(&self) -> Request {
        unsafe {
            self.0
                .get_request
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_client<'a>(&self) -> UrlrequestClient {
        unsafe {
            self.0
                .get_client
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_request_status<'a>(&self) -> UrlrequestStatus {
        unsafe {
            self.0
                .get_request_status
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_request_error<'a>(&self) -> Errorcode {
        unsafe {
            self.0
                .get_request_error
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_response<'a>(&self) -> Response {
        unsafe {
            self.0
                .get_response
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn response_was_cached<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .response_was_cached
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn cancel<'a>(&self) {
        unsafe {
            self.0
                .cancel
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_urlrequest_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Urlrequest {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_urlrequest_t> for &Urlrequest {
    fn as_raw(self) -> *mut _cef_urlrequest_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_urlrequest_t> for &mut Urlrequest {
    fn as_raw(self) -> *mut _cef_urlrequest_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<Urlrequest> for *mut _cef_urlrequest_t {
    fn as_wrapper(self) -> Urlrequest {
        Urlrequest(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_urlrequest_t> for Urlrequest {
    fn into(self) -> *mut _cef_urlrequest_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for Urlrequest {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplUrlrequestClient: Sized {
    fn on_request_complete<'a>(&self, request: &'a mut Urlrequest) {
        unsafe { std::mem::zeroed() }
    }
    fn on_upload_progress<'a>(&self, request: &'a mut Urlrequest, current: i64, total: i64) {
        unsafe { std::mem::zeroed() }
    }
    fn on_download_progress<'a>(&self, request: &'a mut Urlrequest, current: i64, total: i64) {
        unsafe { std::mem::zeroed() }
    }
    fn on_download_data<'a>(
        &self,
        request: &'a mut Urlrequest,
        data: *const ::std::os::raw::c_void,
        data_length: usize,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn get_auth_credentials<'a>(
        &self,
        is_proxy: ::std::os::raw::c_int,
        host: &'a CefStringUtf16,
        port: ::std::os::raw::c_int,
        realm: &'a CefStringUtf16,
        scheme: &'a CefStringUtf16,
        callback: &'a mut AuthCallback,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_urlrequest_client_t {
        let mut object: _cef_urlrequest_client_t = unsafe { std::mem::zeroed() };
        impl_cef_urlrequest_client_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_urlrequest_client_t {
    use super::*;
    pub fn init_methods<I: ImplUrlrequestClient>(object: &mut _cef_urlrequest_client_t) {
        object.on_request_complete = Some(on_request_complete::<I>);
        object.on_upload_progress = Some(on_upload_progress::<I>);
        object.on_download_progress = Some(on_download_progress::<I>);
        object.on_download_data = Some(on_download_data::<I>);
        object.get_auth_credentials = Some(get_auth_credentials::<I>);
    }
    extern "C" fn on_request_complete<I: ImplUrlrequestClient>(
        self_: *mut _cef_urlrequest_client_t,
        request: *mut _cef_urlrequest_t,
    ) {
        let (arg_self_, arg_request) = (self_, request);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_request = &mut Urlrequest(unsafe { RefGuard::from_raw_add_ref(arg_request) });
        arg_self_.interface.on_request_complete(arg_request)
    }
    extern "C" fn on_upload_progress<I: ImplUrlrequestClient>(
        self_: *mut _cef_urlrequest_client_t,
        request: *mut _cef_urlrequest_t,
        current: i64,
        total: i64,
    ) {
        let (arg_self_, arg_request, arg_current, arg_total) = (self_, request, current, total);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_request = &mut Urlrequest(unsafe { RefGuard::from_raw_add_ref(arg_request) });
        let arg_current = arg_current.as_raw();
        let arg_total = arg_total.as_raw();
        arg_self_
            .interface
            .on_upload_progress(arg_request, arg_current, arg_total)
    }
    extern "C" fn on_download_progress<I: ImplUrlrequestClient>(
        self_: *mut _cef_urlrequest_client_t,
        request: *mut _cef_urlrequest_t,
        current: i64,
        total: i64,
    ) {
        let (arg_self_, arg_request, arg_current, arg_total) = (self_, request, current, total);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_request = &mut Urlrequest(unsafe { RefGuard::from_raw_add_ref(arg_request) });
        let arg_current = arg_current.as_raw();
        let arg_total = arg_total.as_raw();
        arg_self_
            .interface
            .on_download_progress(arg_request, arg_current, arg_total)
    }
    extern "C" fn on_download_data<I: ImplUrlrequestClient>(
        self_: *mut _cef_urlrequest_client_t,
        request: *mut _cef_urlrequest_t,
        data: *const ::std::os::raw::c_void,
        data_length: usize,
    ) {
        let (arg_self_, arg_request, arg_data, arg_data_length) =
            (self_, request, data, data_length);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_request = &mut Urlrequest(unsafe { RefGuard::from_raw_add_ref(arg_request) });
        let arg_data_length = arg_data_length.as_raw();
        arg_self_
            .interface
            .on_download_data(arg_request, arg_data, arg_data_length)
    }
    extern "C" fn get_auth_credentials<I: ImplUrlrequestClient>(
        self_: *mut _cef_urlrequest_client_t,
        is_proxy: ::std::os::raw::c_int,
        host: *const _cef_string_utf16_t,
        port: ::std::os::raw::c_int,
        realm: *const _cef_string_utf16_t,
        scheme: *const _cef_string_utf16_t,
        callback: *mut _cef_auth_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_is_proxy, arg_host, arg_port, arg_realm, arg_scheme, arg_callback) =
            (self_, is_proxy, host, port, realm, scheme, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_is_proxy = arg_is_proxy.as_raw();
        let arg_host = WrapParamRef::<CefStringUtf16>::from(arg_host);
        let arg_host = arg_host.as_ref();
        let arg_port = arg_port.as_raw();
        let arg_realm = WrapParamRef::<CefStringUtf16>::from(arg_realm);
        let arg_realm = arg_realm.as_ref();
        let arg_scheme = WrapParamRef::<CefStringUtf16>::from(arg_scheme);
        let arg_scheme = arg_scheme.as_ref();
        let arg_callback = &mut AuthCallback(unsafe { RefGuard::from_raw_add_ref(arg_callback) });
        arg_self_
            .interface
            .get_auth_credentials(
                arg_is_proxy,
                arg_host,
                arg_port,
                arg_realm,
                arg_scheme,
                arg_callback,
            )
            .into()
    }
}
#[doc = "See [_cef_urlrequest_client_t] for more documentation."]
#[derive(Clone)]
pub struct UrlrequestClient(RefGuard<_cef_urlrequest_client_t>);
impl ImplUrlrequestClient for UrlrequestClient {
    fn on_request_complete<'a>(&self, request: &'a mut Urlrequest) {
        unsafe {
            self.0
                .on_request_complete
                .map(|f| {
                    let arg_request = request;
                    let arg_self_ = self.as_raw();
                    let arg_request = arg_request.as_raw();
                    let result = f(arg_self_, arg_request);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_upload_progress<'a>(&self, request: &'a mut Urlrequest, current: i64, total: i64) {
        unsafe {
            self.0
                .on_upload_progress
                .map(|f| {
                    let (arg_request, arg_current, arg_total) = (request, current, total);
                    let arg_self_ = self.as_raw();
                    let arg_request = arg_request.as_raw();
                    let arg_current = arg_current;
                    let arg_total = arg_total;
                    let result = f(arg_self_, arg_request, arg_current, arg_total);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_download_progress<'a>(&self, request: &'a mut Urlrequest, current: i64, total: i64) {
        unsafe {
            self.0
                .on_download_progress
                .map(|f| {
                    let (arg_request, arg_current, arg_total) = (request, current, total);
                    let arg_self_ = self.as_raw();
                    let arg_request = arg_request.as_raw();
                    let arg_current = arg_current;
                    let arg_total = arg_total;
                    let result = f(arg_self_, arg_request, arg_current, arg_total);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_download_data<'a>(
        &self,
        request: &'a mut Urlrequest,
        data: *const ::std::os::raw::c_void,
        data_length: usize,
    ) {
        unsafe {
            self.0
                .on_download_data
                .map(|f| {
                    let (arg_request, arg_data, arg_data_length) = (request, data, data_length);
                    let arg_self_ = self.as_raw();
                    let arg_request = arg_request.as_raw();
                    let arg_data = arg_data as *const _;
                    let arg_data_length = arg_data_length;
                    let result = f(arg_self_, arg_request, arg_data, arg_data_length);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_auth_credentials<'a>(
        &self,
        is_proxy: ::std::os::raw::c_int,
        host: &'a CefStringUtf16,
        port: ::std::os::raw::c_int,
        realm: &'a CefStringUtf16,
        scheme: &'a CefStringUtf16,
        callback: &'a mut AuthCallback,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_auth_credentials
                .map(|f| {
                    let (arg_is_proxy, arg_host, arg_port, arg_realm, arg_scheme, arg_callback) =
                        (is_proxy, host, port, realm, scheme, callback);
                    let arg_self_ = self.as_raw();
                    let arg_is_proxy = arg_is_proxy;
                    let arg_host = arg_host.as_raw();
                    let arg_port = arg_port;
                    let arg_realm = arg_realm.as_raw();
                    let arg_scheme = arg_scheme.as_raw();
                    let arg_callback = arg_callback.as_raw();
                    let result = f(
                        arg_self_,
                        arg_is_proxy,
                        arg_host,
                        arg_port,
                        arg_realm,
                        arg_scheme,
                        arg_callback,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_urlrequest_client_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for UrlrequestClient {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_urlrequest_client_t> for &UrlrequestClient {
    fn as_raw(self) -> *mut _cef_urlrequest_client_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_urlrequest_client_t> for &mut UrlrequestClient {
    fn as_raw(self) -> *mut _cef_urlrequest_client_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<UrlrequestClient> for *mut _cef_urlrequest_client_t {
    fn as_wrapper(self) -> UrlrequestClient {
        UrlrequestClient(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_urlrequest_client_t> for UrlrequestClient {
    fn into(self) -> *mut _cef_urlrequest_client_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for UrlrequestClient {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplLayout: Sized {
    fn as_box_layout<'a>(&self) -> BoxLayout {
        unsafe { std::mem::zeroed() }
    }
    fn as_fill_layout<'a>(&self) -> FillLayout {
        unsafe { std::mem::zeroed() }
    }
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_layout_t {
        let mut object: _cef_layout_t = unsafe { std::mem::zeroed() };
        impl_cef_layout_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_layout_t {
    use super::*;
    pub fn init_methods<I: ImplLayout>(object: &mut _cef_layout_t) {
        object.as_box_layout = Some(as_box_layout::<I>);
        object.as_fill_layout = Some(as_fill_layout::<I>);
        object.is_valid = Some(is_valid::<I>);
    }
    extern "C" fn as_box_layout<I: ImplLayout>(
        self_: *mut _cef_layout_t,
    ) -> *mut _cef_box_layout_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.as_box_layout().into()
    }
    extern "C" fn as_fill_layout<I: ImplLayout>(
        self_: *mut _cef_layout_t,
    ) -> *mut _cef_fill_layout_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.as_fill_layout().into()
    }
    extern "C" fn is_valid<I: ImplLayout>(self_: *mut _cef_layout_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_valid().into()
    }
}
#[doc = "See [_cef_layout_t] for more documentation."]
#[derive(Clone)]
pub struct Layout(RefGuard<_cef_layout_t>);
impl ImplLayout for Layout {
    fn as_box_layout<'a>(&self) -> BoxLayout {
        unsafe {
            self.0
                .as_box_layout
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn as_fill_layout<'a>(&self) -> FillLayout {
        unsafe {
            self.0
                .as_fill_layout
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_layout_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Layout {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_layout_t> for &Layout {
    fn as_raw(self) -> *mut _cef_layout_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_layout_t> for &mut Layout {
    fn as_raw(self) -> *mut _cef_layout_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<Layout> for *mut _cef_layout_t {
    fn as_wrapper(self) -> Layout {
        Layout(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_layout_t> for Layout {
    fn into(self) -> *mut _cef_layout_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for Layout {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplBoxLayout: ImplLayout {
    fn set_flex_for_view<'a>(&self, view: &'a mut View, flex: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn clear_flex_for_view<'a>(&self, view: &'a mut View) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_box_layout_t {
        let mut object: _cef_box_layout_t = unsafe { std::mem::zeroed() };
        impl_cef_layout_t::init_methods::<Self>(&mut object.base);
        impl_cef_box_layout_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_box_layout_t {
    use super::*;
    pub fn init_methods<I: ImplBoxLayout>(object: &mut _cef_box_layout_t) {
        object.set_flex_for_view = Some(set_flex_for_view::<I>);
        object.clear_flex_for_view = Some(clear_flex_for_view::<I>);
    }
    extern "C" fn set_flex_for_view<I: ImplBoxLayout>(
        self_: *mut _cef_box_layout_t,
        view: *mut _cef_view_t,
        flex: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_view, arg_flex) = (self_, view, flex);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_view = &mut View(unsafe { RefGuard::from_raw_add_ref(arg_view) });
        let arg_flex = arg_flex.as_raw();
        arg_self_.interface.set_flex_for_view(arg_view, arg_flex)
    }
    extern "C" fn clear_flex_for_view<I: ImplBoxLayout>(
        self_: *mut _cef_box_layout_t,
        view: *mut _cef_view_t,
    ) {
        let (arg_self_, arg_view) = (self_, view);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_view = &mut View(unsafe { RefGuard::from_raw_add_ref(arg_view) });
        arg_self_.interface.clear_flex_for_view(arg_view)
    }
}
#[doc = "See [_cef_box_layout_t] for more documentation."]
#[derive(Clone)]
pub struct BoxLayout(RefGuard<_cef_box_layout_t>);
impl ImplLayout for BoxLayout {
    fn as_box_layout<'a>(&self) -> BoxLayout {
        Layout(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_box_layout()
    }
    fn as_fill_layout<'a>(&self) -> FillLayout {
        Layout(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_fill_layout()
    }
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        Layout(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_valid()
    }
}
impl ImplBoxLayout for BoxLayout {
    fn set_flex_for_view<'a>(&self, view: &'a mut View, flex: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_flex_for_view
                .map(|f| {
                    let (arg_view, arg_flex) = (view, flex);
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view.as_raw();
                    let arg_flex = arg_flex;
                    let result = f(arg_self_, arg_view, arg_flex);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn clear_flex_for_view<'a>(&self, view: &'a mut View) {
        unsafe {
            self.0
                .clear_flex_for_view
                .map(|f| {
                    let arg_view = view;
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view.as_raw();
                    let result = f(arg_self_, arg_view);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_box_layout_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for BoxLayout {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_box_layout_t> for &BoxLayout {
    fn as_raw(self) -> *mut _cef_box_layout_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_box_layout_t> for &mut BoxLayout {
    fn as_raw(self) -> *mut _cef_box_layout_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<BoxLayout> for *mut _cef_box_layout_t {
    fn as_wrapper(self) -> BoxLayout {
        BoxLayout(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_box_layout_t> for BoxLayout {
    fn into(self) -> *mut _cef_box_layout_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for BoxLayout {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplFillLayout: ImplLayout {
    fn into_raw(self) -> *mut _cef_fill_layout_t {
        let mut object: _cef_fill_layout_t = unsafe { std::mem::zeroed() };
        impl_cef_layout_t::init_methods::<Self>(&mut object.base);
        impl_cef_fill_layout_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_fill_layout_t {
    use super::*;
    pub fn init_methods<I: ImplFillLayout>(object: &mut _cef_fill_layout_t) {}
}
#[doc = "See [_cef_fill_layout_t] for more documentation."]
#[derive(Clone)]
pub struct FillLayout(RefGuard<_cef_fill_layout_t>);
impl ImplLayout for FillLayout {
    fn as_box_layout<'a>(&self) -> BoxLayout {
        Layout(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_box_layout()
    }
    fn as_fill_layout<'a>(&self) -> FillLayout {
        Layout(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_fill_layout()
    }
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        Layout(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_valid()
    }
}
impl ImplFillLayout for FillLayout {}
impl Rc for _cef_fill_layout_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for FillLayout {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_fill_layout_t> for &FillLayout {
    fn as_raw(self) -> *mut _cef_fill_layout_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_fill_layout_t> for &mut FillLayout {
    fn as_raw(self) -> *mut _cef_fill_layout_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<FillLayout> for *mut _cef_fill_layout_t {
    fn as_wrapper(self) -> FillLayout {
        FillLayout(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_fill_layout_t> for FillLayout {
    fn into(self) -> *mut _cef_fill_layout_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for FillLayout {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplViewDelegate: Sized {
    fn get_preferred_size<'a>(&self, view: &'a mut View) -> Size {
        unsafe { std::mem::zeroed() }
    }
    fn get_minimum_size<'a>(&self, view: &'a mut View) -> Size {
        unsafe { std::mem::zeroed() }
    }
    fn get_maximum_size<'a>(&self, view: &'a mut View) -> Size {
        unsafe { std::mem::zeroed() }
    }
    fn get_height_for_width<'a>(
        &self,
        view: &'a mut View,
        width: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn on_parent_view_changed<'a>(
        &self,
        view: &'a mut View,
        added: ::std::os::raw::c_int,
        parent: &'a mut View,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn on_child_view_changed<'a>(
        &self,
        view: &'a mut View,
        added: ::std::os::raw::c_int,
        child: &'a mut View,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn on_window_changed<'a>(&self, view: &'a mut View, added: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn on_layout_changed<'a>(&self, view: &'a mut View, new_bounds: &'a Rect) {
        unsafe { std::mem::zeroed() }
    }
    fn on_focus<'a>(&self, view: &'a mut View) {
        unsafe { std::mem::zeroed() }
    }
    fn on_blur<'a>(&self, view: &'a mut View) {
        unsafe { std::mem::zeroed() }
    }
    fn on_theme_changed<'a>(&self, view: &'a mut View) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_view_delegate_t {
        let mut object: _cef_view_delegate_t = unsafe { std::mem::zeroed() };
        impl_cef_view_delegate_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_view_delegate_t {
    use super::*;
    pub fn init_methods<I: ImplViewDelegate>(object: &mut _cef_view_delegate_t) {
        object.get_preferred_size = Some(get_preferred_size::<I>);
        object.get_minimum_size = Some(get_minimum_size::<I>);
        object.get_maximum_size = Some(get_maximum_size::<I>);
        object.get_height_for_width = Some(get_height_for_width::<I>);
        object.on_parent_view_changed = Some(on_parent_view_changed::<I>);
        object.on_child_view_changed = Some(on_child_view_changed::<I>);
        object.on_window_changed = Some(on_window_changed::<I>);
        object.on_layout_changed = Some(on_layout_changed::<I>);
        object.on_focus = Some(on_focus::<I>);
        object.on_blur = Some(on_blur::<I>);
        object.on_theme_changed = Some(on_theme_changed::<I>);
    }
    extern "C" fn get_preferred_size<I: ImplViewDelegate>(
        self_: *mut _cef_view_delegate_t,
        view: *mut _cef_view_t,
    ) -> _cef_size_t {
        let (arg_self_, arg_view) = (self_, view);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_view = &mut View(unsafe { RefGuard::from_raw_add_ref(arg_view) });
        arg_self_.interface.get_preferred_size(arg_view).into()
    }
    extern "C" fn get_minimum_size<I: ImplViewDelegate>(
        self_: *mut _cef_view_delegate_t,
        view: *mut _cef_view_t,
    ) -> _cef_size_t {
        let (arg_self_, arg_view) = (self_, view);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_view = &mut View(unsafe { RefGuard::from_raw_add_ref(arg_view) });
        arg_self_.interface.get_minimum_size(arg_view).into()
    }
    extern "C" fn get_maximum_size<I: ImplViewDelegate>(
        self_: *mut _cef_view_delegate_t,
        view: *mut _cef_view_t,
    ) -> _cef_size_t {
        let (arg_self_, arg_view) = (self_, view);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_view = &mut View(unsafe { RefGuard::from_raw_add_ref(arg_view) });
        arg_self_.interface.get_maximum_size(arg_view).into()
    }
    extern "C" fn get_height_for_width<I: ImplViewDelegate>(
        self_: *mut _cef_view_delegate_t,
        view: *mut _cef_view_t,
        width: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_view, arg_width) = (self_, view, width);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_view = &mut View(unsafe { RefGuard::from_raw_add_ref(arg_view) });
        let arg_width = arg_width.as_raw();
        arg_self_
            .interface
            .get_height_for_width(arg_view, arg_width)
            .into()
    }
    extern "C" fn on_parent_view_changed<I: ImplViewDelegate>(
        self_: *mut _cef_view_delegate_t,
        view: *mut _cef_view_t,
        added: ::std::os::raw::c_int,
        parent: *mut _cef_view_t,
    ) {
        let (arg_self_, arg_view, arg_added, arg_parent) = (self_, view, added, parent);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_view = &mut View(unsafe { RefGuard::from_raw_add_ref(arg_view) });
        let arg_added = arg_added.as_raw();
        let arg_parent = &mut View(unsafe { RefGuard::from_raw_add_ref(arg_parent) });
        arg_self_
            .interface
            .on_parent_view_changed(arg_view, arg_added, arg_parent)
    }
    extern "C" fn on_child_view_changed<I: ImplViewDelegate>(
        self_: *mut _cef_view_delegate_t,
        view: *mut _cef_view_t,
        added: ::std::os::raw::c_int,
        child: *mut _cef_view_t,
    ) {
        let (arg_self_, arg_view, arg_added, arg_child) = (self_, view, added, child);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_view = &mut View(unsafe { RefGuard::from_raw_add_ref(arg_view) });
        let arg_added = arg_added.as_raw();
        let arg_child = &mut View(unsafe { RefGuard::from_raw_add_ref(arg_child) });
        arg_self_
            .interface
            .on_child_view_changed(arg_view, arg_added, arg_child)
    }
    extern "C" fn on_window_changed<I: ImplViewDelegate>(
        self_: *mut _cef_view_delegate_t,
        view: *mut _cef_view_t,
        added: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_view, arg_added) = (self_, view, added);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_view = &mut View(unsafe { RefGuard::from_raw_add_ref(arg_view) });
        let arg_added = arg_added.as_raw();
        arg_self_.interface.on_window_changed(arg_view, arg_added)
    }
    extern "C" fn on_layout_changed<I: ImplViewDelegate>(
        self_: *mut _cef_view_delegate_t,
        view: *mut _cef_view_t,
        new_bounds: *const _cef_rect_t,
    ) {
        let (arg_self_, arg_view, arg_new_bounds) = (self_, view, new_bounds);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_view = &mut View(unsafe { RefGuard::from_raw_add_ref(arg_view) });
        let arg_new_bounds = WrapParamRef::<Rect>::from(arg_new_bounds);
        let arg_new_bounds = arg_new_bounds.as_ref();
        arg_self_
            .interface
            .on_layout_changed(arg_view, arg_new_bounds)
    }
    extern "C" fn on_focus<I: ImplViewDelegate>(
        self_: *mut _cef_view_delegate_t,
        view: *mut _cef_view_t,
    ) {
        let (arg_self_, arg_view) = (self_, view);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_view = &mut View(unsafe { RefGuard::from_raw_add_ref(arg_view) });
        arg_self_.interface.on_focus(arg_view)
    }
    extern "C" fn on_blur<I: ImplViewDelegate>(
        self_: *mut _cef_view_delegate_t,
        view: *mut _cef_view_t,
    ) {
        let (arg_self_, arg_view) = (self_, view);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_view = &mut View(unsafe { RefGuard::from_raw_add_ref(arg_view) });
        arg_self_.interface.on_blur(arg_view)
    }
    extern "C" fn on_theme_changed<I: ImplViewDelegate>(
        self_: *mut _cef_view_delegate_t,
        view: *mut _cef_view_t,
    ) {
        let (arg_self_, arg_view) = (self_, view);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_view = &mut View(unsafe { RefGuard::from_raw_add_ref(arg_view) });
        arg_self_.interface.on_theme_changed(arg_view)
    }
}
#[doc = "See [_cef_view_delegate_t] for more documentation."]
#[derive(Clone)]
pub struct ViewDelegate(RefGuard<_cef_view_delegate_t>);
impl ImplViewDelegate for ViewDelegate {
    fn get_preferred_size<'a>(&self, view: &'a mut View) -> Size {
        unsafe {
            self.0
                .get_preferred_size
                .map(|f| {
                    let arg_view = view;
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view.as_raw();
                    let result = f(arg_self_, arg_view);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_minimum_size<'a>(&self, view: &'a mut View) -> Size {
        unsafe {
            self.0
                .get_minimum_size
                .map(|f| {
                    let arg_view = view;
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view.as_raw();
                    let result = f(arg_self_, arg_view);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_maximum_size<'a>(&self, view: &'a mut View) -> Size {
        unsafe {
            self.0
                .get_maximum_size
                .map(|f| {
                    let arg_view = view;
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view.as_raw();
                    let result = f(arg_self_, arg_view);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_height_for_width<'a>(
        &self,
        view: &'a mut View,
        width: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_height_for_width
                .map(|f| {
                    let (arg_view, arg_width) = (view, width);
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view.as_raw();
                    let arg_width = arg_width;
                    let result = f(arg_self_, arg_view, arg_width);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_parent_view_changed<'a>(
        &self,
        view: &'a mut View,
        added: ::std::os::raw::c_int,
        parent: &'a mut View,
    ) {
        unsafe {
            self.0
                .on_parent_view_changed
                .map(|f| {
                    let (arg_view, arg_added, arg_parent) = (view, added, parent);
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view.as_raw();
                    let arg_added = arg_added;
                    let arg_parent = arg_parent.as_raw();
                    let result = f(arg_self_, arg_view, arg_added, arg_parent);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_child_view_changed<'a>(
        &self,
        view: &'a mut View,
        added: ::std::os::raw::c_int,
        child: &'a mut View,
    ) {
        unsafe {
            self.0
                .on_child_view_changed
                .map(|f| {
                    let (arg_view, arg_added, arg_child) = (view, added, child);
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view.as_raw();
                    let arg_added = arg_added;
                    let arg_child = arg_child.as_raw();
                    let result = f(arg_self_, arg_view, arg_added, arg_child);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_window_changed<'a>(&self, view: &'a mut View, added: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .on_window_changed
                .map(|f| {
                    let (arg_view, arg_added) = (view, added);
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view.as_raw();
                    let arg_added = arg_added;
                    let result = f(arg_self_, arg_view, arg_added);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_layout_changed<'a>(&self, view: &'a mut View, new_bounds: &'a Rect) {
        unsafe {
            self.0
                .on_layout_changed
                .map(|f| {
                    let (arg_view, arg_new_bounds) = (view, new_bounds);
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view.as_raw();
                    let mut arg_new_bounds: _cef_rect_t = arg_new_bounds.clone().into();
                    let arg_new_bounds = &mut arg_new_bounds;
                    let result = f(arg_self_, arg_view, arg_new_bounds);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_focus<'a>(&self, view: &'a mut View) {
        unsafe {
            self.0
                .on_focus
                .map(|f| {
                    let arg_view = view;
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view.as_raw();
                    let result = f(arg_self_, arg_view);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_blur<'a>(&self, view: &'a mut View) {
        unsafe {
            self.0
                .on_blur
                .map(|f| {
                    let arg_view = view;
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view.as_raw();
                    let result = f(arg_self_, arg_view);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_theme_changed<'a>(&self, view: &'a mut View) {
        unsafe {
            self.0
                .on_theme_changed
                .map(|f| {
                    let arg_view = view;
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view.as_raw();
                    let result = f(arg_self_, arg_view);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_view_delegate_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ViewDelegate {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_view_delegate_t> for &ViewDelegate {
    fn as_raw(self) -> *mut _cef_view_delegate_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_view_delegate_t> for &mut ViewDelegate {
    fn as_raw(self) -> *mut _cef_view_delegate_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<ViewDelegate> for *mut _cef_view_delegate_t {
    fn as_wrapper(self) -> ViewDelegate {
        ViewDelegate(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_view_delegate_t> for ViewDelegate {
    fn into(self) -> *mut _cef_view_delegate_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for ViewDelegate {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplView: Sized {
    fn as_browser_view<'a>(&self) -> BrowserView {
        unsafe { std::mem::zeroed() }
    }
    fn as_button<'a>(&self) -> Button {
        unsafe { std::mem::zeroed() }
    }
    fn as_panel<'a>(&self) -> Panel {
        unsafe { std::mem::zeroed() }
    }
    fn as_scroll_view<'a>(&self) -> ScrollView {
        unsafe { std::mem::zeroed() }
    }
    fn as_textfield<'a>(&self) -> Textfield {
        unsafe { std::mem::zeroed() }
    }
    fn get_type_string<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn to_string<'a>(&self, include_children: ::std::os::raw::c_int) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_attached<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_same<'a>(&self, that: &'a mut View) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_delegate<'a>(&self) -> ViewDelegate {
        unsafe { std::mem::zeroed() }
    }
    fn get_window<'a>(&self) -> Window {
        unsafe { std::mem::zeroed() }
    }
    fn get_id<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_id<'a>(&self, id: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn get_group_id<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_group_id<'a>(&self, group_id: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn get_parent_view<'a>(&self) -> View {
        unsafe { std::mem::zeroed() }
    }
    fn get_view_for_id<'a>(&self, id: ::std::os::raw::c_int) -> View {
        unsafe { std::mem::zeroed() }
    }
    fn set_bounds<'a>(&self, bounds: &'a Rect) {
        unsafe { std::mem::zeroed() }
    }
    fn get_bounds<'a>(&self) -> Rect {
        unsafe { std::mem::zeroed() }
    }
    fn get_bounds_in_screen<'a>(&self) -> Rect {
        unsafe { std::mem::zeroed() }
    }
    fn set_size<'a>(&self, size: &'a Size) {
        unsafe { std::mem::zeroed() }
    }
    fn get_size<'a>(&self) -> Size {
        unsafe { std::mem::zeroed() }
    }
    fn set_position<'a>(&self, position: &'a Point) {
        unsafe { std::mem::zeroed() }
    }
    fn get_position<'a>(&self) -> Point {
        unsafe { std::mem::zeroed() }
    }
    fn set_insets<'a>(&self, insets: &'a Insets) {
        unsafe { std::mem::zeroed() }
    }
    fn get_insets<'a>(&self) -> Insets {
        unsafe { std::mem::zeroed() }
    }
    fn get_preferred_size<'a>(&self) -> Size {
        unsafe { std::mem::zeroed() }
    }
    fn size_to_preferred_size<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn get_minimum_size<'a>(&self) -> Size {
        unsafe { std::mem::zeroed() }
    }
    fn get_maximum_size<'a>(&self) -> Size {
        unsafe { std::mem::zeroed() }
    }
    fn get_height_for_width<'a>(&self, width: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn invalidate_layout<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn set_visible<'a>(&self, visible: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn is_visible<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_drawn<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_enabled<'a>(&self, enabled: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn is_enabled<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_focusable<'a>(&self, focusable: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn is_focusable<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_accessibility_focusable<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn has_focus<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn request_focus<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn set_background_color<'a>(&self, color: u32) {
        unsafe { std::mem::zeroed() }
    }
    fn get_background_color<'a>(&self) -> cef_color_t {
        unsafe { std::mem::zeroed() }
    }
    fn get_theme_color<'a>(&self, color_id: ::std::os::raw::c_int) -> cef_color_t {
        unsafe { std::mem::zeroed() }
    }
    fn convert_point_to_screen<'a>(&self, point: &'a mut Point) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn convert_point_from_screen<'a>(&self, point: &'a mut Point) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn convert_point_to_window<'a>(&self, point: &'a mut Point) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn convert_point_from_window<'a>(&self, point: &'a mut Point) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn convert_point_to_view<'a>(
        &self,
        view: &'a mut View,
        point: &'a mut Point,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn convert_point_from_view<'a>(
        &self,
        view: &'a mut View,
        point: &'a mut Point,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_view_t {
        let mut object: _cef_view_t = unsafe { std::mem::zeroed() };
        impl_cef_view_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_view_t {
    use super::*;
    pub fn init_methods<I: ImplView>(object: &mut _cef_view_t) {
        object.as_browser_view = Some(as_browser_view::<I>);
        object.as_button = Some(as_button::<I>);
        object.as_panel = Some(as_panel::<I>);
        object.as_scroll_view = Some(as_scroll_view::<I>);
        object.as_textfield = Some(as_textfield::<I>);
        object.get_type_string = Some(get_type_string::<I>);
        object.to_string = Some(to_string::<I>);
        object.is_valid = Some(is_valid::<I>);
        object.is_attached = Some(is_attached::<I>);
        object.is_same = Some(is_same::<I>);
        object.get_delegate = Some(get_delegate::<I>);
        object.get_window = Some(get_window::<I>);
        object.get_id = Some(get_id::<I>);
        object.set_id = Some(set_id::<I>);
        object.get_group_id = Some(get_group_id::<I>);
        object.set_group_id = Some(set_group_id::<I>);
        object.get_parent_view = Some(get_parent_view::<I>);
        object.get_view_for_id = Some(get_view_for_id::<I>);
        object.set_bounds = Some(set_bounds::<I>);
        object.get_bounds = Some(get_bounds::<I>);
        object.get_bounds_in_screen = Some(get_bounds_in_screen::<I>);
        object.set_size = Some(set_size::<I>);
        object.get_size = Some(get_size::<I>);
        object.set_position = Some(set_position::<I>);
        object.get_position = Some(get_position::<I>);
        object.set_insets = Some(set_insets::<I>);
        object.get_insets = Some(get_insets::<I>);
        object.get_preferred_size = Some(get_preferred_size::<I>);
        object.size_to_preferred_size = Some(size_to_preferred_size::<I>);
        object.get_minimum_size = Some(get_minimum_size::<I>);
        object.get_maximum_size = Some(get_maximum_size::<I>);
        object.get_height_for_width = Some(get_height_for_width::<I>);
        object.invalidate_layout = Some(invalidate_layout::<I>);
        object.set_visible = Some(set_visible::<I>);
        object.is_visible = Some(is_visible::<I>);
        object.is_drawn = Some(is_drawn::<I>);
        object.set_enabled = Some(set_enabled::<I>);
        object.is_enabled = Some(is_enabled::<I>);
        object.set_focusable = Some(set_focusable::<I>);
        object.is_focusable = Some(is_focusable::<I>);
        object.is_accessibility_focusable = Some(is_accessibility_focusable::<I>);
        object.has_focus = Some(has_focus::<I>);
        object.request_focus = Some(request_focus::<I>);
        object.set_background_color = Some(set_background_color::<I>);
        object.get_background_color = Some(get_background_color::<I>);
        object.get_theme_color = Some(get_theme_color::<I>);
        object.convert_point_to_screen = Some(convert_point_to_screen::<I>);
        object.convert_point_from_screen = Some(convert_point_from_screen::<I>);
        object.convert_point_to_window = Some(convert_point_to_window::<I>);
        object.convert_point_from_window = Some(convert_point_from_window::<I>);
        object.convert_point_to_view = Some(convert_point_to_view::<I>);
        object.convert_point_from_view = Some(convert_point_from_view::<I>);
    }
    extern "C" fn as_browser_view<I: ImplView>(
        self_: *mut _cef_view_t,
    ) -> *mut _cef_browser_view_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.as_browser_view().into()
    }
    extern "C" fn as_button<I: ImplView>(self_: *mut _cef_view_t) -> *mut _cef_button_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.as_button().into()
    }
    extern "C" fn as_panel<I: ImplView>(self_: *mut _cef_view_t) -> *mut _cef_panel_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.as_panel().into()
    }
    extern "C" fn as_scroll_view<I: ImplView>(self_: *mut _cef_view_t) -> *mut _cef_scroll_view_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.as_scroll_view().into()
    }
    extern "C" fn as_textfield<I: ImplView>(self_: *mut _cef_view_t) -> *mut _cef_textfield_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.as_textfield().into()
    }
    extern "C" fn get_type_string<I: ImplView>(
        self_: *mut _cef_view_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_type_string().into()
    }
    extern "C" fn to_string<I: ImplView>(
        self_: *mut _cef_view_t,
        include_children: ::std::os::raw::c_int,
    ) -> *mut _cef_string_utf16_t {
        let (arg_self_, arg_include_children) = (self_, include_children);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_include_children = arg_include_children.as_raw();
        arg_self_.interface.to_string(arg_include_children).into()
    }
    extern "C" fn is_valid<I: ImplView>(self_: *mut _cef_view_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_valid().into()
    }
    extern "C" fn is_attached<I: ImplView>(self_: *mut _cef_view_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_attached().into()
    }
    extern "C" fn is_same<I: ImplView>(
        self_: *mut _cef_view_t,
        that: *mut _cef_view_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_that) = (self_, that);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_that = &mut View(unsafe { RefGuard::from_raw_add_ref(arg_that) });
        arg_self_.interface.is_same(arg_that).into()
    }
    extern "C" fn get_delegate<I: ImplView>(self_: *mut _cef_view_t) -> *mut _cef_view_delegate_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_delegate().into()
    }
    extern "C" fn get_window<I: ImplView>(self_: *mut _cef_view_t) -> *mut _cef_window_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_window().into()
    }
    extern "C" fn get_id<I: ImplView>(self_: *mut _cef_view_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_id().into()
    }
    extern "C" fn set_id<I: ImplView>(self_: *mut _cef_view_t, id: ::std::os::raw::c_int) {
        let (arg_self_, arg_id) = (self_, id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_id = arg_id.as_raw();
        arg_self_.interface.set_id(arg_id)
    }
    extern "C" fn get_group_id<I: ImplView>(self_: *mut _cef_view_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_group_id().into()
    }
    extern "C" fn set_group_id<I: ImplView>(
        self_: *mut _cef_view_t,
        group_id: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_group_id) = (self_, group_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_group_id = arg_group_id.as_raw();
        arg_self_.interface.set_group_id(arg_group_id)
    }
    extern "C" fn get_parent_view<I: ImplView>(self_: *mut _cef_view_t) -> *mut _cef_view_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_parent_view().into()
    }
    extern "C" fn get_view_for_id<I: ImplView>(
        self_: *mut _cef_view_t,
        id: ::std::os::raw::c_int,
    ) -> *mut _cef_view_t {
        let (arg_self_, arg_id) = (self_, id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_id = arg_id.as_raw();
        arg_self_.interface.get_view_for_id(arg_id).into()
    }
    extern "C" fn set_bounds<I: ImplView>(self_: *mut _cef_view_t, bounds: *const _cef_rect_t) {
        let (arg_self_, arg_bounds) = (self_, bounds);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_bounds = WrapParamRef::<Rect>::from(arg_bounds);
        let arg_bounds = arg_bounds.as_ref();
        arg_self_.interface.set_bounds(arg_bounds)
    }
    extern "C" fn get_bounds<I: ImplView>(self_: *mut _cef_view_t) -> _cef_rect_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_bounds().into()
    }
    extern "C" fn get_bounds_in_screen<I: ImplView>(self_: *mut _cef_view_t) -> _cef_rect_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_bounds_in_screen().into()
    }
    extern "C" fn set_size<I: ImplView>(self_: *mut _cef_view_t, size: *const _cef_size_t) {
        let (arg_self_, arg_size) = (self_, size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_size = WrapParamRef::<Size>::from(arg_size);
        let arg_size = arg_size.as_ref();
        arg_self_.interface.set_size(arg_size)
    }
    extern "C" fn get_size<I: ImplView>(self_: *mut _cef_view_t) -> _cef_size_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_size().into()
    }
    extern "C" fn set_position<I: ImplView>(
        self_: *mut _cef_view_t,
        position: *const _cef_point_t,
    ) {
        let (arg_self_, arg_position) = (self_, position);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_position = WrapParamRef::<Point>::from(arg_position);
        let arg_position = arg_position.as_ref();
        arg_self_.interface.set_position(arg_position)
    }
    extern "C" fn get_position<I: ImplView>(self_: *mut _cef_view_t) -> _cef_point_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_position().into()
    }
    extern "C" fn set_insets<I: ImplView>(self_: *mut _cef_view_t, insets: *const _cef_insets_t) {
        let (arg_self_, arg_insets) = (self_, insets);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_insets = WrapParamRef::<Insets>::from(arg_insets);
        let arg_insets = arg_insets.as_ref();
        arg_self_.interface.set_insets(arg_insets)
    }
    extern "C" fn get_insets<I: ImplView>(self_: *mut _cef_view_t) -> _cef_insets_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_insets().into()
    }
    extern "C" fn get_preferred_size<I: ImplView>(self_: *mut _cef_view_t) -> _cef_size_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_preferred_size().into()
    }
    extern "C" fn size_to_preferred_size<I: ImplView>(self_: *mut _cef_view_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.size_to_preferred_size()
    }
    extern "C" fn get_minimum_size<I: ImplView>(self_: *mut _cef_view_t) -> _cef_size_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_minimum_size().into()
    }
    extern "C" fn get_maximum_size<I: ImplView>(self_: *mut _cef_view_t) -> _cef_size_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_maximum_size().into()
    }
    extern "C" fn get_height_for_width<I: ImplView>(
        self_: *mut _cef_view_t,
        width: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_width) = (self_, width);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_width = arg_width.as_raw();
        arg_self_.interface.get_height_for_width(arg_width).into()
    }
    extern "C" fn invalidate_layout<I: ImplView>(self_: *mut _cef_view_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.invalidate_layout()
    }
    extern "C" fn set_visible<I: ImplView>(
        self_: *mut _cef_view_t,
        visible: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_visible) = (self_, visible);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_visible = arg_visible.as_raw();
        arg_self_.interface.set_visible(arg_visible)
    }
    extern "C" fn is_visible<I: ImplView>(self_: *mut _cef_view_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_visible().into()
    }
    extern "C" fn is_drawn<I: ImplView>(self_: *mut _cef_view_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_drawn().into()
    }
    extern "C" fn set_enabled<I: ImplView>(
        self_: *mut _cef_view_t,
        enabled: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_enabled) = (self_, enabled);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_enabled = arg_enabled.as_raw();
        arg_self_.interface.set_enabled(arg_enabled)
    }
    extern "C" fn is_enabled<I: ImplView>(self_: *mut _cef_view_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_enabled().into()
    }
    extern "C" fn set_focusable<I: ImplView>(
        self_: *mut _cef_view_t,
        focusable: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_focusable) = (self_, focusable);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_focusable = arg_focusable.as_raw();
        arg_self_.interface.set_focusable(arg_focusable)
    }
    extern "C" fn is_focusable<I: ImplView>(self_: *mut _cef_view_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_focusable().into()
    }
    extern "C" fn is_accessibility_focusable<I: ImplView>(
        self_: *mut _cef_view_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_accessibility_focusable().into()
    }
    extern "C" fn has_focus<I: ImplView>(self_: *mut _cef_view_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.has_focus().into()
    }
    extern "C" fn request_focus<I: ImplView>(self_: *mut _cef_view_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.request_focus()
    }
    extern "C" fn set_background_color<I: ImplView>(self_: *mut _cef_view_t, color: u32) {
        let (arg_self_, arg_color) = (self_, color);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_color = arg_color.as_raw();
        arg_self_.interface.set_background_color(arg_color)
    }
    extern "C" fn get_background_color<I: ImplView>(self_: *mut _cef_view_t) -> u32 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_background_color().into()
    }
    extern "C" fn get_theme_color<I: ImplView>(
        self_: *mut _cef_view_t,
        color_id: ::std::os::raw::c_int,
    ) -> u32 {
        let (arg_self_, arg_color_id) = (self_, color_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_color_id = arg_color_id.as_raw();
        arg_self_.interface.get_theme_color(arg_color_id).into()
    }
    extern "C" fn convert_point_to_screen<I: ImplView>(
        self_: *mut _cef_view_t,
        point: *mut _cef_point_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_point) = (self_, point);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_point = WrapParamRef::<Point>::from(arg_point);
        let arg_point = arg_point.as_mut();
        arg_self_
            .interface
            .convert_point_to_screen(arg_point)
            .into()
    }
    extern "C" fn convert_point_from_screen<I: ImplView>(
        self_: *mut _cef_view_t,
        point: *mut _cef_point_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_point) = (self_, point);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_point = WrapParamRef::<Point>::from(arg_point);
        let arg_point = arg_point.as_mut();
        arg_self_
            .interface
            .convert_point_from_screen(arg_point)
            .into()
    }
    extern "C" fn convert_point_to_window<I: ImplView>(
        self_: *mut _cef_view_t,
        point: *mut _cef_point_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_point) = (self_, point);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_point = WrapParamRef::<Point>::from(arg_point);
        let arg_point = arg_point.as_mut();
        arg_self_
            .interface
            .convert_point_to_window(arg_point)
            .into()
    }
    extern "C" fn convert_point_from_window<I: ImplView>(
        self_: *mut _cef_view_t,
        point: *mut _cef_point_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_point) = (self_, point);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_point = WrapParamRef::<Point>::from(arg_point);
        let arg_point = arg_point.as_mut();
        arg_self_
            .interface
            .convert_point_from_window(arg_point)
            .into()
    }
    extern "C" fn convert_point_to_view<I: ImplView>(
        self_: *mut _cef_view_t,
        view: *mut _cef_view_t,
        point: *mut _cef_point_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_view, arg_point) = (self_, view, point);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_view = &mut View(unsafe { RefGuard::from_raw_add_ref(arg_view) });
        let mut arg_point = WrapParamRef::<Point>::from(arg_point);
        let arg_point = arg_point.as_mut();
        arg_self_
            .interface
            .convert_point_to_view(arg_view, arg_point)
            .into()
    }
    extern "C" fn convert_point_from_view<I: ImplView>(
        self_: *mut _cef_view_t,
        view: *mut _cef_view_t,
        point: *mut _cef_point_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_view, arg_point) = (self_, view, point);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_view = &mut View(unsafe { RefGuard::from_raw_add_ref(arg_view) });
        let mut arg_point = WrapParamRef::<Point>::from(arg_point);
        let arg_point = arg_point.as_mut();
        arg_self_
            .interface
            .convert_point_from_view(arg_view, arg_point)
            .into()
    }
}
#[doc = "See [_cef_view_t] for more documentation."]
#[derive(Clone)]
pub struct View(RefGuard<_cef_view_t>);
impl ImplView for View {
    fn as_browser_view<'a>(&self) -> BrowserView {
        unsafe {
            self.0
                .as_browser_view
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn as_button<'a>(&self) -> Button {
        unsafe {
            self.0
                .as_button
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn as_panel<'a>(&self) -> Panel {
        unsafe {
            self.0
                .as_panel
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn as_scroll_view<'a>(&self) -> ScrollView {
        unsafe {
            self.0
                .as_scroll_view
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn as_textfield<'a>(&self) -> Textfield {
        unsafe {
            self.0
                .as_textfield
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_type_string<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_type_string
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn to_string<'a>(&self, include_children: ::std::os::raw::c_int) -> CefStringUtf16 {
        unsafe {
            self.0
                .to_string
                .map(|f| {
                    let arg_include_children = include_children;
                    let arg_self_ = self.as_raw();
                    let arg_include_children = arg_include_children;
                    let result = f(arg_self_, arg_include_children);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_attached<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_attached
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_same<'a>(&self, that: &'a mut View) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_same
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.as_raw();
                    let arg_that = arg_that.as_raw();
                    let result = f(arg_self_, arg_that);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_delegate<'a>(&self) -> ViewDelegate {
        unsafe {
            self.0
                .get_delegate
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_window<'a>(&self) -> Window {
        unsafe {
            self.0
                .get_window
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_id<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_id
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_id<'a>(&self, id: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_id
                .map(|f| {
                    let arg_id = id;
                    let arg_self_ = self.as_raw();
                    let arg_id = arg_id;
                    let result = f(arg_self_, arg_id);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_group_id<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_group_id
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_group_id<'a>(&self, group_id: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_group_id
                .map(|f| {
                    let arg_group_id = group_id;
                    let arg_self_ = self.as_raw();
                    let arg_group_id = arg_group_id;
                    let result = f(arg_self_, arg_group_id);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_parent_view<'a>(&self) -> View {
        unsafe {
            self.0
                .get_parent_view
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_view_for_id<'a>(&self, id: ::std::os::raw::c_int) -> View {
        unsafe {
            self.0
                .get_view_for_id
                .map(|f| {
                    let arg_id = id;
                    let arg_self_ = self.as_raw();
                    let arg_id = arg_id;
                    let result = f(arg_self_, arg_id);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_bounds<'a>(&self, bounds: &'a Rect) {
        unsafe {
            self.0
                .set_bounds
                .map(|f| {
                    let arg_bounds = bounds;
                    let arg_self_ = self.as_raw();
                    let mut arg_bounds: _cef_rect_t = arg_bounds.clone().into();
                    let arg_bounds = &mut arg_bounds;
                    let result = f(arg_self_, arg_bounds);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_bounds<'a>(&self) -> Rect {
        unsafe {
            self.0
                .get_bounds
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_bounds_in_screen<'a>(&self) -> Rect {
        unsafe {
            self.0
                .get_bounds_in_screen
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_size<'a>(&self, size: &'a Size) {
        unsafe {
            self.0
                .set_size
                .map(|f| {
                    let arg_size = size;
                    let arg_self_ = self.as_raw();
                    let mut arg_size: _cef_size_t = arg_size.clone().into();
                    let arg_size = &mut arg_size;
                    let result = f(arg_self_, arg_size);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_size<'a>(&self) -> Size {
        unsafe {
            self.0
                .get_size
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_position<'a>(&self, position: &'a Point) {
        unsafe {
            self.0
                .set_position
                .map(|f| {
                    let arg_position = position;
                    let arg_self_ = self.as_raw();
                    let mut arg_position: _cef_point_t = arg_position.clone().into();
                    let arg_position = &mut arg_position;
                    let result = f(arg_self_, arg_position);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_position<'a>(&self) -> Point {
        unsafe {
            self.0
                .get_position
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_insets<'a>(&self, insets: &'a Insets) {
        unsafe {
            self.0
                .set_insets
                .map(|f| {
                    let arg_insets = insets;
                    let arg_self_ = self.as_raw();
                    let mut arg_insets: _cef_insets_t = arg_insets.clone().into();
                    let arg_insets = &mut arg_insets;
                    let result = f(arg_self_, arg_insets);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_insets<'a>(&self) -> Insets {
        unsafe {
            self.0
                .get_insets
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_preferred_size<'a>(&self) -> Size {
        unsafe {
            self.0
                .get_preferred_size
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn size_to_preferred_size<'a>(&self) {
        unsafe {
            self.0
                .size_to_preferred_size
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_minimum_size<'a>(&self) -> Size {
        unsafe {
            self.0
                .get_minimum_size
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_maximum_size<'a>(&self) -> Size {
        unsafe {
            self.0
                .get_maximum_size
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_height_for_width<'a>(&self, width: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_height_for_width
                .map(|f| {
                    let arg_width = width;
                    let arg_self_ = self.as_raw();
                    let arg_width = arg_width;
                    let result = f(arg_self_, arg_width);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn invalidate_layout<'a>(&self) {
        unsafe {
            self.0
                .invalidate_layout
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_visible<'a>(&self, visible: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_visible
                .map(|f| {
                    let arg_visible = visible;
                    let arg_self_ = self.as_raw();
                    let arg_visible = arg_visible;
                    let result = f(arg_self_, arg_visible);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_visible<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_visible
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_drawn<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_drawn
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_enabled<'a>(&self, enabled: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_enabled
                .map(|f| {
                    let arg_enabled = enabled;
                    let arg_self_ = self.as_raw();
                    let arg_enabled = arg_enabled;
                    let result = f(arg_self_, arg_enabled);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_enabled<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_enabled
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_focusable<'a>(&self, focusable: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_focusable
                .map(|f| {
                    let arg_focusable = focusable;
                    let arg_self_ = self.as_raw();
                    let arg_focusable = arg_focusable;
                    let result = f(arg_self_, arg_focusable);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_focusable<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_focusable
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_accessibility_focusable<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_accessibility_focusable
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn has_focus<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_focus
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn request_focus<'a>(&self) {
        unsafe {
            self.0
                .request_focus
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_background_color<'a>(&self, color: u32) {
        unsafe {
            self.0
                .set_background_color
                .map(|f| {
                    let arg_color = color;
                    let arg_self_ = self.as_raw();
                    let arg_color = arg_color;
                    let result = f(arg_self_, arg_color);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_background_color<'a>(&self) -> cef_color_t {
        unsafe {
            self.0
                .get_background_color
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_theme_color<'a>(&self, color_id: ::std::os::raw::c_int) -> cef_color_t {
        unsafe {
            self.0
                .get_theme_color
                .map(|f| {
                    let arg_color_id = color_id;
                    let arg_self_ = self.as_raw();
                    let arg_color_id = arg_color_id;
                    let result = f(arg_self_, arg_color_id);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn convert_point_to_screen<'a>(&self, point: &'a mut Point) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .convert_point_to_screen
                .map(|f| {
                    let arg_point = point;
                    let arg_self_ = self.as_raw();
                    let mut arg_point: _cef_point_t = arg_point.clone().into();
                    let arg_point = &mut arg_point;
                    let result = f(arg_self_, arg_point);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn convert_point_from_screen<'a>(&self, point: &'a mut Point) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .convert_point_from_screen
                .map(|f| {
                    let arg_point = point;
                    let arg_self_ = self.as_raw();
                    let mut arg_point: _cef_point_t = arg_point.clone().into();
                    let arg_point = &mut arg_point;
                    let result = f(arg_self_, arg_point);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn convert_point_to_window<'a>(&self, point: &'a mut Point) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .convert_point_to_window
                .map(|f| {
                    let arg_point = point;
                    let arg_self_ = self.as_raw();
                    let mut arg_point: _cef_point_t = arg_point.clone().into();
                    let arg_point = &mut arg_point;
                    let result = f(arg_self_, arg_point);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn convert_point_from_window<'a>(&self, point: &'a mut Point) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .convert_point_from_window
                .map(|f| {
                    let arg_point = point;
                    let arg_self_ = self.as_raw();
                    let mut arg_point: _cef_point_t = arg_point.clone().into();
                    let arg_point = &mut arg_point;
                    let result = f(arg_self_, arg_point);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn convert_point_to_view<'a>(
        &self,
        view: &'a mut View,
        point: &'a mut Point,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .convert_point_to_view
                .map(|f| {
                    let (arg_view, arg_point) = (view, point);
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view.as_raw();
                    let mut arg_point: _cef_point_t = arg_point.clone().into();
                    let arg_point = &mut arg_point;
                    let result = f(arg_self_, arg_view, arg_point);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn convert_point_from_view<'a>(
        &self,
        view: &'a mut View,
        point: &'a mut Point,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .convert_point_from_view
                .map(|f| {
                    let (arg_view, arg_point) = (view, point);
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view.as_raw();
                    let mut arg_point: _cef_point_t = arg_point.clone().into();
                    let arg_point = &mut arg_point;
                    let result = f(arg_self_, arg_view, arg_point);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_view_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for View {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_view_t> for &View {
    fn as_raw(self) -> *mut _cef_view_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_view_t> for &mut View {
    fn as_raw(self) -> *mut _cef_view_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<View> for *mut _cef_view_t {
    fn as_wrapper(self) -> View {
        View(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_view_t> for View {
    fn into(self) -> *mut _cef_view_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for View {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplButton: ImplView {
    fn as_label_button<'a>(&self) -> LabelButton {
        unsafe { std::mem::zeroed() }
    }
    fn set_state<'a>(&self, state: ButtonState) {
        unsafe { std::mem::zeroed() }
    }
    fn get_state<'a>(&self) -> ButtonState {
        unsafe { std::mem::zeroed() }
    }
    fn set_ink_drop_enabled<'a>(&self, enabled: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn set_tooltip_text<'a>(&self, tooltip_text: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn set_accessible_name<'a>(&self, name: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_button_t {
        let mut object: _cef_button_t = unsafe { std::mem::zeroed() };
        impl_cef_view_t::init_methods::<Self>(&mut object.base);
        impl_cef_button_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_button_t {
    use super::*;
    pub fn init_methods<I: ImplButton>(object: &mut _cef_button_t) {
        object.as_label_button = Some(as_label_button::<I>);
        object.set_state = Some(set_state::<I>);
        object.get_state = Some(get_state::<I>);
        object.set_ink_drop_enabled = Some(set_ink_drop_enabled::<I>);
        object.set_tooltip_text = Some(set_tooltip_text::<I>);
        object.set_accessible_name = Some(set_accessible_name::<I>);
    }
    extern "C" fn as_label_button<I: ImplButton>(
        self_: *mut _cef_button_t,
    ) -> *mut _cef_label_button_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.as_label_button().into()
    }
    extern "C" fn set_state<I: ImplButton>(self_: *mut _cef_button_t, state: cef_button_state_t) {
        let (arg_self_, arg_state) = (self_, state);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_state = arg_state.as_raw();
        arg_self_.interface.set_state(arg_state)
    }
    extern "C" fn get_state<I: ImplButton>(self_: *mut _cef_button_t) -> cef_button_state_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_state().into()
    }
    extern "C" fn set_ink_drop_enabled<I: ImplButton>(
        self_: *mut _cef_button_t,
        enabled: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_enabled) = (self_, enabled);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_enabled = arg_enabled.as_raw();
        arg_self_.interface.set_ink_drop_enabled(arg_enabled)
    }
    extern "C" fn set_tooltip_text<I: ImplButton>(
        self_: *mut _cef_button_t,
        tooltip_text: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_tooltip_text) = (self_, tooltip_text);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_tooltip_text = WrapParamRef::<CefStringUtf16>::from(arg_tooltip_text);
        let arg_tooltip_text = arg_tooltip_text.as_ref();
        arg_self_.interface.set_tooltip_text(arg_tooltip_text)
    }
    extern "C" fn set_accessible_name<I: ImplButton>(
        self_: *mut _cef_button_t,
        name: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_name) = (self_, name);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = WrapParamRef::<CefStringUtf16>::from(arg_name);
        let arg_name = arg_name.as_ref();
        arg_self_.interface.set_accessible_name(arg_name)
    }
}
#[doc = "See [_cef_button_t] for more documentation."]
#[derive(Clone)]
pub struct Button(RefGuard<_cef_button_t>);
impl ImplView for Button {
    fn as_browser_view<'a>(&self) -> BrowserView {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_browser_view()
    }
    fn as_button<'a>(&self) -> Button {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).as_button()
    }
    fn as_panel<'a>(&self) -> Panel {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).as_panel()
    }
    fn as_scroll_view<'a>(&self) -> ScrollView {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_scroll_view()
    }
    fn as_textfield<'a>(&self) -> Textfield {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_textfield()
    }
    fn get_type_string<'a>(&self) -> CefStringUtf16 {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_type_string()
    }
    fn to_string<'a>(&self, include_children: ::std::os::raw::c_int) -> CefStringUtf16 {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .to_string(include_children)
    }
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).is_valid()
    }
    fn is_attached<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_attached()
    }
    fn is_same<'a>(&self, that: &'a mut View) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_same(that)
    }
    fn get_delegate<'a>(&self) -> ViewDelegate {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_delegate()
    }
    fn get_window<'a>(&self) -> Window {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_window()
    }
    fn get_id<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).get_id()
    }
    fn set_id<'a>(&self, id: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).set_id(id)
    }
    fn get_group_id<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_group_id()
    }
    fn set_group_id<'a>(&self, group_id: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_group_id(group_id)
    }
    fn get_parent_view<'a>(&self) -> View {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_parent_view()
    }
    fn get_view_for_id<'a>(&self, id: ::std::os::raw::c_int) -> View {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_view_for_id(id)
    }
    fn set_bounds<'a>(&self, bounds: &'a Rect) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_bounds(bounds)
    }
    fn get_bounds<'a>(&self) -> Rect {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_bounds()
    }
    fn get_bounds_in_screen<'a>(&self) -> Rect {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_bounds_in_screen()
    }
    fn set_size<'a>(&self, size: &'a Size) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_size(size)
    }
    fn get_size<'a>(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).get_size()
    }
    fn set_position<'a>(&self, position: &'a Point) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_position(position)
    }
    fn get_position<'a>(&self) -> Point {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_position()
    }
    fn set_insets<'a>(&self, insets: &'a Insets) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_insets(insets)
    }
    fn get_insets<'a>(&self) -> Insets {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_insets()
    }
    fn get_preferred_size<'a>(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_preferred_size()
    }
    fn size_to_preferred_size<'a>(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .size_to_preferred_size()
    }
    fn get_minimum_size<'a>(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_minimum_size()
    }
    fn get_maximum_size<'a>(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_maximum_size()
    }
    fn get_height_for_width<'a>(&self, width: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_height_for_width(width)
    }
    fn invalidate_layout<'a>(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .invalidate_layout()
    }
    fn set_visible<'a>(&self, visible: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_visible(visible)
    }
    fn is_visible<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_visible()
    }
    fn is_drawn<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).is_drawn()
    }
    fn set_enabled<'a>(&self, enabled: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_enabled(enabled)
    }
    fn is_enabled<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_enabled()
    }
    fn set_focusable<'a>(&self, focusable: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_focusable(focusable)
    }
    fn is_focusable<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_focusable()
    }
    fn is_accessibility_focusable<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_accessibility_focusable()
    }
    fn has_focus<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).has_focus()
    }
    fn request_focus<'a>(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .request_focus()
    }
    fn set_background_color<'a>(&self, color: u32) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_background_color(color)
    }
    fn get_background_color<'a>(&self) -> cef_color_t {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_background_color()
    }
    fn get_theme_color<'a>(&self, color_id: ::std::os::raw::c_int) -> cef_color_t {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_theme_color(color_id)
    }
    fn convert_point_to_screen<'a>(&self, point: &'a mut Point) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_screen(point)
    }
    fn convert_point_from_screen<'a>(&self, point: &'a mut Point) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_screen(point)
    }
    fn convert_point_to_window<'a>(&self, point: &'a mut Point) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_window(point)
    }
    fn convert_point_from_window<'a>(&self, point: &'a mut Point) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_window(point)
    }
    fn convert_point_to_view<'a>(
        &self,
        view: &'a mut View,
        point: &'a mut Point,
    ) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_view(view, point)
    }
    fn convert_point_from_view<'a>(
        &self,
        view: &'a mut View,
        point: &'a mut Point,
    ) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_view(view, point)
    }
}
impl ImplButton for Button {
    fn as_label_button<'a>(&self) -> LabelButton {
        unsafe {
            self.0
                .as_label_button
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_state<'a>(&self, state: ButtonState) {
        unsafe {
            self.0
                .set_state
                .map(|f| {
                    let arg_state = state;
                    let arg_self_ = self.as_raw();
                    let arg_state = arg_state.as_raw();
                    let result = f(arg_self_, arg_state);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_state<'a>(&self) -> ButtonState {
        unsafe {
            self.0
                .get_state
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_ink_drop_enabled<'a>(&self, enabled: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_ink_drop_enabled
                .map(|f| {
                    let arg_enabled = enabled;
                    let arg_self_ = self.as_raw();
                    let arg_enabled = arg_enabled;
                    let result = f(arg_self_, arg_enabled);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_tooltip_text<'a>(&self, tooltip_text: &'a CefStringUtf16) {
        unsafe {
            self.0
                .set_tooltip_text
                .map(|f| {
                    let arg_tooltip_text = tooltip_text;
                    let arg_self_ = self.as_raw();
                    let arg_tooltip_text = arg_tooltip_text.as_raw();
                    let result = f(arg_self_, arg_tooltip_text);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_accessible_name<'a>(&self, name: &'a CefStringUtf16) {
        unsafe {
            self.0
                .set_accessible_name
                .map(|f| {
                    let arg_name = name;
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.as_raw();
                    let result = f(arg_self_, arg_name);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_button_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Button {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_button_t> for &Button {
    fn as_raw(self) -> *mut _cef_button_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_button_t> for &mut Button {
    fn as_raw(self) -> *mut _cef_button_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<Button> for *mut _cef_button_t {
    fn as_wrapper(self) -> Button {
        Button(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_button_t> for Button {
    fn into(self) -> *mut _cef_button_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for Button {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplButtonDelegate: ImplViewDelegate {
    fn on_button_pressed<'a>(&self, button: &'a mut Button) {
        unsafe { std::mem::zeroed() }
    }
    fn on_button_state_changed<'a>(&self, button: &'a mut Button) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_button_delegate_t {
        let mut object: _cef_button_delegate_t = unsafe { std::mem::zeroed() };
        impl_cef_view_delegate_t::init_methods::<Self>(&mut object.base);
        impl_cef_button_delegate_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_button_delegate_t {
    use super::*;
    pub fn init_methods<I: ImplButtonDelegate>(object: &mut _cef_button_delegate_t) {
        object.on_button_pressed = Some(on_button_pressed::<I>);
        object.on_button_state_changed = Some(on_button_state_changed::<I>);
    }
    extern "C" fn on_button_pressed<I: ImplButtonDelegate>(
        self_: *mut _cef_button_delegate_t,
        button: *mut _cef_button_t,
    ) {
        let (arg_self_, arg_button) = (self_, button);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_button = &mut Button(unsafe { RefGuard::from_raw_add_ref(arg_button) });
        arg_self_.interface.on_button_pressed(arg_button)
    }
    extern "C" fn on_button_state_changed<I: ImplButtonDelegate>(
        self_: *mut _cef_button_delegate_t,
        button: *mut _cef_button_t,
    ) {
        let (arg_self_, arg_button) = (self_, button);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_button = &mut Button(unsafe { RefGuard::from_raw_add_ref(arg_button) });
        arg_self_.interface.on_button_state_changed(arg_button)
    }
}
#[doc = "See [_cef_button_delegate_t] for more documentation."]
#[derive(Clone)]
pub struct ButtonDelegate(RefGuard<_cef_button_delegate_t>);
impl ImplViewDelegate for ButtonDelegate {
    fn get_preferred_size<'a>(&self, view: &'a mut View) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_preferred_size(view)
    }
    fn get_minimum_size<'a>(&self, view: &'a mut View) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_minimum_size(view)
    }
    fn get_maximum_size<'a>(&self, view: &'a mut View) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_maximum_size(view)
    }
    fn get_height_for_width<'a>(
        &self,
        view: &'a mut View,
        width: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_height_for_width(view, width)
    }
    fn on_parent_view_changed<'a>(
        &self,
        view: &'a mut View,
        added: ::std::os::raw::c_int,
        parent: &'a mut View,
    ) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_parent_view_changed(view, added, parent)
    }
    fn on_child_view_changed<'a>(
        &self,
        view: &'a mut View,
        added: ::std::os::raw::c_int,
        child: &'a mut View,
    ) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_child_view_changed(view, added, child)
    }
    fn on_window_changed<'a>(&self, view: &'a mut View, added: ::std::os::raw::c_int) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_window_changed(view, added)
    }
    fn on_layout_changed<'a>(&self, view: &'a mut View, new_bounds: &'a Rect) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_layout_changed(view, new_bounds)
    }
    fn on_focus<'a>(&self, view: &'a mut View) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_focus(view)
    }
    fn on_blur<'a>(&self, view: &'a mut View) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_blur(view)
    }
    fn on_theme_changed<'a>(&self, view: &'a mut View) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_theme_changed(view)
    }
}
impl ImplButtonDelegate for ButtonDelegate {
    fn on_button_pressed<'a>(&self, button: &'a mut Button) {
        unsafe {
            self.0
                .on_button_pressed
                .map(|f| {
                    let arg_button = button;
                    let arg_self_ = self.as_raw();
                    let arg_button = arg_button.as_raw();
                    let result = f(arg_self_, arg_button);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_button_state_changed<'a>(&self, button: &'a mut Button) {
        unsafe {
            self.0
                .on_button_state_changed
                .map(|f| {
                    let arg_button = button;
                    let arg_self_ = self.as_raw();
                    let arg_button = arg_button.as_raw();
                    let result = f(arg_self_, arg_button);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_button_delegate_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ButtonDelegate {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_button_delegate_t> for &ButtonDelegate {
    fn as_raw(self) -> *mut _cef_button_delegate_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_button_delegate_t> for &mut ButtonDelegate {
    fn as_raw(self) -> *mut _cef_button_delegate_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<ButtonDelegate> for *mut _cef_button_delegate_t {
    fn as_wrapper(self) -> ButtonDelegate {
        ButtonDelegate(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_button_delegate_t> for ButtonDelegate {
    fn into(self) -> *mut _cef_button_delegate_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for ButtonDelegate {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplLabelButton: ImplButton {
    fn as_menu_button<'a>(&self) -> MenuButton {
        unsafe { std::mem::zeroed() }
    }
    fn set_text<'a>(&self, text: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn get_text<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn set_image<'a>(&self, button_state: ButtonState, image: &'a mut Image) {
        unsafe { std::mem::zeroed() }
    }
    fn get_image<'a>(&self, button_state: ButtonState) -> Image {
        unsafe { std::mem::zeroed() }
    }
    fn set_text_color<'a>(&self, for_state: ButtonState, color: u32) {
        unsafe { std::mem::zeroed() }
    }
    fn set_enabled_text_colors<'a>(&self, color: u32) {
        unsafe { std::mem::zeroed() }
    }
    fn set_font_list<'a>(&self, font_list: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn set_horizontal_alignment<'a>(&self, alignment: HorizontalAlignment) {
        unsafe { std::mem::zeroed() }
    }
    fn set_minimum_size<'a>(&self, size: &'a Size) {
        unsafe { std::mem::zeroed() }
    }
    fn set_maximum_size<'a>(&self, size: &'a Size) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_label_button_t {
        let mut object: _cef_label_button_t = unsafe { std::mem::zeroed() };
        impl_cef_view_t::init_methods::<Self>(&mut object.base.base);
        impl_cef_button_t::init_methods::<Self>(&mut object.base);
        impl_cef_label_button_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_label_button_t {
    use super::*;
    pub fn init_methods<I: ImplLabelButton>(object: &mut _cef_label_button_t) {
        object.as_menu_button = Some(as_menu_button::<I>);
        object.set_text = Some(set_text::<I>);
        object.get_text = Some(get_text::<I>);
        object.set_image = Some(set_image::<I>);
        object.get_image = Some(get_image::<I>);
        object.set_text_color = Some(set_text_color::<I>);
        object.set_enabled_text_colors = Some(set_enabled_text_colors::<I>);
        object.set_font_list = Some(set_font_list::<I>);
        object.set_horizontal_alignment = Some(set_horizontal_alignment::<I>);
        object.set_minimum_size = Some(set_minimum_size::<I>);
        object.set_maximum_size = Some(set_maximum_size::<I>);
    }
    extern "C" fn as_menu_button<I: ImplLabelButton>(
        self_: *mut _cef_label_button_t,
    ) -> *mut _cef_menu_button_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.as_menu_button().into()
    }
    extern "C" fn set_text<I: ImplLabelButton>(
        self_: *mut _cef_label_button_t,
        text: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_text) = (self_, text);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_text = WrapParamRef::<CefStringUtf16>::from(arg_text);
        let arg_text = arg_text.as_ref();
        arg_self_.interface.set_text(arg_text)
    }
    extern "C" fn get_text<I: ImplLabelButton>(
        self_: *mut _cef_label_button_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_text().into()
    }
    extern "C" fn set_image<I: ImplLabelButton>(
        self_: *mut _cef_label_button_t,
        button_state: cef_button_state_t,
        image: *mut _cef_image_t,
    ) {
        let (arg_self_, arg_button_state, arg_image) = (self_, button_state, image);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_button_state = arg_button_state.as_raw();
        let arg_image = &mut Image(unsafe { RefGuard::from_raw_add_ref(arg_image) });
        arg_self_.interface.set_image(arg_button_state, arg_image)
    }
    extern "C" fn get_image<I: ImplLabelButton>(
        self_: *mut _cef_label_button_t,
        button_state: cef_button_state_t,
    ) -> *mut _cef_image_t {
        let (arg_self_, arg_button_state) = (self_, button_state);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_button_state = arg_button_state.as_raw();
        arg_self_.interface.get_image(arg_button_state).into()
    }
    extern "C" fn set_text_color<I: ImplLabelButton>(
        self_: *mut _cef_label_button_t,
        for_state: cef_button_state_t,
        color: u32,
    ) {
        let (arg_self_, arg_for_state, arg_color) = (self_, for_state, color);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_for_state = arg_for_state.as_raw();
        let arg_color = arg_color.as_raw();
        arg_self_.interface.set_text_color(arg_for_state, arg_color)
    }
    extern "C" fn set_enabled_text_colors<I: ImplLabelButton>(
        self_: *mut _cef_label_button_t,
        color: u32,
    ) {
        let (arg_self_, arg_color) = (self_, color);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_color = arg_color.as_raw();
        arg_self_.interface.set_enabled_text_colors(arg_color)
    }
    extern "C" fn set_font_list<I: ImplLabelButton>(
        self_: *mut _cef_label_button_t,
        font_list: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_font_list) = (self_, font_list);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_font_list = WrapParamRef::<CefStringUtf16>::from(arg_font_list);
        let arg_font_list = arg_font_list.as_ref();
        arg_self_.interface.set_font_list(arg_font_list)
    }
    extern "C" fn set_horizontal_alignment<I: ImplLabelButton>(
        self_: *mut _cef_label_button_t,
        alignment: cef_horizontal_alignment_t,
    ) {
        let (arg_self_, arg_alignment) = (self_, alignment);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_alignment = arg_alignment.as_raw();
        arg_self_.interface.set_horizontal_alignment(arg_alignment)
    }
    extern "C" fn set_minimum_size<I: ImplLabelButton>(
        self_: *mut _cef_label_button_t,
        size: *const _cef_size_t,
    ) {
        let (arg_self_, arg_size) = (self_, size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_size = WrapParamRef::<Size>::from(arg_size);
        let arg_size = arg_size.as_ref();
        arg_self_.interface.set_minimum_size(arg_size)
    }
    extern "C" fn set_maximum_size<I: ImplLabelButton>(
        self_: *mut _cef_label_button_t,
        size: *const _cef_size_t,
    ) {
        let (arg_self_, arg_size) = (self_, size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_size = WrapParamRef::<Size>::from(arg_size);
        let arg_size = arg_size.as_ref();
        arg_self_.interface.set_maximum_size(arg_size)
    }
}
#[doc = "See [_cef_label_button_t] for more documentation."]
#[derive(Clone)]
pub struct LabelButton(RefGuard<_cef_label_button_t>);
impl ImplView for LabelButton {
    fn as_browser_view<'a>(&self) -> BrowserView {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_browser_view()
    }
    fn as_button<'a>(&self) -> Button {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).as_button()
    }
    fn as_panel<'a>(&self) -> Panel {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).as_panel()
    }
    fn as_scroll_view<'a>(&self) -> ScrollView {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_scroll_view()
    }
    fn as_textfield<'a>(&self) -> Textfield {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_textfield()
    }
    fn get_type_string<'a>(&self) -> CefStringUtf16 {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_type_string()
    }
    fn to_string<'a>(&self, include_children: ::std::os::raw::c_int) -> CefStringUtf16 {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .to_string(include_children)
    }
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).is_valid()
    }
    fn is_attached<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_attached()
    }
    fn is_same<'a>(&self, that: &'a mut View) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_same(that)
    }
    fn get_delegate<'a>(&self) -> ViewDelegate {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_delegate()
    }
    fn get_window<'a>(&self) -> Window {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_window()
    }
    fn get_id<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).get_id()
    }
    fn set_id<'a>(&self, id: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).set_id(id)
    }
    fn get_group_id<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_group_id()
    }
    fn set_group_id<'a>(&self, group_id: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_group_id(group_id)
    }
    fn get_parent_view<'a>(&self) -> View {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_parent_view()
    }
    fn get_view_for_id<'a>(&self, id: ::std::os::raw::c_int) -> View {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_view_for_id(id)
    }
    fn set_bounds<'a>(&self, bounds: &'a Rect) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_bounds(bounds)
    }
    fn get_bounds<'a>(&self) -> Rect {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_bounds()
    }
    fn get_bounds_in_screen<'a>(&self) -> Rect {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_bounds_in_screen()
    }
    fn set_size<'a>(&self, size: &'a Size) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_size(size)
    }
    fn get_size<'a>(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).get_size()
    }
    fn set_position<'a>(&self, position: &'a Point) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_position(position)
    }
    fn get_position<'a>(&self) -> Point {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_position()
    }
    fn set_insets<'a>(&self, insets: &'a Insets) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_insets(insets)
    }
    fn get_insets<'a>(&self) -> Insets {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_insets()
    }
    fn get_preferred_size<'a>(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_preferred_size()
    }
    fn size_to_preferred_size<'a>(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .size_to_preferred_size()
    }
    fn get_minimum_size<'a>(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_minimum_size()
    }
    fn get_maximum_size<'a>(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_maximum_size()
    }
    fn get_height_for_width<'a>(&self, width: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_height_for_width(width)
    }
    fn invalidate_layout<'a>(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .invalidate_layout()
    }
    fn set_visible<'a>(&self, visible: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_visible(visible)
    }
    fn is_visible<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_visible()
    }
    fn is_drawn<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).is_drawn()
    }
    fn set_enabled<'a>(&self, enabled: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_enabled(enabled)
    }
    fn is_enabled<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_enabled()
    }
    fn set_focusable<'a>(&self, focusable: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_focusable(focusable)
    }
    fn is_focusable<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_focusable()
    }
    fn is_accessibility_focusable<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_accessibility_focusable()
    }
    fn has_focus<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).has_focus()
    }
    fn request_focus<'a>(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .request_focus()
    }
    fn set_background_color<'a>(&self, color: u32) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_background_color(color)
    }
    fn get_background_color<'a>(&self) -> cef_color_t {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_background_color()
    }
    fn get_theme_color<'a>(&self, color_id: ::std::os::raw::c_int) -> cef_color_t {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_theme_color(color_id)
    }
    fn convert_point_to_screen<'a>(&self, point: &'a mut Point) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_screen(point)
    }
    fn convert_point_from_screen<'a>(&self, point: &'a mut Point) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_screen(point)
    }
    fn convert_point_to_window<'a>(&self, point: &'a mut Point) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_window(point)
    }
    fn convert_point_from_window<'a>(&self, point: &'a mut Point) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_window(point)
    }
    fn convert_point_to_view<'a>(
        &self,
        view: &'a mut View,
        point: &'a mut Point,
    ) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_view(view, point)
    }
    fn convert_point_from_view<'a>(
        &self,
        view: &'a mut View,
        point: &'a mut Point,
    ) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_view(view, point)
    }
}
impl ImplButton for LabelButton {
    fn as_label_button<'a>(&self) -> LabelButton {
        Button(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_label_button()
    }
    fn set_state<'a>(&self, state: ButtonState) {
        Button(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_state(state)
    }
    fn get_state<'a>(&self) -> ButtonState {
        Button(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_state()
    }
    fn set_ink_drop_enabled<'a>(&self, enabled: ::std::os::raw::c_int) {
        Button(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_ink_drop_enabled(enabled)
    }
    fn set_tooltip_text<'a>(&self, tooltip_text: &'a CefStringUtf16) {
        Button(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_tooltip_text(tooltip_text)
    }
    fn set_accessible_name<'a>(&self, name: &'a CefStringUtf16) {
        Button(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_accessible_name(name)
    }
}
impl ImplLabelButton for LabelButton {
    fn as_menu_button<'a>(&self) -> MenuButton {
        unsafe {
            self.0
                .as_menu_button
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_text<'a>(&self, text: &'a CefStringUtf16) {
        unsafe {
            self.0
                .set_text
                .map(|f| {
                    let arg_text = text;
                    let arg_self_ = self.as_raw();
                    let arg_text = arg_text.as_raw();
                    let result = f(arg_self_, arg_text);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_text<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_text
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_image<'a>(&self, button_state: ButtonState, image: &'a mut Image) {
        unsafe {
            self.0
                .set_image
                .map(|f| {
                    let (arg_button_state, arg_image) = (button_state, image);
                    let arg_self_ = self.as_raw();
                    let arg_button_state = arg_button_state.as_raw();
                    let arg_image = arg_image.as_raw();
                    let result = f(arg_self_, arg_button_state, arg_image);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_image<'a>(&self, button_state: ButtonState) -> Image {
        unsafe {
            self.0
                .get_image
                .map(|f| {
                    let arg_button_state = button_state;
                    let arg_self_ = self.as_raw();
                    let arg_button_state = arg_button_state.as_raw();
                    let result = f(arg_self_, arg_button_state);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_text_color<'a>(&self, for_state: ButtonState, color: u32) {
        unsafe {
            self.0
                .set_text_color
                .map(|f| {
                    let (arg_for_state, arg_color) = (for_state, color);
                    let arg_self_ = self.as_raw();
                    let arg_for_state = arg_for_state.as_raw();
                    let arg_color = arg_color;
                    let result = f(arg_self_, arg_for_state, arg_color);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_enabled_text_colors<'a>(&self, color: u32) {
        unsafe {
            self.0
                .set_enabled_text_colors
                .map(|f| {
                    let arg_color = color;
                    let arg_self_ = self.as_raw();
                    let arg_color = arg_color;
                    let result = f(arg_self_, arg_color);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_font_list<'a>(&self, font_list: &'a CefStringUtf16) {
        unsafe {
            self.0
                .set_font_list
                .map(|f| {
                    let arg_font_list = font_list;
                    let arg_self_ = self.as_raw();
                    let arg_font_list = arg_font_list.as_raw();
                    let result = f(arg_self_, arg_font_list);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_horizontal_alignment<'a>(&self, alignment: HorizontalAlignment) {
        unsafe {
            self.0
                .set_horizontal_alignment
                .map(|f| {
                    let arg_alignment = alignment;
                    let arg_self_ = self.as_raw();
                    let arg_alignment = arg_alignment.as_raw();
                    let result = f(arg_self_, arg_alignment);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_minimum_size<'a>(&self, size: &'a Size) {
        unsafe {
            self.0
                .set_minimum_size
                .map(|f| {
                    let arg_size = size;
                    let arg_self_ = self.as_raw();
                    let mut arg_size: _cef_size_t = arg_size.clone().into();
                    let arg_size = &mut arg_size;
                    let result = f(arg_self_, arg_size);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_maximum_size<'a>(&self, size: &'a Size) {
        unsafe {
            self.0
                .set_maximum_size
                .map(|f| {
                    let arg_size = size;
                    let arg_self_ = self.as_raw();
                    let mut arg_size: _cef_size_t = arg_size.clone().into();
                    let arg_size = &mut arg_size;
                    let result = f(arg_self_, arg_size);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_label_button_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for LabelButton {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_label_button_t> for &LabelButton {
    fn as_raw(self) -> *mut _cef_label_button_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_label_button_t> for &mut LabelButton {
    fn as_raw(self) -> *mut _cef_label_button_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<LabelButton> for *mut _cef_label_button_t {
    fn as_wrapper(self) -> LabelButton {
        LabelButton(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_label_button_t> for LabelButton {
    fn into(self) -> *mut _cef_label_button_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for LabelButton {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplMenuButtonPressedLock: Sized {
    fn into_raw(self) -> *mut _cef_menu_button_pressed_lock_t {
        let mut object: _cef_menu_button_pressed_lock_t = unsafe { std::mem::zeroed() };
        impl_cef_menu_button_pressed_lock_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_menu_button_pressed_lock_t {
    use super::*;
    pub fn init_methods<I: ImplMenuButtonPressedLock>(
        object: &mut _cef_menu_button_pressed_lock_t,
    ) {
    }
}
#[doc = "See [_cef_menu_button_pressed_lock_t] for more documentation."]
#[derive(Clone)]
pub struct MenuButtonPressedLock(RefGuard<_cef_menu_button_pressed_lock_t>);
impl ImplMenuButtonPressedLock for MenuButtonPressedLock {}
impl Rc for _cef_menu_button_pressed_lock_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for MenuButtonPressedLock {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_menu_button_pressed_lock_t> for &MenuButtonPressedLock {
    fn as_raw(self) -> *mut _cef_menu_button_pressed_lock_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_menu_button_pressed_lock_t> for &mut MenuButtonPressedLock {
    fn as_raw(self) -> *mut _cef_menu_button_pressed_lock_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<MenuButtonPressedLock> for *mut _cef_menu_button_pressed_lock_t {
    fn as_wrapper(self) -> MenuButtonPressedLock {
        MenuButtonPressedLock(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_menu_button_pressed_lock_t> for MenuButtonPressedLock {
    fn into(self) -> *mut _cef_menu_button_pressed_lock_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for MenuButtonPressedLock {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplMenuButtonDelegate: ImplButtonDelegate {
    fn on_menu_button_pressed<'a>(
        &self,
        menu_button: &'a mut MenuButton,
        screen_point: &'a Point,
        button_pressed_lock: &'a mut MenuButtonPressedLock,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_menu_button_delegate_t {
        let mut object: _cef_menu_button_delegate_t = unsafe { std::mem::zeroed() };
        impl_cef_view_delegate_t::init_methods::<Self>(&mut object.base.base);
        impl_cef_button_delegate_t::init_methods::<Self>(&mut object.base);
        impl_cef_menu_button_delegate_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_menu_button_delegate_t {
    use super::*;
    pub fn init_methods<I: ImplMenuButtonDelegate>(object: &mut _cef_menu_button_delegate_t) {
        object.on_menu_button_pressed = Some(on_menu_button_pressed::<I>);
    }
    extern "C" fn on_menu_button_pressed<I: ImplMenuButtonDelegate>(
        self_: *mut _cef_menu_button_delegate_t,
        menu_button: *mut _cef_menu_button_t,
        screen_point: *const _cef_point_t,
        button_pressed_lock: *mut _cef_menu_button_pressed_lock_t,
    ) {
        let (arg_self_, arg_menu_button, arg_screen_point, arg_button_pressed_lock) =
            (self_, menu_button, screen_point, button_pressed_lock);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_menu_button =
            &mut MenuButton(unsafe { RefGuard::from_raw_add_ref(arg_menu_button) });
        let arg_screen_point = WrapParamRef::<Point>::from(arg_screen_point);
        let arg_screen_point = arg_screen_point.as_ref();
        let arg_button_pressed_lock = &mut MenuButtonPressedLock(unsafe {
            RefGuard::from_raw_add_ref(arg_button_pressed_lock)
        });
        arg_self_.interface.on_menu_button_pressed(
            arg_menu_button,
            arg_screen_point,
            arg_button_pressed_lock,
        )
    }
}
#[doc = "See [_cef_menu_button_delegate_t] for more documentation."]
#[derive(Clone)]
pub struct MenuButtonDelegate(RefGuard<_cef_menu_button_delegate_t>);
impl ImplViewDelegate for MenuButtonDelegate {
    fn get_preferred_size<'a>(&self, view: &'a mut View) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_preferred_size(view)
    }
    fn get_minimum_size<'a>(&self, view: &'a mut View) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_minimum_size(view)
    }
    fn get_maximum_size<'a>(&self, view: &'a mut View) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_maximum_size(view)
    }
    fn get_height_for_width<'a>(
        &self,
        view: &'a mut View,
        width: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_height_for_width(view, width)
    }
    fn on_parent_view_changed<'a>(
        &self,
        view: &'a mut View,
        added: ::std::os::raw::c_int,
        parent: &'a mut View,
    ) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_parent_view_changed(view, added, parent)
    }
    fn on_child_view_changed<'a>(
        &self,
        view: &'a mut View,
        added: ::std::os::raw::c_int,
        child: &'a mut View,
    ) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_child_view_changed(view, added, child)
    }
    fn on_window_changed<'a>(&self, view: &'a mut View, added: ::std::os::raw::c_int) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_window_changed(view, added)
    }
    fn on_layout_changed<'a>(&self, view: &'a mut View, new_bounds: &'a Rect) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_layout_changed(view, new_bounds)
    }
    fn on_focus<'a>(&self, view: &'a mut View) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_focus(view)
    }
    fn on_blur<'a>(&self, view: &'a mut View) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_blur(view)
    }
    fn on_theme_changed<'a>(&self, view: &'a mut View) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_theme_changed(view)
    }
}
impl ImplButtonDelegate for MenuButtonDelegate {
    fn on_button_pressed<'a>(&self, button: &'a mut Button) {
        ButtonDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_button_pressed(button)
    }
    fn on_button_state_changed<'a>(&self, button: &'a mut Button) {
        ButtonDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_button_state_changed(button)
    }
}
impl ImplMenuButtonDelegate for MenuButtonDelegate {
    fn on_menu_button_pressed<'a>(
        &self,
        menu_button: &'a mut MenuButton,
        screen_point: &'a Point,
        button_pressed_lock: &'a mut MenuButtonPressedLock,
    ) {
        unsafe {
            self.0
                .on_menu_button_pressed
                .map(|f| {
                    let (arg_menu_button, arg_screen_point, arg_button_pressed_lock) =
                        (menu_button, screen_point, button_pressed_lock);
                    let arg_self_ = self.as_raw();
                    let arg_menu_button = arg_menu_button.as_raw();
                    let mut arg_screen_point: _cef_point_t = arg_screen_point.clone().into();
                    let arg_screen_point = &mut arg_screen_point;
                    let mut arg_button_pressed_lock: _cef_menu_button_pressed_lock_t =
                        arg_button_pressed_lock.clone().into();
                    let arg_button_pressed_lock = &mut arg_button_pressed_lock;
                    let result = f(
                        arg_self_,
                        arg_menu_button,
                        arg_screen_point,
                        arg_button_pressed_lock,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_menu_button_delegate_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for MenuButtonDelegate {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_menu_button_delegate_t> for &MenuButtonDelegate {
    fn as_raw(self) -> *mut _cef_menu_button_delegate_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_menu_button_delegate_t> for &mut MenuButtonDelegate {
    fn as_raw(self) -> *mut _cef_menu_button_delegate_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<MenuButtonDelegate> for *mut _cef_menu_button_delegate_t {
    fn as_wrapper(self) -> MenuButtonDelegate {
        MenuButtonDelegate(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_menu_button_delegate_t> for MenuButtonDelegate {
    fn into(self) -> *mut _cef_menu_button_delegate_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for MenuButtonDelegate {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplMenuButton: ImplLabelButton {
    fn show_menu<'a>(
        &self,
        menu_model: &'a mut MenuModel,
        screen_point: &'a Point,
        anchor_position: MenuAnchorPosition,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn trigger_menu<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_menu_button_t {
        let mut object: _cef_menu_button_t = unsafe { std::mem::zeroed() };
        impl_cef_view_t::init_methods::<Self>(&mut object.base.base.base);
        impl_cef_button_t::init_methods::<Self>(&mut object.base.base);
        impl_cef_label_button_t::init_methods::<Self>(&mut object.base);
        impl_cef_menu_button_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_menu_button_t {
    use super::*;
    pub fn init_methods<I: ImplMenuButton>(object: &mut _cef_menu_button_t) {
        object.show_menu = Some(show_menu::<I>);
        object.trigger_menu = Some(trigger_menu::<I>);
    }
    extern "C" fn show_menu<I: ImplMenuButton>(
        self_: *mut _cef_menu_button_t,
        menu_model: *mut _cef_menu_model_t,
        screen_point: *const _cef_point_t,
        anchor_position: cef_menu_anchor_position_t,
    ) {
        let (arg_self_, arg_menu_model, arg_screen_point, arg_anchor_position) =
            (self_, menu_model, screen_point, anchor_position);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_menu_model = &mut MenuModel(unsafe { RefGuard::from_raw_add_ref(arg_menu_model) });
        let arg_screen_point = WrapParamRef::<Point>::from(arg_screen_point);
        let arg_screen_point = arg_screen_point.as_ref();
        let arg_anchor_position = arg_anchor_position.as_raw();
        arg_self_
            .interface
            .show_menu(arg_menu_model, arg_screen_point, arg_anchor_position)
    }
    extern "C" fn trigger_menu<I: ImplMenuButton>(self_: *mut _cef_menu_button_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.trigger_menu()
    }
}
#[doc = "See [_cef_menu_button_t] for more documentation."]
#[derive(Clone)]
pub struct MenuButton(RefGuard<_cef_menu_button_t>);
impl ImplView for MenuButton {
    fn as_browser_view<'a>(&self) -> BrowserView {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_browser_view()
    }
    fn as_button<'a>(&self) -> Button {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).as_button()
    }
    fn as_panel<'a>(&self) -> Panel {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).as_panel()
    }
    fn as_scroll_view<'a>(&self) -> ScrollView {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_scroll_view()
    }
    fn as_textfield<'a>(&self) -> Textfield {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_textfield()
    }
    fn get_type_string<'a>(&self) -> CefStringUtf16 {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_type_string()
    }
    fn to_string<'a>(&self, include_children: ::std::os::raw::c_int) -> CefStringUtf16 {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .to_string(include_children)
    }
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).is_valid()
    }
    fn is_attached<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_attached()
    }
    fn is_same<'a>(&self, that: &'a mut View) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_same(that)
    }
    fn get_delegate<'a>(&self) -> ViewDelegate {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_delegate()
    }
    fn get_window<'a>(&self) -> Window {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_window()
    }
    fn get_id<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).get_id()
    }
    fn set_id<'a>(&self, id: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).set_id(id)
    }
    fn get_group_id<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_group_id()
    }
    fn set_group_id<'a>(&self, group_id: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_group_id(group_id)
    }
    fn get_parent_view<'a>(&self) -> View {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_parent_view()
    }
    fn get_view_for_id<'a>(&self, id: ::std::os::raw::c_int) -> View {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_view_for_id(id)
    }
    fn set_bounds<'a>(&self, bounds: &'a Rect) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_bounds(bounds)
    }
    fn get_bounds<'a>(&self) -> Rect {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_bounds()
    }
    fn get_bounds_in_screen<'a>(&self) -> Rect {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_bounds_in_screen()
    }
    fn set_size<'a>(&self, size: &'a Size) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_size(size)
    }
    fn get_size<'a>(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).get_size()
    }
    fn set_position<'a>(&self, position: &'a Point) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_position(position)
    }
    fn get_position<'a>(&self) -> Point {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_position()
    }
    fn set_insets<'a>(&self, insets: &'a Insets) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_insets(insets)
    }
    fn get_insets<'a>(&self) -> Insets {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_insets()
    }
    fn get_preferred_size<'a>(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_preferred_size()
    }
    fn size_to_preferred_size<'a>(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .size_to_preferred_size()
    }
    fn get_minimum_size<'a>(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_minimum_size()
    }
    fn get_maximum_size<'a>(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_maximum_size()
    }
    fn get_height_for_width<'a>(&self, width: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_height_for_width(width)
    }
    fn invalidate_layout<'a>(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .invalidate_layout()
    }
    fn set_visible<'a>(&self, visible: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_visible(visible)
    }
    fn is_visible<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_visible()
    }
    fn is_drawn<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).is_drawn()
    }
    fn set_enabled<'a>(&self, enabled: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_enabled(enabled)
    }
    fn is_enabled<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_enabled()
    }
    fn set_focusable<'a>(&self, focusable: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_focusable(focusable)
    }
    fn is_focusable<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_focusable()
    }
    fn is_accessibility_focusable<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_accessibility_focusable()
    }
    fn has_focus<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).has_focus()
    }
    fn request_focus<'a>(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .request_focus()
    }
    fn set_background_color<'a>(&self, color: u32) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_background_color(color)
    }
    fn get_background_color<'a>(&self) -> cef_color_t {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_background_color()
    }
    fn get_theme_color<'a>(&self, color_id: ::std::os::raw::c_int) -> cef_color_t {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_theme_color(color_id)
    }
    fn convert_point_to_screen<'a>(&self, point: &'a mut Point) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_screen(point)
    }
    fn convert_point_from_screen<'a>(&self, point: &'a mut Point) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_screen(point)
    }
    fn convert_point_to_window<'a>(&self, point: &'a mut Point) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_window(point)
    }
    fn convert_point_from_window<'a>(&self, point: &'a mut Point) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_window(point)
    }
    fn convert_point_to_view<'a>(
        &self,
        view: &'a mut View,
        point: &'a mut Point,
    ) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_view(view, point)
    }
    fn convert_point_from_view<'a>(
        &self,
        view: &'a mut View,
        point: &'a mut Point,
    ) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_view(view, point)
    }
}
impl ImplButton for MenuButton {
    fn as_label_button<'a>(&self) -> LabelButton {
        Button(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_label_button()
    }
    fn set_state<'a>(&self, state: ButtonState) {
        Button(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_state(state)
    }
    fn get_state<'a>(&self) -> ButtonState {
        Button(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_state()
    }
    fn set_ink_drop_enabled<'a>(&self, enabled: ::std::os::raw::c_int) {
        Button(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_ink_drop_enabled(enabled)
    }
    fn set_tooltip_text<'a>(&self, tooltip_text: &'a CefStringUtf16) {
        Button(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_tooltip_text(tooltip_text)
    }
    fn set_accessible_name<'a>(&self, name: &'a CefStringUtf16) {
        Button(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_accessible_name(name)
    }
}
impl ImplLabelButton for MenuButton {
    fn as_menu_button<'a>(&self) -> MenuButton {
        LabelButton(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_menu_button()
    }
    fn set_text<'a>(&self, text: &'a CefStringUtf16) {
        LabelButton(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_text(text)
    }
    fn get_text<'a>(&self) -> CefStringUtf16 {
        LabelButton(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_text()
    }
    fn set_image<'a>(&self, button_state: ButtonState, image: &'a mut Image) {
        LabelButton(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_image(button_state, image)
    }
    fn get_image<'a>(&self, button_state: ButtonState) -> Image {
        LabelButton(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_image(button_state)
    }
    fn set_text_color<'a>(&self, for_state: ButtonState, color: u32) {
        LabelButton(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_text_color(for_state, color)
    }
    fn set_enabled_text_colors<'a>(&self, color: u32) {
        LabelButton(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_enabled_text_colors(color)
    }
    fn set_font_list<'a>(&self, font_list: &'a CefStringUtf16) {
        LabelButton(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_font_list(font_list)
    }
    fn set_horizontal_alignment<'a>(&self, alignment: HorizontalAlignment) {
        LabelButton(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_horizontal_alignment(alignment)
    }
    fn set_minimum_size<'a>(&self, size: &'a Size) {
        LabelButton(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_minimum_size(size)
    }
    fn set_maximum_size<'a>(&self, size: &'a Size) {
        LabelButton(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_maximum_size(size)
    }
}
impl ImplMenuButton for MenuButton {
    fn show_menu<'a>(
        &self,
        menu_model: &'a mut MenuModel,
        screen_point: &'a Point,
        anchor_position: MenuAnchorPosition,
    ) {
        unsafe {
            self.0
                .show_menu
                .map(|f| {
                    let (arg_menu_model, arg_screen_point, arg_anchor_position) =
                        (menu_model, screen_point, anchor_position);
                    let arg_self_ = self.as_raw();
                    let arg_menu_model = arg_menu_model.as_raw();
                    let mut arg_screen_point: _cef_point_t = arg_screen_point.clone().into();
                    let arg_screen_point = &mut arg_screen_point;
                    let arg_anchor_position = arg_anchor_position.as_raw();
                    let result = f(
                        arg_self_,
                        arg_menu_model,
                        arg_screen_point,
                        arg_anchor_position,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn trigger_menu<'a>(&self) {
        unsafe {
            self.0
                .trigger_menu
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_menu_button_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for MenuButton {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_menu_button_t> for &MenuButton {
    fn as_raw(self) -> *mut _cef_menu_button_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_menu_button_t> for &mut MenuButton {
    fn as_raw(self) -> *mut _cef_menu_button_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<MenuButton> for *mut _cef_menu_button_t {
    fn as_wrapper(self) -> MenuButton {
        MenuButton(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_menu_button_t> for MenuButton {
    fn into(self) -> *mut _cef_menu_button_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for MenuButton {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplTextfieldDelegate: ImplViewDelegate {
    fn on_key_event<'a>(
        &self,
        textfield: &'a mut Textfield,
        event: &'a KeyEvent,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn on_after_user_action<'a>(&self, textfield: &'a mut Textfield) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_textfield_delegate_t {
        let mut object: _cef_textfield_delegate_t = unsafe { std::mem::zeroed() };
        impl_cef_view_delegate_t::init_methods::<Self>(&mut object.base);
        impl_cef_textfield_delegate_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_textfield_delegate_t {
    use super::*;
    pub fn init_methods<I: ImplTextfieldDelegate>(object: &mut _cef_textfield_delegate_t) {
        object.on_key_event = Some(on_key_event::<I>);
        object.on_after_user_action = Some(on_after_user_action::<I>);
    }
    extern "C" fn on_key_event<I: ImplTextfieldDelegate>(
        self_: *mut _cef_textfield_delegate_t,
        textfield: *mut _cef_textfield_t,
        event: *const _cef_key_event_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_textfield, arg_event) = (self_, textfield, event);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_textfield = &mut Textfield(unsafe { RefGuard::from_raw_add_ref(arg_textfield) });
        let arg_event = WrapParamRef::<KeyEvent>::from(arg_event);
        let arg_event = arg_event.as_ref();
        arg_self_
            .interface
            .on_key_event(arg_textfield, arg_event)
            .into()
    }
    extern "C" fn on_after_user_action<I: ImplTextfieldDelegate>(
        self_: *mut _cef_textfield_delegate_t,
        textfield: *mut _cef_textfield_t,
    ) {
        let (arg_self_, arg_textfield) = (self_, textfield);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_textfield = &mut Textfield(unsafe { RefGuard::from_raw_add_ref(arg_textfield) });
        arg_self_.interface.on_after_user_action(arg_textfield)
    }
}
#[doc = "See [_cef_textfield_delegate_t] for more documentation."]
#[derive(Clone)]
pub struct TextfieldDelegate(RefGuard<_cef_textfield_delegate_t>);
impl ImplViewDelegate for TextfieldDelegate {
    fn get_preferred_size<'a>(&self, view: &'a mut View) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_preferred_size(view)
    }
    fn get_minimum_size<'a>(&self, view: &'a mut View) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_minimum_size(view)
    }
    fn get_maximum_size<'a>(&self, view: &'a mut View) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_maximum_size(view)
    }
    fn get_height_for_width<'a>(
        &self,
        view: &'a mut View,
        width: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_height_for_width(view, width)
    }
    fn on_parent_view_changed<'a>(
        &self,
        view: &'a mut View,
        added: ::std::os::raw::c_int,
        parent: &'a mut View,
    ) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_parent_view_changed(view, added, parent)
    }
    fn on_child_view_changed<'a>(
        &self,
        view: &'a mut View,
        added: ::std::os::raw::c_int,
        child: &'a mut View,
    ) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_child_view_changed(view, added, child)
    }
    fn on_window_changed<'a>(&self, view: &'a mut View, added: ::std::os::raw::c_int) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_window_changed(view, added)
    }
    fn on_layout_changed<'a>(&self, view: &'a mut View, new_bounds: &'a Rect) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_layout_changed(view, new_bounds)
    }
    fn on_focus<'a>(&self, view: &'a mut View) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_focus(view)
    }
    fn on_blur<'a>(&self, view: &'a mut View) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_blur(view)
    }
    fn on_theme_changed<'a>(&self, view: &'a mut View) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_theme_changed(view)
    }
}
impl ImplTextfieldDelegate for TextfieldDelegate {
    fn on_key_event<'a>(
        &self,
        textfield: &'a mut Textfield,
        event: &'a KeyEvent,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_key_event
                .map(|f| {
                    let (arg_textfield, arg_event) = (textfield, event);
                    let arg_self_ = self.as_raw();
                    let arg_textfield = arg_textfield.as_raw();
                    let mut arg_event: _cef_key_event_t = arg_event.clone().into();
                    let arg_event = &mut arg_event;
                    let result = f(arg_self_, arg_textfield, arg_event);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_after_user_action<'a>(&self, textfield: &'a mut Textfield) {
        unsafe {
            self.0
                .on_after_user_action
                .map(|f| {
                    let arg_textfield = textfield;
                    let arg_self_ = self.as_raw();
                    let arg_textfield = arg_textfield.as_raw();
                    let result = f(arg_self_, arg_textfield);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_textfield_delegate_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for TextfieldDelegate {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_textfield_delegate_t> for &TextfieldDelegate {
    fn as_raw(self) -> *mut _cef_textfield_delegate_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_textfield_delegate_t> for &mut TextfieldDelegate {
    fn as_raw(self) -> *mut _cef_textfield_delegate_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<TextfieldDelegate> for *mut _cef_textfield_delegate_t {
    fn as_wrapper(self) -> TextfieldDelegate {
        TextfieldDelegate(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_textfield_delegate_t> for TextfieldDelegate {
    fn into(self) -> *mut _cef_textfield_delegate_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for TextfieldDelegate {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplTextfield: ImplView {
    fn set_password_input<'a>(&self, password_input: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn is_password_input<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn set_read_only<'a>(&self, read_only: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn is_read_only<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_text<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn set_text<'a>(&self, text: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn append_text<'a>(&self, text: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn insert_or_replace_text<'a>(&self, text: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn has_selection<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_selected_text<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn select_all<'a>(&self, reversed: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn clear_selection<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn get_selected_range<'a>(&self) -> Range {
        unsafe { std::mem::zeroed() }
    }
    fn select_range<'a>(&self, range: &'a Range) {
        unsafe { std::mem::zeroed() }
    }
    fn get_cursor_position<'a>(&self) -> usize {
        unsafe { std::mem::zeroed() }
    }
    fn set_text_color<'a>(&self, color: u32) {
        unsafe { std::mem::zeroed() }
    }
    fn get_text_color<'a>(&self) -> cef_color_t {
        unsafe { std::mem::zeroed() }
    }
    fn set_selection_text_color<'a>(&self, color: u32) {
        unsafe { std::mem::zeroed() }
    }
    fn get_selection_text_color<'a>(&self) -> cef_color_t {
        unsafe { std::mem::zeroed() }
    }
    fn set_selection_background_color<'a>(&self, color: u32) {
        unsafe { std::mem::zeroed() }
    }
    fn get_selection_background_color<'a>(&self) -> cef_color_t {
        unsafe { std::mem::zeroed() }
    }
    fn set_font_list<'a>(&self, font_list: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn apply_text_color<'a>(&self, color: u32, range: &'a Range) {
        unsafe { std::mem::zeroed() }
    }
    fn apply_text_style<'a>(&self, style: TextStyle, add: ::std::os::raw::c_int, range: &'a Range) {
        unsafe { std::mem::zeroed() }
    }
    fn is_command_enabled<'a>(&self, command_id: TextFieldCommands) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn execute_command<'a>(&self, command_id: TextFieldCommands) {
        unsafe { std::mem::zeroed() }
    }
    fn clear_edit_history<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn set_placeholder_text<'a>(&self, text: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn get_placeholder_text<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn set_placeholder_text_color<'a>(&self, color: u32) {
        unsafe { std::mem::zeroed() }
    }
    fn set_accessible_name<'a>(&self, name: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_textfield_t {
        let mut object: _cef_textfield_t = unsafe { std::mem::zeroed() };
        impl_cef_view_t::init_methods::<Self>(&mut object.base);
        impl_cef_textfield_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_textfield_t {
    use super::*;
    pub fn init_methods<I: ImplTextfield>(object: &mut _cef_textfield_t) {
        object.set_password_input = Some(set_password_input::<I>);
        object.is_password_input = Some(is_password_input::<I>);
        object.set_read_only = Some(set_read_only::<I>);
        object.is_read_only = Some(is_read_only::<I>);
        object.get_text = Some(get_text::<I>);
        object.set_text = Some(set_text::<I>);
        object.append_text = Some(append_text::<I>);
        object.insert_or_replace_text = Some(insert_or_replace_text::<I>);
        object.has_selection = Some(has_selection::<I>);
        object.get_selected_text = Some(get_selected_text::<I>);
        object.select_all = Some(select_all::<I>);
        object.clear_selection = Some(clear_selection::<I>);
        object.get_selected_range = Some(get_selected_range::<I>);
        object.select_range = Some(select_range::<I>);
        object.get_cursor_position = Some(get_cursor_position::<I>);
        object.set_text_color = Some(set_text_color::<I>);
        object.get_text_color = Some(get_text_color::<I>);
        object.set_selection_text_color = Some(set_selection_text_color::<I>);
        object.get_selection_text_color = Some(get_selection_text_color::<I>);
        object.set_selection_background_color = Some(set_selection_background_color::<I>);
        object.get_selection_background_color = Some(get_selection_background_color::<I>);
        object.set_font_list = Some(set_font_list::<I>);
        object.apply_text_color = Some(apply_text_color::<I>);
        object.apply_text_style = Some(apply_text_style::<I>);
        object.is_command_enabled = Some(is_command_enabled::<I>);
        object.execute_command = Some(execute_command::<I>);
        object.clear_edit_history = Some(clear_edit_history::<I>);
        object.set_placeholder_text = Some(set_placeholder_text::<I>);
        object.get_placeholder_text = Some(get_placeholder_text::<I>);
        object.set_placeholder_text_color = Some(set_placeholder_text_color::<I>);
        object.set_accessible_name = Some(set_accessible_name::<I>);
    }
    extern "C" fn set_password_input<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
        password_input: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_password_input) = (self_, password_input);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_password_input = arg_password_input.as_raw();
        arg_self_.interface.set_password_input(arg_password_input)
    }
    extern "C" fn is_password_input<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_password_input().into()
    }
    extern "C" fn set_read_only<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
        read_only: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_read_only) = (self_, read_only);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_read_only = arg_read_only.as_raw();
        arg_self_.interface.set_read_only(arg_read_only)
    }
    extern "C" fn is_read_only<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_read_only().into()
    }
    extern "C" fn get_text<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_text().into()
    }
    extern "C" fn set_text<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
        text: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_text) = (self_, text);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_text = WrapParamRef::<CefStringUtf16>::from(arg_text);
        let arg_text = arg_text.as_ref();
        arg_self_.interface.set_text(arg_text)
    }
    extern "C" fn append_text<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
        text: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_text) = (self_, text);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_text = WrapParamRef::<CefStringUtf16>::from(arg_text);
        let arg_text = arg_text.as_ref();
        arg_self_.interface.append_text(arg_text)
    }
    extern "C" fn insert_or_replace_text<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
        text: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_text) = (self_, text);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_text = WrapParamRef::<CefStringUtf16>::from(arg_text);
        let arg_text = arg_text.as_ref();
        arg_self_.interface.insert_or_replace_text(arg_text)
    }
    extern "C" fn has_selection<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.has_selection().into()
    }
    extern "C" fn get_selected_text<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_selected_text().into()
    }
    extern "C" fn select_all<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
        reversed: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_reversed) = (self_, reversed);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_reversed = arg_reversed.as_raw();
        arg_self_.interface.select_all(arg_reversed)
    }
    extern "C" fn clear_selection<I: ImplTextfield>(self_: *mut _cef_textfield_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.clear_selection()
    }
    extern "C" fn get_selected_range<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
    ) -> _cef_range_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_selected_range().into()
    }
    extern "C" fn select_range<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
        range: *const _cef_range_t,
    ) {
        let (arg_self_, arg_range) = (self_, range);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_range = WrapParamRef::<Range>::from(arg_range);
        let arg_range = arg_range.as_ref();
        arg_self_.interface.select_range(arg_range)
    }
    extern "C" fn get_cursor_position<I: ImplTextfield>(self_: *mut _cef_textfield_t) -> usize {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_cursor_position().into()
    }
    extern "C" fn set_text_color<I: ImplTextfield>(self_: *mut _cef_textfield_t, color: u32) {
        let (arg_self_, arg_color) = (self_, color);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_color = arg_color.as_raw();
        arg_self_.interface.set_text_color(arg_color)
    }
    extern "C" fn get_text_color<I: ImplTextfield>(self_: *mut _cef_textfield_t) -> u32 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_text_color().into()
    }
    extern "C" fn set_selection_text_color<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
        color: u32,
    ) {
        let (arg_self_, arg_color) = (self_, color);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_color = arg_color.as_raw();
        arg_self_.interface.set_selection_text_color(arg_color)
    }
    extern "C" fn get_selection_text_color<I: ImplTextfield>(self_: *mut _cef_textfield_t) -> u32 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_selection_text_color().into()
    }
    extern "C" fn set_selection_background_color<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
        color: u32,
    ) {
        let (arg_self_, arg_color) = (self_, color);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_color = arg_color.as_raw();
        arg_self_
            .interface
            .set_selection_background_color(arg_color)
    }
    extern "C" fn get_selection_background_color<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
    ) -> u32 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_selection_background_color().into()
    }
    extern "C" fn set_font_list<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
        font_list: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_font_list) = (self_, font_list);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_font_list = WrapParamRef::<CefStringUtf16>::from(arg_font_list);
        let arg_font_list = arg_font_list.as_ref();
        arg_self_.interface.set_font_list(arg_font_list)
    }
    extern "C" fn apply_text_color<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
        color: u32,
        range: *const _cef_range_t,
    ) {
        let (arg_self_, arg_color, arg_range) = (self_, color, range);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_color = arg_color.as_raw();
        let arg_range = WrapParamRef::<Range>::from(arg_range);
        let arg_range = arg_range.as_ref();
        arg_self_.interface.apply_text_color(arg_color, arg_range)
    }
    extern "C" fn apply_text_style<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
        style: cef_text_style_t,
        add: ::std::os::raw::c_int,
        range: *const _cef_range_t,
    ) {
        let (arg_self_, arg_style, arg_add, arg_range) = (self_, style, add, range);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_style = arg_style.as_raw();
        let arg_add = arg_add.as_raw();
        let arg_range = WrapParamRef::<Range>::from(arg_range);
        let arg_range = arg_range.as_ref();
        arg_self_
            .interface
            .apply_text_style(arg_style, arg_add, arg_range)
    }
    extern "C" fn is_command_enabled<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
        command_id: cef_text_field_commands_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_id) = (self_, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        arg_self_
            .interface
            .is_command_enabled(arg_command_id)
            .into()
    }
    extern "C" fn execute_command<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
        command_id: cef_text_field_commands_t,
    ) {
        let (arg_self_, arg_command_id) = (self_, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        arg_self_.interface.execute_command(arg_command_id)
    }
    extern "C" fn clear_edit_history<I: ImplTextfield>(self_: *mut _cef_textfield_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.clear_edit_history()
    }
    extern "C" fn set_placeholder_text<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
        text: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_text) = (self_, text);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_text = WrapParamRef::<CefStringUtf16>::from(arg_text);
        let arg_text = arg_text.as_ref();
        arg_self_.interface.set_placeholder_text(arg_text)
    }
    extern "C" fn get_placeholder_text<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
    ) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_placeholder_text().into()
    }
    extern "C" fn set_placeholder_text_color<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
        color: u32,
    ) {
        let (arg_self_, arg_color) = (self_, color);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_color = arg_color.as_raw();
        arg_self_.interface.set_placeholder_text_color(arg_color)
    }
    extern "C" fn set_accessible_name<I: ImplTextfield>(
        self_: *mut _cef_textfield_t,
        name: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_name) = (self_, name);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = WrapParamRef::<CefStringUtf16>::from(arg_name);
        let arg_name = arg_name.as_ref();
        arg_self_.interface.set_accessible_name(arg_name)
    }
}
#[doc = "See [_cef_textfield_t] for more documentation."]
#[derive(Clone)]
pub struct Textfield(RefGuard<_cef_textfield_t>);
impl ImplView for Textfield {
    fn as_browser_view<'a>(&self) -> BrowserView {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_browser_view()
    }
    fn as_button<'a>(&self) -> Button {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).as_button()
    }
    fn as_panel<'a>(&self) -> Panel {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).as_panel()
    }
    fn as_scroll_view<'a>(&self) -> ScrollView {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_scroll_view()
    }
    fn as_textfield<'a>(&self) -> Textfield {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_textfield()
    }
    fn get_type_string<'a>(&self) -> CefStringUtf16 {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_type_string()
    }
    fn to_string<'a>(&self, include_children: ::std::os::raw::c_int) -> CefStringUtf16 {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .to_string(include_children)
    }
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).is_valid()
    }
    fn is_attached<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_attached()
    }
    fn is_same<'a>(&self, that: &'a mut View) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_same(that)
    }
    fn get_delegate<'a>(&self) -> ViewDelegate {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_delegate()
    }
    fn get_window<'a>(&self) -> Window {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_window()
    }
    fn get_id<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).get_id()
    }
    fn set_id<'a>(&self, id: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).set_id(id)
    }
    fn get_group_id<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_group_id()
    }
    fn set_group_id<'a>(&self, group_id: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_group_id(group_id)
    }
    fn get_parent_view<'a>(&self) -> View {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_parent_view()
    }
    fn get_view_for_id<'a>(&self, id: ::std::os::raw::c_int) -> View {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_view_for_id(id)
    }
    fn set_bounds<'a>(&self, bounds: &'a Rect) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_bounds(bounds)
    }
    fn get_bounds<'a>(&self) -> Rect {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_bounds()
    }
    fn get_bounds_in_screen<'a>(&self) -> Rect {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_bounds_in_screen()
    }
    fn set_size<'a>(&self, size: &'a Size) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_size(size)
    }
    fn get_size<'a>(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).get_size()
    }
    fn set_position<'a>(&self, position: &'a Point) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_position(position)
    }
    fn get_position<'a>(&self) -> Point {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_position()
    }
    fn set_insets<'a>(&self, insets: &'a Insets) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_insets(insets)
    }
    fn get_insets<'a>(&self) -> Insets {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_insets()
    }
    fn get_preferred_size<'a>(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_preferred_size()
    }
    fn size_to_preferred_size<'a>(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .size_to_preferred_size()
    }
    fn get_minimum_size<'a>(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_minimum_size()
    }
    fn get_maximum_size<'a>(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_maximum_size()
    }
    fn get_height_for_width<'a>(&self, width: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_height_for_width(width)
    }
    fn invalidate_layout<'a>(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .invalidate_layout()
    }
    fn set_visible<'a>(&self, visible: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_visible(visible)
    }
    fn is_visible<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_visible()
    }
    fn is_drawn<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).is_drawn()
    }
    fn set_enabled<'a>(&self, enabled: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_enabled(enabled)
    }
    fn is_enabled<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_enabled()
    }
    fn set_focusable<'a>(&self, focusable: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_focusable(focusable)
    }
    fn is_focusable<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_focusable()
    }
    fn is_accessibility_focusable<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_accessibility_focusable()
    }
    fn has_focus<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).has_focus()
    }
    fn request_focus<'a>(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .request_focus()
    }
    fn set_background_color<'a>(&self, color: u32) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_background_color(color)
    }
    fn get_background_color<'a>(&self) -> cef_color_t {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_background_color()
    }
    fn get_theme_color<'a>(&self, color_id: ::std::os::raw::c_int) -> cef_color_t {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_theme_color(color_id)
    }
    fn convert_point_to_screen<'a>(&self, point: &'a mut Point) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_screen(point)
    }
    fn convert_point_from_screen<'a>(&self, point: &'a mut Point) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_screen(point)
    }
    fn convert_point_to_window<'a>(&self, point: &'a mut Point) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_window(point)
    }
    fn convert_point_from_window<'a>(&self, point: &'a mut Point) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_window(point)
    }
    fn convert_point_to_view<'a>(
        &self,
        view: &'a mut View,
        point: &'a mut Point,
    ) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_view(view, point)
    }
    fn convert_point_from_view<'a>(
        &self,
        view: &'a mut View,
        point: &'a mut Point,
    ) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_view(view, point)
    }
}
impl ImplTextfield for Textfield {
    fn set_password_input<'a>(&self, password_input: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_password_input
                .map(|f| {
                    let arg_password_input = password_input;
                    let arg_self_ = self.as_raw();
                    let arg_password_input = arg_password_input;
                    let result = f(arg_self_, arg_password_input);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_password_input<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_password_input
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_read_only<'a>(&self, read_only: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_read_only
                .map(|f| {
                    let arg_read_only = read_only;
                    let arg_self_ = self.as_raw();
                    let arg_read_only = arg_read_only;
                    let result = f(arg_self_, arg_read_only);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_read_only<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_read_only
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_text<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_text
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_text<'a>(&self, text: &'a CefStringUtf16) {
        unsafe {
            self.0
                .set_text
                .map(|f| {
                    let arg_text = text;
                    let arg_self_ = self.as_raw();
                    let arg_text = arg_text.as_raw();
                    let result = f(arg_self_, arg_text);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn append_text<'a>(&self, text: &'a CefStringUtf16) {
        unsafe {
            self.0
                .append_text
                .map(|f| {
                    let arg_text = text;
                    let arg_self_ = self.as_raw();
                    let arg_text = arg_text.as_raw();
                    let result = f(arg_self_, arg_text);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn insert_or_replace_text<'a>(&self, text: &'a CefStringUtf16) {
        unsafe {
            self.0
                .insert_or_replace_text
                .map(|f| {
                    let arg_text = text;
                    let arg_self_ = self.as_raw();
                    let arg_text = arg_text.as_raw();
                    let result = f(arg_self_, arg_text);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn has_selection<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_selection
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_selected_text<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_selected_text
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn select_all<'a>(&self, reversed: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .select_all
                .map(|f| {
                    let arg_reversed = reversed;
                    let arg_self_ = self.as_raw();
                    let arg_reversed = arg_reversed;
                    let result = f(arg_self_, arg_reversed);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn clear_selection<'a>(&self) {
        unsafe {
            self.0
                .clear_selection
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_selected_range<'a>(&self) -> Range {
        unsafe {
            self.0
                .get_selected_range
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn select_range<'a>(&self, range: &'a Range) {
        unsafe {
            self.0
                .select_range
                .map(|f| {
                    let arg_range = range;
                    let arg_self_ = self.as_raw();
                    let mut arg_range: _cef_range_t = arg_range.clone().into();
                    let arg_range = &mut arg_range;
                    let result = f(arg_self_, arg_range);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_cursor_position<'a>(&self) -> usize {
        unsafe {
            self.0
                .get_cursor_position
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_text_color<'a>(&self, color: u32) {
        unsafe {
            self.0
                .set_text_color
                .map(|f| {
                    let arg_color = color;
                    let arg_self_ = self.as_raw();
                    let arg_color = arg_color;
                    let result = f(arg_self_, arg_color);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_text_color<'a>(&self) -> cef_color_t {
        unsafe {
            self.0
                .get_text_color
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_selection_text_color<'a>(&self, color: u32) {
        unsafe {
            self.0
                .set_selection_text_color
                .map(|f| {
                    let arg_color = color;
                    let arg_self_ = self.as_raw();
                    let arg_color = arg_color;
                    let result = f(arg_self_, arg_color);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_selection_text_color<'a>(&self) -> cef_color_t {
        unsafe {
            self.0
                .get_selection_text_color
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_selection_background_color<'a>(&self, color: u32) {
        unsafe {
            self.0
                .set_selection_background_color
                .map(|f| {
                    let arg_color = color;
                    let arg_self_ = self.as_raw();
                    let arg_color = arg_color;
                    let result = f(arg_self_, arg_color);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_selection_background_color<'a>(&self) -> cef_color_t {
        unsafe {
            self.0
                .get_selection_background_color
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_font_list<'a>(&self, font_list: &'a CefStringUtf16) {
        unsafe {
            self.0
                .set_font_list
                .map(|f| {
                    let arg_font_list = font_list;
                    let arg_self_ = self.as_raw();
                    let arg_font_list = arg_font_list.as_raw();
                    let result = f(arg_self_, arg_font_list);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn apply_text_color<'a>(&self, color: u32, range: &'a Range) {
        unsafe {
            self.0
                .apply_text_color
                .map(|f| {
                    let (arg_color, arg_range) = (color, range);
                    let arg_self_ = self.as_raw();
                    let arg_color = arg_color;
                    let mut arg_range: _cef_range_t = arg_range.clone().into();
                    let arg_range = &mut arg_range;
                    let result = f(arg_self_, arg_color, arg_range);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn apply_text_style<'a>(&self, style: TextStyle, add: ::std::os::raw::c_int, range: &'a Range) {
        unsafe {
            self.0
                .apply_text_style
                .map(|f| {
                    let (arg_style, arg_add, arg_range) = (style, add, range);
                    let arg_self_ = self.as_raw();
                    let arg_style = arg_style.as_raw();
                    let arg_add = arg_add;
                    let mut arg_range: _cef_range_t = arg_range.clone().into();
                    let arg_range = &mut arg_range;
                    let result = f(arg_self_, arg_style, arg_add, arg_range);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_command_enabled<'a>(&self, command_id: TextFieldCommands) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_command_enabled
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id.as_raw();
                    let result = f(arg_self_, arg_command_id);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn execute_command<'a>(&self, command_id: TextFieldCommands) {
        unsafe {
            self.0
                .execute_command
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id.as_raw();
                    let result = f(arg_self_, arg_command_id);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn clear_edit_history<'a>(&self) {
        unsafe {
            self.0
                .clear_edit_history
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_placeholder_text<'a>(&self, text: &'a CefStringUtf16) {
        unsafe {
            self.0
                .set_placeholder_text
                .map(|f| {
                    let arg_text = text;
                    let arg_self_ = self.as_raw();
                    let arg_text = arg_text.as_raw();
                    let result = f(arg_self_, arg_text);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_placeholder_text<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_placeholder_text
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_placeholder_text_color<'a>(&self, color: u32) {
        unsafe {
            self.0
                .set_placeholder_text_color
                .map(|f| {
                    let arg_color = color;
                    let arg_self_ = self.as_raw();
                    let arg_color = arg_color;
                    let result = f(arg_self_, arg_color);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_accessible_name<'a>(&self, name: &'a CefStringUtf16) {
        unsafe {
            self.0
                .set_accessible_name
                .map(|f| {
                    let arg_name = name;
                    let arg_self_ = self.as_raw();
                    let arg_name = arg_name.as_raw();
                    let result = f(arg_self_, arg_name);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_textfield_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Textfield {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_textfield_t> for &Textfield {
    fn as_raw(self) -> *mut _cef_textfield_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_textfield_t> for &mut Textfield {
    fn as_raw(self) -> *mut _cef_textfield_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<Textfield> for *mut _cef_textfield_t {
    fn as_wrapper(self) -> Textfield {
        Textfield(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_textfield_t> for Textfield {
    fn into(self) -> *mut _cef_textfield_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for Textfield {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplBrowserViewDelegate: ImplViewDelegate {
    fn on_browser_created<'a>(&self, browser_view: &'a mut BrowserView, browser: &'a mut Browser) {
        unsafe { std::mem::zeroed() }
    }
    fn on_browser_destroyed<'a>(
        &self,
        browser_view: &'a mut BrowserView,
        browser: &'a mut Browser,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn get_delegate_for_popup_browser_view<'a>(
        &self,
        browser_view: &'a mut BrowserView,
        settings: &'a BrowserSettings,
        client: &'a mut Client,
        is_devtools: ::std::os::raw::c_int,
    ) -> BrowserViewDelegate {
        unsafe { std::mem::zeroed() }
    }
    fn on_popup_browser_view_created<'a>(
        &self,
        browser_view: &'a mut BrowserView,
        popup_browser_view: &'a mut BrowserView,
        is_devtools: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_chrome_toolbar_type<'a>(&self, browser_view: &'a mut BrowserView) -> ChromeToolbarType {
        unsafe { std::mem::zeroed() }
    }
    fn use_frameless_window_for_picture_in_picture<'a>(
        &self,
        browser_view: &'a mut BrowserView,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn on_gesture_command<'a>(
        &self,
        browser_view: &'a mut BrowserView,
        gesture_command: GestureCommand,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_browser_runtime_style<'a>(&self) -> RuntimeStyle {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_browser_view_delegate_t {
        let mut object: _cef_browser_view_delegate_t = unsafe { std::mem::zeroed() };
        impl_cef_view_delegate_t::init_methods::<Self>(&mut object.base);
        impl_cef_browser_view_delegate_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_browser_view_delegate_t {
    use super::*;
    pub fn init_methods<I: ImplBrowserViewDelegate>(object: &mut _cef_browser_view_delegate_t) {
        object.on_browser_created = Some(on_browser_created::<I>);
        object.on_browser_destroyed = Some(on_browser_destroyed::<I>);
        object.get_delegate_for_popup_browser_view = Some(get_delegate_for_popup_browser_view::<I>);
        object.on_popup_browser_view_created = Some(on_popup_browser_view_created::<I>);
        object.get_chrome_toolbar_type = Some(get_chrome_toolbar_type::<I>);
        object.use_frameless_window_for_picture_in_picture =
            Some(use_frameless_window_for_picture_in_picture::<I>);
        object.on_gesture_command = Some(on_gesture_command::<I>);
        object.get_browser_runtime_style = Some(get_browser_runtime_style::<I>);
    }
    extern "C" fn on_browser_created<I: ImplBrowserViewDelegate>(
        self_: *mut _cef_browser_view_delegate_t,
        browser_view: *mut _cef_browser_view_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser_view, arg_browser) = (self_, browser_view, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser_view =
            &mut BrowserView(unsafe { RefGuard::from_raw_add_ref(arg_browser_view) });
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        arg_self_
            .interface
            .on_browser_created(arg_browser_view, arg_browser)
    }
    extern "C" fn on_browser_destroyed<I: ImplBrowserViewDelegate>(
        self_: *mut _cef_browser_view_delegate_t,
        browser_view: *mut _cef_browser_view_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser_view, arg_browser) = (self_, browser_view, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser_view =
            &mut BrowserView(unsafe { RefGuard::from_raw_add_ref(arg_browser_view) });
        let arg_browser = &mut Browser(unsafe { RefGuard::from_raw_add_ref(arg_browser) });
        arg_self_
            .interface
            .on_browser_destroyed(arg_browser_view, arg_browser)
    }
    extern "C" fn get_delegate_for_popup_browser_view<I: ImplBrowserViewDelegate>(
        self_: *mut _cef_browser_view_delegate_t,
        browser_view: *mut _cef_browser_view_t,
        settings: *const _cef_browser_settings_t,
        client: *mut _cef_client_t,
        is_devtools: ::std::os::raw::c_int,
    ) -> *mut _cef_browser_view_delegate_t {
        let (arg_self_, arg_browser_view, arg_settings, arg_client, arg_is_devtools) =
            (self_, browser_view, settings, client, is_devtools);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser_view =
            &mut BrowserView(unsafe { RefGuard::from_raw_add_ref(arg_browser_view) });
        let arg_settings = WrapParamRef::<BrowserSettings>::from(arg_settings);
        let arg_settings = arg_settings.as_ref();
        let arg_client = &mut Client(unsafe { RefGuard::from_raw_add_ref(arg_client) });
        let arg_is_devtools = arg_is_devtools.as_raw();
        arg_self_
            .interface
            .get_delegate_for_popup_browser_view(
                arg_browser_view,
                arg_settings,
                arg_client,
                arg_is_devtools,
            )
            .into()
    }
    extern "C" fn on_popup_browser_view_created<I: ImplBrowserViewDelegate>(
        self_: *mut _cef_browser_view_delegate_t,
        browser_view: *mut _cef_browser_view_t,
        popup_browser_view: *mut _cef_browser_view_t,
        is_devtools: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser_view, arg_popup_browser_view, arg_is_devtools) =
            (self_, browser_view, popup_browser_view, is_devtools);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser_view =
            &mut BrowserView(unsafe { RefGuard::from_raw_add_ref(arg_browser_view) });
        let arg_popup_browser_view =
            &mut BrowserView(unsafe { RefGuard::from_raw_add_ref(arg_popup_browser_view) });
        let arg_is_devtools = arg_is_devtools.as_raw();
        arg_self_
            .interface
            .on_popup_browser_view_created(
                arg_browser_view,
                arg_popup_browser_view,
                arg_is_devtools,
            )
            .into()
    }
    extern "C" fn get_chrome_toolbar_type<I: ImplBrowserViewDelegate>(
        self_: *mut _cef_browser_view_delegate_t,
        browser_view: *mut _cef_browser_view_t,
    ) -> cef_chrome_toolbar_type_t {
        let (arg_self_, arg_browser_view) = (self_, browser_view);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser_view =
            &mut BrowserView(unsafe { RefGuard::from_raw_add_ref(arg_browser_view) });
        arg_self_
            .interface
            .get_chrome_toolbar_type(arg_browser_view)
            .into()
    }
    extern "C" fn use_frameless_window_for_picture_in_picture<I: ImplBrowserViewDelegate>(
        self_: *mut _cef_browser_view_delegate_t,
        browser_view: *mut _cef_browser_view_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser_view) = (self_, browser_view);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser_view =
            &mut BrowserView(unsafe { RefGuard::from_raw_add_ref(arg_browser_view) });
        arg_self_
            .interface
            .use_frameless_window_for_picture_in_picture(arg_browser_view)
            .into()
    }
    extern "C" fn on_gesture_command<I: ImplBrowserViewDelegate>(
        self_: *mut _cef_browser_view_delegate_t,
        browser_view: *mut _cef_browser_view_t,
        gesture_command: cef_gesture_command_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser_view, arg_gesture_command) =
            (self_, browser_view, gesture_command);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser_view =
            &mut BrowserView(unsafe { RefGuard::from_raw_add_ref(arg_browser_view) });
        let arg_gesture_command = arg_gesture_command.as_raw();
        arg_self_
            .interface
            .on_gesture_command(arg_browser_view, arg_gesture_command)
            .into()
    }
    extern "C" fn get_browser_runtime_style<I: ImplBrowserViewDelegate>(
        self_: *mut _cef_browser_view_delegate_t,
    ) -> cef_runtime_style_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_browser_runtime_style().into()
    }
}
#[doc = "See [_cef_browser_view_delegate_t] for more documentation."]
#[derive(Clone)]
pub struct BrowserViewDelegate(RefGuard<_cef_browser_view_delegate_t>);
impl ImplViewDelegate for BrowserViewDelegate {
    fn get_preferred_size<'a>(&self, view: &'a mut View) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_preferred_size(view)
    }
    fn get_minimum_size<'a>(&self, view: &'a mut View) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_minimum_size(view)
    }
    fn get_maximum_size<'a>(&self, view: &'a mut View) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_maximum_size(view)
    }
    fn get_height_for_width<'a>(
        &self,
        view: &'a mut View,
        width: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_height_for_width(view, width)
    }
    fn on_parent_view_changed<'a>(
        &self,
        view: &'a mut View,
        added: ::std::os::raw::c_int,
        parent: &'a mut View,
    ) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_parent_view_changed(view, added, parent)
    }
    fn on_child_view_changed<'a>(
        &self,
        view: &'a mut View,
        added: ::std::os::raw::c_int,
        child: &'a mut View,
    ) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_child_view_changed(view, added, child)
    }
    fn on_window_changed<'a>(&self, view: &'a mut View, added: ::std::os::raw::c_int) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_window_changed(view, added)
    }
    fn on_layout_changed<'a>(&self, view: &'a mut View, new_bounds: &'a Rect) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_layout_changed(view, new_bounds)
    }
    fn on_focus<'a>(&self, view: &'a mut View) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_focus(view)
    }
    fn on_blur<'a>(&self, view: &'a mut View) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_blur(view)
    }
    fn on_theme_changed<'a>(&self, view: &'a mut View) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_theme_changed(view)
    }
}
impl ImplBrowserViewDelegate for BrowserViewDelegate {
    fn on_browser_created<'a>(&self, browser_view: &'a mut BrowserView, browser: &'a mut Browser) {
        unsafe {
            self.0
                .on_browser_created
                .map(|f| {
                    let (arg_browser_view, arg_browser) = (browser_view, browser);
                    let arg_self_ = self.as_raw();
                    let arg_browser_view = arg_browser_view.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let result = f(arg_self_, arg_browser_view, arg_browser);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_browser_destroyed<'a>(
        &self,
        browser_view: &'a mut BrowserView,
        browser: &'a mut Browser,
    ) {
        unsafe {
            self.0
                .on_browser_destroyed
                .map(|f| {
                    let (arg_browser_view, arg_browser) = (browser_view, browser);
                    let arg_self_ = self.as_raw();
                    let arg_browser_view = arg_browser_view.as_raw();
                    let arg_browser = arg_browser.as_raw();
                    let result = f(arg_self_, arg_browser_view, arg_browser);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_delegate_for_popup_browser_view<'a>(
        &self,
        browser_view: &'a mut BrowserView,
        settings: &'a BrowserSettings,
        client: &'a mut Client,
        is_devtools: ::std::os::raw::c_int,
    ) -> BrowserViewDelegate {
        unsafe {
            self.0
                .get_delegate_for_popup_browser_view
                .map(|f| {
                    let (arg_browser_view, arg_settings, arg_client, arg_is_devtools) =
                        (browser_view, settings, client, is_devtools);
                    let arg_self_ = self.as_raw();
                    let arg_browser_view = arg_browser_view.as_raw();
                    let mut arg_settings: _cef_browser_settings_t = arg_settings.clone().into();
                    let arg_settings = &mut arg_settings;
                    let arg_client = arg_client.as_raw();
                    let arg_is_devtools = arg_is_devtools;
                    let result = f(
                        arg_self_,
                        arg_browser_view,
                        arg_settings,
                        arg_client,
                        arg_is_devtools,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_popup_browser_view_created<'a>(
        &self,
        browser_view: &'a mut BrowserView,
        popup_browser_view: &'a mut BrowserView,
        is_devtools: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_popup_browser_view_created
                .map(|f| {
                    let (arg_browser_view, arg_popup_browser_view, arg_is_devtools) =
                        (browser_view, popup_browser_view, is_devtools);
                    let arg_self_ = self.as_raw();
                    let arg_browser_view = arg_browser_view.as_raw();
                    let arg_popup_browser_view = arg_popup_browser_view.as_raw();
                    let arg_is_devtools = arg_is_devtools;
                    let result = f(
                        arg_self_,
                        arg_browser_view,
                        arg_popup_browser_view,
                        arg_is_devtools,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_chrome_toolbar_type<'a>(&self, browser_view: &'a mut BrowserView) -> ChromeToolbarType {
        unsafe {
            self.0
                .get_chrome_toolbar_type
                .map(|f| {
                    let arg_browser_view = browser_view;
                    let arg_self_ = self.as_raw();
                    let arg_browser_view = arg_browser_view.as_raw();
                    let result = f(arg_self_, arg_browser_view);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn use_frameless_window_for_picture_in_picture<'a>(
        &self,
        browser_view: &'a mut BrowserView,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .use_frameless_window_for_picture_in_picture
                .map(|f| {
                    let arg_browser_view = browser_view;
                    let arg_self_ = self.as_raw();
                    let arg_browser_view = arg_browser_view.as_raw();
                    let result = f(arg_self_, arg_browser_view);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_gesture_command<'a>(
        &self,
        browser_view: &'a mut BrowserView,
        gesture_command: GestureCommand,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_gesture_command
                .map(|f| {
                    let (arg_browser_view, arg_gesture_command) = (browser_view, gesture_command);
                    let arg_self_ = self.as_raw();
                    let arg_browser_view = arg_browser_view.as_raw();
                    let arg_gesture_command = arg_gesture_command.as_raw();
                    let result = f(arg_self_, arg_browser_view, arg_gesture_command);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_browser_runtime_style<'a>(&self) -> RuntimeStyle {
        unsafe {
            self.0
                .get_browser_runtime_style
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_browser_view_delegate_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for BrowserViewDelegate {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_browser_view_delegate_t> for &BrowserViewDelegate {
    fn as_raw(self) -> *mut _cef_browser_view_delegate_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_browser_view_delegate_t> for &mut BrowserViewDelegate {
    fn as_raw(self) -> *mut _cef_browser_view_delegate_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<BrowserViewDelegate> for *mut _cef_browser_view_delegate_t {
    fn as_wrapper(self) -> BrowserViewDelegate {
        BrowserViewDelegate(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_browser_view_delegate_t> for BrowserViewDelegate {
    fn into(self) -> *mut _cef_browser_view_delegate_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for BrowserViewDelegate {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplBrowserView: ImplView {
    fn get_browser<'a>(&self) -> Browser {
        unsafe { std::mem::zeroed() }
    }
    fn get_chrome_toolbar<'a>(&self) -> View {
        unsafe { std::mem::zeroed() }
    }
    fn set_prefer_accelerators<'a>(&self, prefer_accelerators: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn get_runtime_style<'a>(&self) -> RuntimeStyle {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_browser_view_t {
        let mut object: _cef_browser_view_t = unsafe { std::mem::zeroed() };
        impl_cef_view_t::init_methods::<Self>(&mut object.base);
        impl_cef_browser_view_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_browser_view_t {
    use super::*;
    pub fn init_methods<I: ImplBrowserView>(object: &mut _cef_browser_view_t) {
        object.get_browser = Some(get_browser::<I>);
        object.get_chrome_toolbar = Some(get_chrome_toolbar::<I>);
        object.set_prefer_accelerators = Some(set_prefer_accelerators::<I>);
        object.get_runtime_style = Some(get_runtime_style::<I>);
    }
    extern "C" fn get_browser<I: ImplBrowserView>(
        self_: *mut _cef_browser_view_t,
    ) -> *mut _cef_browser_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_browser().into()
    }
    extern "C" fn get_chrome_toolbar<I: ImplBrowserView>(
        self_: *mut _cef_browser_view_t,
    ) -> *mut _cef_view_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_chrome_toolbar().into()
    }
    extern "C" fn set_prefer_accelerators<I: ImplBrowserView>(
        self_: *mut _cef_browser_view_t,
        prefer_accelerators: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_prefer_accelerators) = (self_, prefer_accelerators);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_prefer_accelerators = arg_prefer_accelerators.as_raw();
        arg_self_
            .interface
            .set_prefer_accelerators(arg_prefer_accelerators)
    }
    extern "C" fn get_runtime_style<I: ImplBrowserView>(
        self_: *mut _cef_browser_view_t,
    ) -> cef_runtime_style_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_runtime_style().into()
    }
}
#[doc = "See [_cef_browser_view_t] for more documentation."]
#[derive(Clone)]
pub struct BrowserView(RefGuard<_cef_browser_view_t>);
impl ImplView for BrowserView {
    fn as_browser_view<'a>(&self) -> BrowserView {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_browser_view()
    }
    fn as_button<'a>(&self) -> Button {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).as_button()
    }
    fn as_panel<'a>(&self) -> Panel {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).as_panel()
    }
    fn as_scroll_view<'a>(&self) -> ScrollView {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_scroll_view()
    }
    fn as_textfield<'a>(&self) -> Textfield {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_textfield()
    }
    fn get_type_string<'a>(&self) -> CefStringUtf16 {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_type_string()
    }
    fn to_string<'a>(&self, include_children: ::std::os::raw::c_int) -> CefStringUtf16 {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .to_string(include_children)
    }
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).is_valid()
    }
    fn is_attached<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_attached()
    }
    fn is_same<'a>(&self, that: &'a mut View) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_same(that)
    }
    fn get_delegate<'a>(&self) -> ViewDelegate {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_delegate()
    }
    fn get_window<'a>(&self) -> Window {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_window()
    }
    fn get_id<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).get_id()
    }
    fn set_id<'a>(&self, id: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).set_id(id)
    }
    fn get_group_id<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_group_id()
    }
    fn set_group_id<'a>(&self, group_id: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_group_id(group_id)
    }
    fn get_parent_view<'a>(&self) -> View {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_parent_view()
    }
    fn get_view_for_id<'a>(&self, id: ::std::os::raw::c_int) -> View {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_view_for_id(id)
    }
    fn set_bounds<'a>(&self, bounds: &'a Rect) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_bounds(bounds)
    }
    fn get_bounds<'a>(&self) -> Rect {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_bounds()
    }
    fn get_bounds_in_screen<'a>(&self) -> Rect {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_bounds_in_screen()
    }
    fn set_size<'a>(&self, size: &'a Size) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_size(size)
    }
    fn get_size<'a>(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).get_size()
    }
    fn set_position<'a>(&self, position: &'a Point) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_position(position)
    }
    fn get_position<'a>(&self) -> Point {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_position()
    }
    fn set_insets<'a>(&self, insets: &'a Insets) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_insets(insets)
    }
    fn get_insets<'a>(&self) -> Insets {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_insets()
    }
    fn get_preferred_size<'a>(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_preferred_size()
    }
    fn size_to_preferred_size<'a>(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .size_to_preferred_size()
    }
    fn get_minimum_size<'a>(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_minimum_size()
    }
    fn get_maximum_size<'a>(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_maximum_size()
    }
    fn get_height_for_width<'a>(&self, width: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_height_for_width(width)
    }
    fn invalidate_layout<'a>(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .invalidate_layout()
    }
    fn set_visible<'a>(&self, visible: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_visible(visible)
    }
    fn is_visible<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_visible()
    }
    fn is_drawn<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).is_drawn()
    }
    fn set_enabled<'a>(&self, enabled: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_enabled(enabled)
    }
    fn is_enabled<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_enabled()
    }
    fn set_focusable<'a>(&self, focusable: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_focusable(focusable)
    }
    fn is_focusable<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_focusable()
    }
    fn is_accessibility_focusable<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_accessibility_focusable()
    }
    fn has_focus<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).has_focus()
    }
    fn request_focus<'a>(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .request_focus()
    }
    fn set_background_color<'a>(&self, color: u32) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_background_color(color)
    }
    fn get_background_color<'a>(&self) -> cef_color_t {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_background_color()
    }
    fn get_theme_color<'a>(&self, color_id: ::std::os::raw::c_int) -> cef_color_t {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_theme_color(color_id)
    }
    fn convert_point_to_screen<'a>(&self, point: &'a mut Point) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_screen(point)
    }
    fn convert_point_from_screen<'a>(&self, point: &'a mut Point) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_screen(point)
    }
    fn convert_point_to_window<'a>(&self, point: &'a mut Point) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_window(point)
    }
    fn convert_point_from_window<'a>(&self, point: &'a mut Point) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_window(point)
    }
    fn convert_point_to_view<'a>(
        &self,
        view: &'a mut View,
        point: &'a mut Point,
    ) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_view(view, point)
    }
    fn convert_point_from_view<'a>(
        &self,
        view: &'a mut View,
        point: &'a mut Point,
    ) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_view(view, point)
    }
}
impl ImplBrowserView for BrowserView {
    fn get_browser<'a>(&self) -> Browser {
        unsafe {
            self.0
                .get_browser
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_chrome_toolbar<'a>(&self) -> View {
        unsafe {
            self.0
                .get_chrome_toolbar
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_prefer_accelerators<'a>(&self, prefer_accelerators: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_prefer_accelerators
                .map(|f| {
                    let arg_prefer_accelerators = prefer_accelerators;
                    let arg_self_ = self.as_raw();
                    let arg_prefer_accelerators = arg_prefer_accelerators;
                    let result = f(arg_self_, arg_prefer_accelerators);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_runtime_style<'a>(&self) -> RuntimeStyle {
        unsafe {
            self.0
                .get_runtime_style
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_browser_view_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for BrowserView {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_browser_view_t> for &BrowserView {
    fn as_raw(self) -> *mut _cef_browser_view_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_browser_view_t> for &mut BrowserView {
    fn as_raw(self) -> *mut _cef_browser_view_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<BrowserView> for *mut _cef_browser_view_t {
    fn as_wrapper(self) -> BrowserView {
        BrowserView(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_browser_view_t> for BrowserView {
    fn into(self) -> *mut _cef_browser_view_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for BrowserView {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplScrollView: ImplView {
    fn set_content_view<'a>(&self, view: &'a mut View) {
        unsafe { std::mem::zeroed() }
    }
    fn get_content_view<'a>(&self) -> View {
        unsafe { std::mem::zeroed() }
    }
    fn get_visible_content_rect<'a>(&self) -> Rect {
        unsafe { std::mem::zeroed() }
    }
    fn has_horizontal_scrollbar<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_horizontal_scrollbar_height<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn has_vertical_scrollbar<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_vertical_scrollbar_width<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_scroll_view_t {
        let mut object: _cef_scroll_view_t = unsafe { std::mem::zeroed() };
        impl_cef_view_t::init_methods::<Self>(&mut object.base);
        impl_cef_scroll_view_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_scroll_view_t {
    use super::*;
    pub fn init_methods<I: ImplScrollView>(object: &mut _cef_scroll_view_t) {
        object.set_content_view = Some(set_content_view::<I>);
        object.get_content_view = Some(get_content_view::<I>);
        object.get_visible_content_rect = Some(get_visible_content_rect::<I>);
        object.has_horizontal_scrollbar = Some(has_horizontal_scrollbar::<I>);
        object.get_horizontal_scrollbar_height = Some(get_horizontal_scrollbar_height::<I>);
        object.has_vertical_scrollbar = Some(has_vertical_scrollbar::<I>);
        object.get_vertical_scrollbar_width = Some(get_vertical_scrollbar_width::<I>);
    }
    extern "C" fn set_content_view<I: ImplScrollView>(
        self_: *mut _cef_scroll_view_t,
        view: *mut _cef_view_t,
    ) {
        let (arg_self_, arg_view) = (self_, view);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_view = &mut View(unsafe { RefGuard::from_raw_add_ref(arg_view) });
        arg_self_.interface.set_content_view(arg_view)
    }
    extern "C" fn get_content_view<I: ImplScrollView>(
        self_: *mut _cef_scroll_view_t,
    ) -> *mut _cef_view_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_content_view().into()
    }
    extern "C" fn get_visible_content_rect<I: ImplScrollView>(
        self_: *mut _cef_scroll_view_t,
    ) -> _cef_rect_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_visible_content_rect().into()
    }
    extern "C" fn has_horizontal_scrollbar<I: ImplScrollView>(
        self_: *mut _cef_scroll_view_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.has_horizontal_scrollbar().into()
    }
    extern "C" fn get_horizontal_scrollbar_height<I: ImplScrollView>(
        self_: *mut _cef_scroll_view_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_horizontal_scrollbar_height().into()
    }
    extern "C" fn has_vertical_scrollbar<I: ImplScrollView>(
        self_: *mut _cef_scroll_view_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.has_vertical_scrollbar().into()
    }
    extern "C" fn get_vertical_scrollbar_width<I: ImplScrollView>(
        self_: *mut _cef_scroll_view_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_vertical_scrollbar_width().into()
    }
}
#[doc = "See [_cef_scroll_view_t] for more documentation."]
#[derive(Clone)]
pub struct ScrollView(RefGuard<_cef_scroll_view_t>);
impl ImplView for ScrollView {
    fn as_browser_view<'a>(&self) -> BrowserView {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_browser_view()
    }
    fn as_button<'a>(&self) -> Button {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).as_button()
    }
    fn as_panel<'a>(&self) -> Panel {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).as_panel()
    }
    fn as_scroll_view<'a>(&self) -> ScrollView {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_scroll_view()
    }
    fn as_textfield<'a>(&self) -> Textfield {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_textfield()
    }
    fn get_type_string<'a>(&self) -> CefStringUtf16 {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_type_string()
    }
    fn to_string<'a>(&self, include_children: ::std::os::raw::c_int) -> CefStringUtf16 {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .to_string(include_children)
    }
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).is_valid()
    }
    fn is_attached<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_attached()
    }
    fn is_same<'a>(&self, that: &'a mut View) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_same(that)
    }
    fn get_delegate<'a>(&self) -> ViewDelegate {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_delegate()
    }
    fn get_window<'a>(&self) -> Window {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_window()
    }
    fn get_id<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).get_id()
    }
    fn set_id<'a>(&self, id: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).set_id(id)
    }
    fn get_group_id<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_group_id()
    }
    fn set_group_id<'a>(&self, group_id: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_group_id(group_id)
    }
    fn get_parent_view<'a>(&self) -> View {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_parent_view()
    }
    fn get_view_for_id<'a>(&self, id: ::std::os::raw::c_int) -> View {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_view_for_id(id)
    }
    fn set_bounds<'a>(&self, bounds: &'a Rect) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_bounds(bounds)
    }
    fn get_bounds<'a>(&self) -> Rect {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_bounds()
    }
    fn get_bounds_in_screen<'a>(&self) -> Rect {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_bounds_in_screen()
    }
    fn set_size<'a>(&self, size: &'a Size) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_size(size)
    }
    fn get_size<'a>(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).get_size()
    }
    fn set_position<'a>(&self, position: &'a Point) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_position(position)
    }
    fn get_position<'a>(&self) -> Point {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_position()
    }
    fn set_insets<'a>(&self, insets: &'a Insets) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_insets(insets)
    }
    fn get_insets<'a>(&self) -> Insets {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_insets()
    }
    fn get_preferred_size<'a>(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_preferred_size()
    }
    fn size_to_preferred_size<'a>(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .size_to_preferred_size()
    }
    fn get_minimum_size<'a>(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_minimum_size()
    }
    fn get_maximum_size<'a>(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_maximum_size()
    }
    fn get_height_for_width<'a>(&self, width: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_height_for_width(width)
    }
    fn invalidate_layout<'a>(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .invalidate_layout()
    }
    fn set_visible<'a>(&self, visible: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_visible(visible)
    }
    fn is_visible<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_visible()
    }
    fn is_drawn<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).is_drawn()
    }
    fn set_enabled<'a>(&self, enabled: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_enabled(enabled)
    }
    fn is_enabled<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_enabled()
    }
    fn set_focusable<'a>(&self, focusable: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_focusable(focusable)
    }
    fn is_focusable<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_focusable()
    }
    fn is_accessibility_focusable<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_accessibility_focusable()
    }
    fn has_focus<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).has_focus()
    }
    fn request_focus<'a>(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .request_focus()
    }
    fn set_background_color<'a>(&self, color: u32) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_background_color(color)
    }
    fn get_background_color<'a>(&self) -> cef_color_t {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_background_color()
    }
    fn get_theme_color<'a>(&self, color_id: ::std::os::raw::c_int) -> cef_color_t {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_theme_color(color_id)
    }
    fn convert_point_to_screen<'a>(&self, point: &'a mut Point) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_screen(point)
    }
    fn convert_point_from_screen<'a>(&self, point: &'a mut Point) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_screen(point)
    }
    fn convert_point_to_window<'a>(&self, point: &'a mut Point) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_window(point)
    }
    fn convert_point_from_window<'a>(&self, point: &'a mut Point) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_window(point)
    }
    fn convert_point_to_view<'a>(
        &self,
        view: &'a mut View,
        point: &'a mut Point,
    ) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_view(view, point)
    }
    fn convert_point_from_view<'a>(
        &self,
        view: &'a mut View,
        point: &'a mut Point,
    ) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_view(view, point)
    }
}
impl ImplScrollView for ScrollView {
    fn set_content_view<'a>(&self, view: &'a mut View) {
        unsafe {
            self.0
                .set_content_view
                .map(|f| {
                    let arg_view = view;
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view.as_raw();
                    let result = f(arg_self_, arg_view);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_content_view<'a>(&self) -> View {
        unsafe {
            self.0
                .get_content_view
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_visible_content_rect<'a>(&self) -> Rect {
        unsafe {
            self.0
                .get_visible_content_rect
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn has_horizontal_scrollbar<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_horizontal_scrollbar
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_horizontal_scrollbar_height<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_horizontal_scrollbar_height
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn has_vertical_scrollbar<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_vertical_scrollbar
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_vertical_scrollbar_width<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_vertical_scrollbar_width
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_scroll_view_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ScrollView {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_scroll_view_t> for &ScrollView {
    fn as_raw(self) -> *mut _cef_scroll_view_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_scroll_view_t> for &mut ScrollView {
    fn as_raw(self) -> *mut _cef_scroll_view_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<ScrollView> for *mut _cef_scroll_view_t {
    fn as_wrapper(self) -> ScrollView {
        ScrollView(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_scroll_view_t> for ScrollView {
    fn into(self) -> *mut _cef_scroll_view_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for ScrollView {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplDisplay: Sized {
    fn get_id<'a>(&self) -> i64 {
        unsafe { std::mem::zeroed() }
    }
    fn get_device_scale_factor<'a>(&self) -> f32 {
        unsafe { std::mem::zeroed() }
    }
    fn convert_point_to_pixels<'a>(&self, point: &'a mut Point) {
        unsafe { std::mem::zeroed() }
    }
    fn convert_point_from_pixels<'a>(&self, point: &'a mut Point) {
        unsafe { std::mem::zeroed() }
    }
    fn get_bounds<'a>(&self) -> Rect {
        unsafe { std::mem::zeroed() }
    }
    fn get_work_area<'a>(&self) -> Rect {
        unsafe { std::mem::zeroed() }
    }
    fn get_rotation<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_display_t {
        let mut object: _cef_display_t = unsafe { std::mem::zeroed() };
        impl_cef_display_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_display_t {
    use super::*;
    pub fn init_methods<I: ImplDisplay>(object: &mut _cef_display_t) {
        object.get_id = Some(get_id::<I>);
        object.get_device_scale_factor = Some(get_device_scale_factor::<I>);
        object.convert_point_to_pixels = Some(convert_point_to_pixels::<I>);
        object.convert_point_from_pixels = Some(convert_point_from_pixels::<I>);
        object.get_bounds = Some(get_bounds::<I>);
        object.get_work_area = Some(get_work_area::<I>);
        object.get_rotation = Some(get_rotation::<I>);
    }
    extern "C" fn get_id<I: ImplDisplay>(self_: *mut _cef_display_t) -> i64 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_id().into()
    }
    extern "C" fn get_device_scale_factor<I: ImplDisplay>(self_: *mut _cef_display_t) -> f32 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_device_scale_factor().into()
    }
    extern "C" fn convert_point_to_pixels<I: ImplDisplay>(
        self_: *mut _cef_display_t,
        point: *mut _cef_point_t,
    ) {
        let (arg_self_, arg_point) = (self_, point);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_point = WrapParamRef::<Point>::from(arg_point);
        let arg_point = arg_point.as_mut();
        arg_self_.interface.convert_point_to_pixels(arg_point)
    }
    extern "C" fn convert_point_from_pixels<I: ImplDisplay>(
        self_: *mut _cef_display_t,
        point: *mut _cef_point_t,
    ) {
        let (arg_self_, arg_point) = (self_, point);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_point = WrapParamRef::<Point>::from(arg_point);
        let arg_point = arg_point.as_mut();
        arg_self_.interface.convert_point_from_pixels(arg_point)
    }
    extern "C" fn get_bounds<I: ImplDisplay>(self_: *mut _cef_display_t) -> _cef_rect_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_bounds().into()
    }
    extern "C" fn get_work_area<I: ImplDisplay>(self_: *mut _cef_display_t) -> _cef_rect_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_work_area().into()
    }
    extern "C" fn get_rotation<I: ImplDisplay>(
        self_: *mut _cef_display_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_rotation().into()
    }
}
#[doc = "See [_cef_display_t] for more documentation."]
#[derive(Clone)]
pub struct Display(RefGuard<_cef_display_t>);
impl ImplDisplay for Display {
    fn get_id<'a>(&self) -> i64 {
        unsafe {
            self.0
                .get_id
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_device_scale_factor<'a>(&self) -> f32 {
        unsafe {
            self.0
                .get_device_scale_factor
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn convert_point_to_pixels<'a>(&self, point: &'a mut Point) {
        unsafe {
            self.0
                .convert_point_to_pixels
                .map(|f| {
                    let arg_point = point;
                    let arg_self_ = self.as_raw();
                    let mut arg_point: _cef_point_t = arg_point.clone().into();
                    let arg_point = &mut arg_point;
                    let result = f(arg_self_, arg_point);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn convert_point_from_pixels<'a>(&self, point: &'a mut Point) {
        unsafe {
            self.0
                .convert_point_from_pixels
                .map(|f| {
                    let arg_point = point;
                    let arg_self_ = self.as_raw();
                    let mut arg_point: _cef_point_t = arg_point.clone().into();
                    let arg_point = &mut arg_point;
                    let result = f(arg_self_, arg_point);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_bounds<'a>(&self) -> Rect {
        unsafe {
            self.0
                .get_bounds
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_work_area<'a>(&self) -> Rect {
        unsafe {
            self.0
                .get_work_area
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_rotation<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_rotation
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_display_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Display {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_display_t> for &Display {
    fn as_raw(self) -> *mut _cef_display_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_display_t> for &mut Display {
    fn as_raw(self) -> *mut _cef_display_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<Display> for *mut _cef_display_t {
    fn as_wrapper(self) -> Display {
        Display(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_display_t> for Display {
    fn into(self) -> *mut _cef_display_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for Display {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplOverlayController: Sized {
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_same<'a>(&self, that: &'a mut OverlayController) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_contents_view<'a>(&self) -> View {
        unsafe { std::mem::zeroed() }
    }
    fn get_window<'a>(&self) -> Window {
        unsafe { std::mem::zeroed() }
    }
    fn get_docking_mode<'a>(&self) -> DockingMode {
        unsafe { std::mem::zeroed() }
    }
    fn destroy<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn set_bounds<'a>(&self, bounds: &'a Rect) {
        unsafe { std::mem::zeroed() }
    }
    fn get_bounds<'a>(&self) -> Rect {
        unsafe { std::mem::zeroed() }
    }
    fn get_bounds_in_screen<'a>(&self) -> Rect {
        unsafe { std::mem::zeroed() }
    }
    fn set_size<'a>(&self, size: &'a Size) {
        unsafe { std::mem::zeroed() }
    }
    fn get_size<'a>(&self) -> Size {
        unsafe { std::mem::zeroed() }
    }
    fn set_position<'a>(&self, position: &'a Point) {
        unsafe { std::mem::zeroed() }
    }
    fn get_position<'a>(&self) -> Point {
        unsafe { std::mem::zeroed() }
    }
    fn set_insets<'a>(&self, insets: &'a Insets) {
        unsafe { std::mem::zeroed() }
    }
    fn get_insets<'a>(&self) -> Insets {
        unsafe { std::mem::zeroed() }
    }
    fn size_to_preferred_size<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn set_visible<'a>(&self, visible: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn is_visible<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_drawn<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_overlay_controller_t {
        let mut object: _cef_overlay_controller_t = unsafe { std::mem::zeroed() };
        impl_cef_overlay_controller_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_overlay_controller_t {
    use super::*;
    pub fn init_methods<I: ImplOverlayController>(object: &mut _cef_overlay_controller_t) {
        object.is_valid = Some(is_valid::<I>);
        object.is_same = Some(is_same::<I>);
        object.get_contents_view = Some(get_contents_view::<I>);
        object.get_window = Some(get_window::<I>);
        object.get_docking_mode = Some(get_docking_mode::<I>);
        object.destroy = Some(destroy::<I>);
        object.set_bounds = Some(set_bounds::<I>);
        object.get_bounds = Some(get_bounds::<I>);
        object.get_bounds_in_screen = Some(get_bounds_in_screen::<I>);
        object.set_size = Some(set_size::<I>);
        object.get_size = Some(get_size::<I>);
        object.set_position = Some(set_position::<I>);
        object.get_position = Some(get_position::<I>);
        object.set_insets = Some(set_insets::<I>);
        object.get_insets = Some(get_insets::<I>);
        object.size_to_preferred_size = Some(size_to_preferred_size::<I>);
        object.set_visible = Some(set_visible::<I>);
        object.is_visible = Some(is_visible::<I>);
        object.is_drawn = Some(is_drawn::<I>);
    }
    extern "C" fn is_valid<I: ImplOverlayController>(
        self_: *mut _cef_overlay_controller_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_valid().into()
    }
    extern "C" fn is_same<I: ImplOverlayController>(
        self_: *mut _cef_overlay_controller_t,
        that: *mut _cef_overlay_controller_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_that) = (self_, that);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_that = &mut OverlayController(unsafe { RefGuard::from_raw_add_ref(arg_that) });
        arg_self_.interface.is_same(arg_that).into()
    }
    extern "C" fn get_contents_view<I: ImplOverlayController>(
        self_: *mut _cef_overlay_controller_t,
    ) -> *mut _cef_view_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_contents_view().into()
    }
    extern "C" fn get_window<I: ImplOverlayController>(
        self_: *mut _cef_overlay_controller_t,
    ) -> *mut _cef_window_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_window().into()
    }
    extern "C" fn get_docking_mode<I: ImplOverlayController>(
        self_: *mut _cef_overlay_controller_t,
    ) -> cef_docking_mode_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_docking_mode().into()
    }
    extern "C" fn destroy<I: ImplOverlayController>(self_: *mut _cef_overlay_controller_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.destroy()
    }
    extern "C" fn set_bounds<I: ImplOverlayController>(
        self_: *mut _cef_overlay_controller_t,
        bounds: *const _cef_rect_t,
    ) {
        let (arg_self_, arg_bounds) = (self_, bounds);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_bounds = WrapParamRef::<Rect>::from(arg_bounds);
        let arg_bounds = arg_bounds.as_ref();
        arg_self_.interface.set_bounds(arg_bounds)
    }
    extern "C" fn get_bounds<I: ImplOverlayController>(
        self_: *mut _cef_overlay_controller_t,
    ) -> _cef_rect_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_bounds().into()
    }
    extern "C" fn get_bounds_in_screen<I: ImplOverlayController>(
        self_: *mut _cef_overlay_controller_t,
    ) -> _cef_rect_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_bounds_in_screen().into()
    }
    extern "C" fn set_size<I: ImplOverlayController>(
        self_: *mut _cef_overlay_controller_t,
        size: *const _cef_size_t,
    ) {
        let (arg_self_, arg_size) = (self_, size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_size = WrapParamRef::<Size>::from(arg_size);
        let arg_size = arg_size.as_ref();
        arg_self_.interface.set_size(arg_size)
    }
    extern "C" fn get_size<I: ImplOverlayController>(
        self_: *mut _cef_overlay_controller_t,
    ) -> _cef_size_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_size().into()
    }
    extern "C" fn set_position<I: ImplOverlayController>(
        self_: *mut _cef_overlay_controller_t,
        position: *const _cef_point_t,
    ) {
        let (arg_self_, arg_position) = (self_, position);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_position = WrapParamRef::<Point>::from(arg_position);
        let arg_position = arg_position.as_ref();
        arg_self_.interface.set_position(arg_position)
    }
    extern "C" fn get_position<I: ImplOverlayController>(
        self_: *mut _cef_overlay_controller_t,
    ) -> _cef_point_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_position().into()
    }
    extern "C" fn set_insets<I: ImplOverlayController>(
        self_: *mut _cef_overlay_controller_t,
        insets: *const _cef_insets_t,
    ) {
        let (arg_self_, arg_insets) = (self_, insets);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_insets = WrapParamRef::<Insets>::from(arg_insets);
        let arg_insets = arg_insets.as_ref();
        arg_self_.interface.set_insets(arg_insets)
    }
    extern "C" fn get_insets<I: ImplOverlayController>(
        self_: *mut _cef_overlay_controller_t,
    ) -> _cef_insets_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_insets().into()
    }
    extern "C" fn size_to_preferred_size<I: ImplOverlayController>(
        self_: *mut _cef_overlay_controller_t,
    ) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.size_to_preferred_size()
    }
    extern "C" fn set_visible<I: ImplOverlayController>(
        self_: *mut _cef_overlay_controller_t,
        visible: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_visible) = (self_, visible);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_visible = arg_visible.as_raw();
        arg_self_.interface.set_visible(arg_visible)
    }
    extern "C" fn is_visible<I: ImplOverlayController>(
        self_: *mut _cef_overlay_controller_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_visible().into()
    }
    extern "C" fn is_drawn<I: ImplOverlayController>(
        self_: *mut _cef_overlay_controller_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_drawn().into()
    }
}
#[doc = "See [_cef_overlay_controller_t] for more documentation."]
#[derive(Clone)]
pub struct OverlayController(RefGuard<_cef_overlay_controller_t>);
impl ImplOverlayController for OverlayController {
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_same<'a>(&self, that: &'a mut OverlayController) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_same
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.as_raw();
                    let arg_that = arg_that.as_raw();
                    let result = f(arg_self_, arg_that);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_contents_view<'a>(&self) -> View {
        unsafe {
            self.0
                .get_contents_view
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_window<'a>(&self) -> Window {
        unsafe {
            self.0
                .get_window
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_docking_mode<'a>(&self) -> DockingMode {
        unsafe {
            self.0
                .get_docking_mode
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn destroy<'a>(&self) {
        unsafe {
            self.0
                .destroy
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_bounds<'a>(&self, bounds: &'a Rect) {
        unsafe {
            self.0
                .set_bounds
                .map(|f| {
                    let arg_bounds = bounds;
                    let arg_self_ = self.as_raw();
                    let mut arg_bounds: _cef_rect_t = arg_bounds.clone().into();
                    let arg_bounds = &mut arg_bounds;
                    let result = f(arg_self_, arg_bounds);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_bounds<'a>(&self) -> Rect {
        unsafe {
            self.0
                .get_bounds
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_bounds_in_screen<'a>(&self) -> Rect {
        unsafe {
            self.0
                .get_bounds_in_screen
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_size<'a>(&self, size: &'a Size) {
        unsafe {
            self.0
                .set_size
                .map(|f| {
                    let arg_size = size;
                    let arg_self_ = self.as_raw();
                    let mut arg_size: _cef_size_t = arg_size.clone().into();
                    let arg_size = &mut arg_size;
                    let result = f(arg_self_, arg_size);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_size<'a>(&self) -> Size {
        unsafe {
            self.0
                .get_size
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_position<'a>(&self, position: &'a Point) {
        unsafe {
            self.0
                .set_position
                .map(|f| {
                    let arg_position = position;
                    let arg_self_ = self.as_raw();
                    let mut arg_position: _cef_point_t = arg_position.clone().into();
                    let arg_position = &mut arg_position;
                    let result = f(arg_self_, arg_position);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_position<'a>(&self) -> Point {
        unsafe {
            self.0
                .get_position
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_insets<'a>(&self, insets: &'a Insets) {
        unsafe {
            self.0
                .set_insets
                .map(|f| {
                    let arg_insets = insets;
                    let arg_self_ = self.as_raw();
                    let mut arg_insets: _cef_insets_t = arg_insets.clone().into();
                    let arg_insets = &mut arg_insets;
                    let result = f(arg_self_, arg_insets);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_insets<'a>(&self) -> Insets {
        unsafe {
            self.0
                .get_insets
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn size_to_preferred_size<'a>(&self) {
        unsafe {
            self.0
                .size_to_preferred_size
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_visible<'a>(&self, visible: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_visible
                .map(|f| {
                    let arg_visible = visible;
                    let arg_self_ = self.as_raw();
                    let arg_visible = arg_visible;
                    let result = f(arg_self_, arg_visible);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_visible<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_visible
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_drawn<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_drawn
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_overlay_controller_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for OverlayController {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_overlay_controller_t> for &OverlayController {
    fn as_raw(self) -> *mut _cef_overlay_controller_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_overlay_controller_t> for &mut OverlayController {
    fn as_raw(self) -> *mut _cef_overlay_controller_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<OverlayController> for *mut _cef_overlay_controller_t {
    fn as_wrapper(self) -> OverlayController {
        OverlayController(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_overlay_controller_t> for OverlayController {
    fn into(self) -> *mut _cef_overlay_controller_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for OverlayController {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplPanelDelegate: ImplViewDelegate {
    fn into_raw(self) -> *mut _cef_panel_delegate_t {
        let mut object: _cef_panel_delegate_t = unsafe { std::mem::zeroed() };
        impl_cef_view_delegate_t::init_methods::<Self>(&mut object.base);
        impl_cef_panel_delegate_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_panel_delegate_t {
    use super::*;
    pub fn init_methods<I: ImplPanelDelegate>(object: &mut _cef_panel_delegate_t) {}
}
#[doc = "See [_cef_panel_delegate_t] for more documentation."]
#[derive(Clone)]
pub struct PanelDelegate(RefGuard<_cef_panel_delegate_t>);
impl ImplViewDelegate for PanelDelegate {
    fn get_preferred_size<'a>(&self, view: &'a mut View) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_preferred_size(view)
    }
    fn get_minimum_size<'a>(&self, view: &'a mut View) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_minimum_size(view)
    }
    fn get_maximum_size<'a>(&self, view: &'a mut View) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_maximum_size(view)
    }
    fn get_height_for_width<'a>(
        &self,
        view: &'a mut View,
        width: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_height_for_width(view, width)
    }
    fn on_parent_view_changed<'a>(
        &self,
        view: &'a mut View,
        added: ::std::os::raw::c_int,
        parent: &'a mut View,
    ) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_parent_view_changed(view, added, parent)
    }
    fn on_child_view_changed<'a>(
        &self,
        view: &'a mut View,
        added: ::std::os::raw::c_int,
        child: &'a mut View,
    ) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_child_view_changed(view, added, child)
    }
    fn on_window_changed<'a>(&self, view: &'a mut View, added: ::std::os::raw::c_int) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_window_changed(view, added)
    }
    fn on_layout_changed<'a>(&self, view: &'a mut View, new_bounds: &'a Rect) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_layout_changed(view, new_bounds)
    }
    fn on_focus<'a>(&self, view: &'a mut View) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_focus(view)
    }
    fn on_blur<'a>(&self, view: &'a mut View) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_blur(view)
    }
    fn on_theme_changed<'a>(&self, view: &'a mut View) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_theme_changed(view)
    }
}
impl ImplPanelDelegate for PanelDelegate {}
impl Rc for _cef_panel_delegate_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for PanelDelegate {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_panel_delegate_t> for &PanelDelegate {
    fn as_raw(self) -> *mut _cef_panel_delegate_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_panel_delegate_t> for &mut PanelDelegate {
    fn as_raw(self) -> *mut _cef_panel_delegate_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<PanelDelegate> for *mut _cef_panel_delegate_t {
    fn as_wrapper(self) -> PanelDelegate {
        PanelDelegate(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_panel_delegate_t> for PanelDelegate {
    fn into(self) -> *mut _cef_panel_delegate_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for PanelDelegate {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplPanel: ImplView {
    fn as_window<'a>(&self) -> Window {
        unsafe { std::mem::zeroed() }
    }
    fn set_to_fill_layout<'a>(&self) -> FillLayout {
        unsafe { std::mem::zeroed() }
    }
    fn set_to_box_layout<'a>(&self, settings: &'a BoxLayoutSettings) -> BoxLayout {
        unsafe { std::mem::zeroed() }
    }
    fn get_layout<'a>(&self) -> Layout {
        unsafe { std::mem::zeroed() }
    }
    fn layout<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn add_child_view<'a>(&self, view: &'a mut View) {
        unsafe { std::mem::zeroed() }
    }
    fn add_child_view_at<'a>(&self, view: &'a mut View, index: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn reorder_child_view<'a>(&self, view: &'a mut View, index: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn remove_child_view<'a>(&self, view: &'a mut View) {
        unsafe { std::mem::zeroed() }
    }
    fn remove_all_child_views<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn get_child_view_count<'a>(&self) -> usize {
        unsafe { std::mem::zeroed() }
    }
    fn get_child_view_at<'a>(&self, index: ::std::os::raw::c_int) -> View {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_panel_t {
        let mut object: _cef_panel_t = unsafe { std::mem::zeroed() };
        impl_cef_view_t::init_methods::<Self>(&mut object.base);
        impl_cef_panel_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_panel_t {
    use super::*;
    pub fn init_methods<I: ImplPanel>(object: &mut _cef_panel_t) {
        object.as_window = Some(as_window::<I>);
        object.set_to_fill_layout = Some(set_to_fill_layout::<I>);
        object.set_to_box_layout = Some(set_to_box_layout::<I>);
        object.get_layout = Some(get_layout::<I>);
        object.layout = Some(layout::<I>);
        object.add_child_view = Some(add_child_view::<I>);
        object.add_child_view_at = Some(add_child_view_at::<I>);
        object.reorder_child_view = Some(reorder_child_view::<I>);
        object.remove_child_view = Some(remove_child_view::<I>);
        object.remove_all_child_views = Some(remove_all_child_views::<I>);
        object.get_child_view_count = Some(get_child_view_count::<I>);
        object.get_child_view_at = Some(get_child_view_at::<I>);
    }
    extern "C" fn as_window<I: ImplPanel>(self_: *mut _cef_panel_t) -> *mut _cef_window_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.as_window().into()
    }
    extern "C" fn set_to_fill_layout<I: ImplPanel>(
        self_: *mut _cef_panel_t,
    ) -> *mut _cef_fill_layout_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.set_to_fill_layout().into()
    }
    extern "C" fn set_to_box_layout<I: ImplPanel>(
        self_: *mut _cef_panel_t,
        settings: *const _cef_box_layout_settings_t,
    ) -> *mut _cef_box_layout_t {
        let (arg_self_, arg_settings) = (self_, settings);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_settings = WrapParamRef::<BoxLayoutSettings>::from(arg_settings);
        let arg_settings = arg_settings.as_ref();
        arg_self_.interface.set_to_box_layout(arg_settings).into()
    }
    extern "C" fn get_layout<I: ImplPanel>(self_: *mut _cef_panel_t) -> *mut _cef_layout_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_layout().into()
    }
    extern "C" fn layout<I: ImplPanel>(self_: *mut _cef_panel_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.layout()
    }
    extern "C" fn add_child_view<I: ImplPanel>(self_: *mut _cef_panel_t, view: *mut _cef_view_t) {
        let (arg_self_, arg_view) = (self_, view);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_view = &mut View(unsafe { RefGuard::from_raw_add_ref(arg_view) });
        arg_self_.interface.add_child_view(arg_view)
    }
    extern "C" fn add_child_view_at<I: ImplPanel>(
        self_: *mut _cef_panel_t,
        view: *mut _cef_view_t,
        index: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_view, arg_index) = (self_, view, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_view = &mut View(unsafe { RefGuard::from_raw_add_ref(arg_view) });
        let arg_index = arg_index.as_raw();
        arg_self_.interface.add_child_view_at(arg_view, arg_index)
    }
    extern "C" fn reorder_child_view<I: ImplPanel>(
        self_: *mut _cef_panel_t,
        view: *mut _cef_view_t,
        index: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_view, arg_index) = (self_, view, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_view = &mut View(unsafe { RefGuard::from_raw_add_ref(arg_view) });
        let arg_index = arg_index.as_raw();
        arg_self_.interface.reorder_child_view(arg_view, arg_index)
    }
    extern "C" fn remove_child_view<I: ImplPanel>(
        self_: *mut _cef_panel_t,
        view: *mut _cef_view_t,
    ) {
        let (arg_self_, arg_view) = (self_, view);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_view = &mut View(unsafe { RefGuard::from_raw_add_ref(arg_view) });
        arg_self_.interface.remove_child_view(arg_view)
    }
    extern "C" fn remove_all_child_views<I: ImplPanel>(self_: *mut _cef_panel_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.remove_all_child_views()
    }
    extern "C" fn get_child_view_count<I: ImplPanel>(self_: *mut _cef_panel_t) -> usize {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_child_view_count().into()
    }
    extern "C" fn get_child_view_at<I: ImplPanel>(
        self_: *mut _cef_panel_t,
        index: ::std::os::raw::c_int,
    ) -> *mut _cef_view_t {
        let (arg_self_, arg_index) = (self_, index);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.as_raw();
        arg_self_.interface.get_child_view_at(arg_index).into()
    }
}
#[doc = "See [_cef_panel_t] for more documentation."]
#[derive(Clone)]
pub struct Panel(RefGuard<_cef_panel_t>);
impl ImplView for Panel {
    fn as_browser_view<'a>(&self) -> BrowserView {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_browser_view()
    }
    fn as_button<'a>(&self) -> Button {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).as_button()
    }
    fn as_panel<'a>(&self) -> Panel {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).as_panel()
    }
    fn as_scroll_view<'a>(&self) -> ScrollView {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_scroll_view()
    }
    fn as_textfield<'a>(&self) -> Textfield {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_textfield()
    }
    fn get_type_string<'a>(&self) -> CefStringUtf16 {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_type_string()
    }
    fn to_string<'a>(&self, include_children: ::std::os::raw::c_int) -> CefStringUtf16 {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .to_string(include_children)
    }
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).is_valid()
    }
    fn is_attached<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_attached()
    }
    fn is_same<'a>(&self, that: &'a mut View) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_same(that)
    }
    fn get_delegate<'a>(&self) -> ViewDelegate {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_delegate()
    }
    fn get_window<'a>(&self) -> Window {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_window()
    }
    fn get_id<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).get_id()
    }
    fn set_id<'a>(&self, id: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).set_id(id)
    }
    fn get_group_id<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_group_id()
    }
    fn set_group_id<'a>(&self, group_id: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_group_id(group_id)
    }
    fn get_parent_view<'a>(&self) -> View {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_parent_view()
    }
    fn get_view_for_id<'a>(&self, id: ::std::os::raw::c_int) -> View {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_view_for_id(id)
    }
    fn set_bounds<'a>(&self, bounds: &'a Rect) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_bounds(bounds)
    }
    fn get_bounds<'a>(&self) -> Rect {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_bounds()
    }
    fn get_bounds_in_screen<'a>(&self) -> Rect {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_bounds_in_screen()
    }
    fn set_size<'a>(&self, size: &'a Size) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_size(size)
    }
    fn get_size<'a>(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).get_size()
    }
    fn set_position<'a>(&self, position: &'a Point) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_position(position)
    }
    fn get_position<'a>(&self) -> Point {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_position()
    }
    fn set_insets<'a>(&self, insets: &'a Insets) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_insets(insets)
    }
    fn get_insets<'a>(&self) -> Insets {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_insets()
    }
    fn get_preferred_size<'a>(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_preferred_size()
    }
    fn size_to_preferred_size<'a>(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .size_to_preferred_size()
    }
    fn get_minimum_size<'a>(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_minimum_size()
    }
    fn get_maximum_size<'a>(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_maximum_size()
    }
    fn get_height_for_width<'a>(&self, width: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_height_for_width(width)
    }
    fn invalidate_layout<'a>(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .invalidate_layout()
    }
    fn set_visible<'a>(&self, visible: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_visible(visible)
    }
    fn is_visible<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_visible()
    }
    fn is_drawn<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).is_drawn()
    }
    fn set_enabled<'a>(&self, enabled: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_enabled(enabled)
    }
    fn is_enabled<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_enabled()
    }
    fn set_focusable<'a>(&self, focusable: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_focusable(focusable)
    }
    fn is_focusable<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_focusable()
    }
    fn is_accessibility_focusable<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_accessibility_focusable()
    }
    fn has_focus<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).has_focus()
    }
    fn request_focus<'a>(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .request_focus()
    }
    fn set_background_color<'a>(&self, color: u32) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_background_color(color)
    }
    fn get_background_color<'a>(&self) -> cef_color_t {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_background_color()
    }
    fn get_theme_color<'a>(&self, color_id: ::std::os::raw::c_int) -> cef_color_t {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_theme_color(color_id)
    }
    fn convert_point_to_screen<'a>(&self, point: &'a mut Point) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_screen(point)
    }
    fn convert_point_from_screen<'a>(&self, point: &'a mut Point) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_screen(point)
    }
    fn convert_point_to_window<'a>(&self, point: &'a mut Point) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_window(point)
    }
    fn convert_point_from_window<'a>(&self, point: &'a mut Point) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_window(point)
    }
    fn convert_point_to_view<'a>(
        &self,
        view: &'a mut View,
        point: &'a mut Point,
    ) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_view(view, point)
    }
    fn convert_point_from_view<'a>(
        &self,
        view: &'a mut View,
        point: &'a mut Point,
    ) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_view(view, point)
    }
}
impl ImplPanel for Panel {
    fn as_window<'a>(&self) -> Window {
        unsafe {
            self.0
                .as_window
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_to_fill_layout<'a>(&self) -> FillLayout {
        unsafe {
            self.0
                .set_to_fill_layout
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_to_box_layout<'a>(&self, settings: &'a BoxLayoutSettings) -> BoxLayout {
        unsafe {
            self.0
                .set_to_box_layout
                .map(|f| {
                    let arg_settings = settings;
                    let arg_self_ = self.as_raw();
                    let mut arg_settings: _cef_box_layout_settings_t = arg_settings.clone().into();
                    let arg_settings = &mut arg_settings;
                    let result = f(arg_self_, arg_settings);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_layout<'a>(&self) -> Layout {
        unsafe {
            self.0
                .get_layout
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn layout<'a>(&self) {
        unsafe {
            self.0
                .layout
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn add_child_view<'a>(&self, view: &'a mut View) {
        unsafe {
            self.0
                .add_child_view
                .map(|f| {
                    let arg_view = view;
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view.as_raw();
                    let result = f(arg_self_, arg_view);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn add_child_view_at<'a>(&self, view: &'a mut View, index: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .add_child_view_at
                .map(|f| {
                    let (arg_view, arg_index) = (view, index);
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_view, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn reorder_child_view<'a>(&self, view: &'a mut View, index: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .reorder_child_view
                .map(|f| {
                    let (arg_view, arg_index) = (view, index);
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_view, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn remove_child_view<'a>(&self, view: &'a mut View) {
        unsafe {
            self.0
                .remove_child_view
                .map(|f| {
                    let arg_view = view;
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view.as_raw();
                    let result = f(arg_self_, arg_view);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn remove_all_child_views<'a>(&self) {
        unsafe {
            self.0
                .remove_all_child_views
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_child_view_count<'a>(&self) -> usize {
        unsafe {
            self.0
                .get_child_view_count
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_child_view_at<'a>(&self, index: ::std::os::raw::c_int) -> View {
        unsafe {
            self.0
                .get_child_view_at
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.as_raw();
                    let arg_index = arg_index;
                    let result = f(arg_self_, arg_index);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_panel_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Panel {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_panel_t> for &Panel {
    fn as_raw(self) -> *mut _cef_panel_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_panel_t> for &mut Panel {
    fn as_raw(self) -> *mut _cef_panel_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<Panel> for *mut _cef_panel_t {
    fn as_wrapper(self) -> Panel {
        Panel(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_panel_t> for Panel {
    fn into(self) -> *mut _cef_panel_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for Panel {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplWindowDelegate: ImplPanelDelegate {
    fn on_window_created<'a>(&self, window: &'a mut Window) {
        unsafe { std::mem::zeroed() }
    }
    fn on_window_closing<'a>(&self, window: &'a mut Window) {
        unsafe { std::mem::zeroed() }
    }
    fn on_window_destroyed<'a>(&self, window: &'a mut Window) {
        unsafe { std::mem::zeroed() }
    }
    fn on_window_activation_changed<'a>(
        &self,
        window: &'a mut Window,
        active: ::std::os::raw::c_int,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn on_window_bounds_changed<'a>(&self, window: &'a mut Window, new_bounds: &'a Rect) {
        unsafe { std::mem::zeroed() }
    }
    fn on_window_fullscreen_transition<'a>(
        &self,
        window: &'a mut Window,
        is_completed: ::std::os::raw::c_int,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn get_parent_window<'a>(
        &self,
        window: &'a mut Window,
        is_menu: *mut ::std::os::raw::c_int,
        can_activate_menu: *mut ::std::os::raw::c_int,
    ) -> Window {
        unsafe { std::mem::zeroed() }
    }
    fn is_window_modal_dialog<'a>(&self, window: &'a mut Window) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_initial_bounds<'a>(&self, window: &'a mut Window) -> Rect {
        unsafe { std::mem::zeroed() }
    }
    fn get_initial_show_state<'a>(&self, window: &'a mut Window) -> ShowState {
        unsafe { std::mem::zeroed() }
    }
    fn is_frameless<'a>(&self, window: &'a mut Window) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn with_standard_window_buttons<'a>(&self, window: &'a mut Window) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_titlebar_height<'a>(
        &self,
        window: &'a mut Window,
        titlebar_height: *mut f32,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn accepts_first_mouse<'a>(&self, window: &'a mut Window) -> State {
        unsafe { std::mem::zeroed() }
    }
    fn can_resize<'a>(&self, window: &'a mut Window) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn can_maximize<'a>(&self, window: &'a mut Window) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn can_minimize<'a>(&self, window: &'a mut Window) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn can_close<'a>(&self, window: &'a mut Window) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn on_accelerator<'a>(
        &self,
        window: &'a mut Window,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn on_key_event<'a>(
        &self,
        window: &'a mut Window,
        event: &'a KeyEvent,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn on_theme_colors_changed<'a>(
        &self,
        window: &'a mut Window,
        chrome_theme: ::std::os::raw::c_int,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn get_window_runtime_style<'a>(&self) -> RuntimeStyle {
        unsafe { std::mem::zeroed() }
    }
    fn get_linux_window_properties<'a>(
        &self,
        window: &'a mut Window,
        properties: &'a mut LinuxWindowProperties,
    ) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_window_delegate_t {
        let mut object: _cef_window_delegate_t = unsafe { std::mem::zeroed() };
        impl_cef_view_delegate_t::init_methods::<Self>(&mut object.base.base);
        impl_cef_panel_delegate_t::init_methods::<Self>(&mut object.base);
        impl_cef_window_delegate_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_window_delegate_t {
    use super::*;
    pub fn init_methods<I: ImplWindowDelegate>(object: &mut _cef_window_delegate_t) {
        object.on_window_created = Some(on_window_created::<I>);
        object.on_window_closing = Some(on_window_closing::<I>);
        object.on_window_destroyed = Some(on_window_destroyed::<I>);
        object.on_window_activation_changed = Some(on_window_activation_changed::<I>);
        object.on_window_bounds_changed = Some(on_window_bounds_changed::<I>);
        object.on_window_fullscreen_transition = Some(on_window_fullscreen_transition::<I>);
        object.get_parent_window = Some(get_parent_window::<I>);
        object.is_window_modal_dialog = Some(is_window_modal_dialog::<I>);
        object.get_initial_bounds = Some(get_initial_bounds::<I>);
        object.get_initial_show_state = Some(get_initial_show_state::<I>);
        object.is_frameless = Some(is_frameless::<I>);
        object.with_standard_window_buttons = Some(with_standard_window_buttons::<I>);
        object.get_titlebar_height = Some(get_titlebar_height::<I>);
        object.accepts_first_mouse = Some(accepts_first_mouse::<I>);
        object.can_resize = Some(can_resize::<I>);
        object.can_maximize = Some(can_maximize::<I>);
        object.can_minimize = Some(can_minimize::<I>);
        object.can_close = Some(can_close::<I>);
        object.on_accelerator = Some(on_accelerator::<I>);
        object.on_key_event = Some(on_key_event::<I>);
        object.on_theme_colors_changed = Some(on_theme_colors_changed::<I>);
        object.get_window_runtime_style = Some(get_window_runtime_style::<I>);
        object.get_linux_window_properties = Some(get_linux_window_properties::<I>);
    }
    extern "C" fn on_window_created<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
    ) {
        let (arg_self_, arg_window) = (self_, window);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_window = &mut Window(unsafe { RefGuard::from_raw_add_ref(arg_window) });
        arg_self_.interface.on_window_created(arg_window)
    }
    extern "C" fn on_window_closing<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
    ) {
        let (arg_self_, arg_window) = (self_, window);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_window = &mut Window(unsafe { RefGuard::from_raw_add_ref(arg_window) });
        arg_self_.interface.on_window_closing(arg_window)
    }
    extern "C" fn on_window_destroyed<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
    ) {
        let (arg_self_, arg_window) = (self_, window);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_window = &mut Window(unsafe { RefGuard::from_raw_add_ref(arg_window) });
        arg_self_.interface.on_window_destroyed(arg_window)
    }
    extern "C" fn on_window_activation_changed<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
        active: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_window, arg_active) = (self_, window, active);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_window = &mut Window(unsafe { RefGuard::from_raw_add_ref(arg_window) });
        let arg_active = arg_active.as_raw();
        arg_self_
            .interface
            .on_window_activation_changed(arg_window, arg_active)
    }
    extern "C" fn on_window_bounds_changed<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
        new_bounds: *const _cef_rect_t,
    ) {
        let (arg_self_, arg_window, arg_new_bounds) = (self_, window, new_bounds);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_window = &mut Window(unsafe { RefGuard::from_raw_add_ref(arg_window) });
        let arg_new_bounds = WrapParamRef::<Rect>::from(arg_new_bounds);
        let arg_new_bounds = arg_new_bounds.as_ref();
        arg_self_
            .interface
            .on_window_bounds_changed(arg_window, arg_new_bounds)
    }
    extern "C" fn on_window_fullscreen_transition<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
        is_completed: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_window, arg_is_completed) = (self_, window, is_completed);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_window = &mut Window(unsafe { RefGuard::from_raw_add_ref(arg_window) });
        let arg_is_completed = arg_is_completed.as_raw();
        arg_self_
            .interface
            .on_window_fullscreen_transition(arg_window, arg_is_completed)
    }
    extern "C" fn get_parent_window<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
        is_menu: *mut ::std::os::raw::c_int,
        can_activate_menu: *mut ::std::os::raw::c_int,
    ) -> *mut _cef_window_t {
        let (arg_self_, arg_window, arg_is_menu, arg_can_activate_menu) =
            (self_, window, is_menu, can_activate_menu);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_window = &mut Window(unsafe { RefGuard::from_raw_add_ref(arg_window) });
        let mut arg_is_menu = WrapParamRef::<::std::os::raw::c_int>::from(arg_is_menu);
        let arg_is_menu = arg_is_menu.as_mut();
        let mut arg_can_activate_menu =
            WrapParamRef::<::std::os::raw::c_int>::from(arg_can_activate_menu);
        let arg_can_activate_menu = arg_can_activate_menu.as_mut();
        arg_self_
            .interface
            .get_parent_window(arg_window, arg_is_menu, arg_can_activate_menu)
            .into()
    }
    extern "C" fn is_window_modal_dialog<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_window) = (self_, window);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_window = &mut Window(unsafe { RefGuard::from_raw_add_ref(arg_window) });
        arg_self_
            .interface
            .is_window_modal_dialog(arg_window)
            .into()
    }
    extern "C" fn get_initial_bounds<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
    ) -> _cef_rect_t {
        let (arg_self_, arg_window) = (self_, window);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_window = &mut Window(unsafe { RefGuard::from_raw_add_ref(arg_window) });
        arg_self_.interface.get_initial_bounds(arg_window).into()
    }
    extern "C" fn get_initial_show_state<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
    ) -> cef_show_state_t {
        let (arg_self_, arg_window) = (self_, window);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_window = &mut Window(unsafe { RefGuard::from_raw_add_ref(arg_window) });
        arg_self_
            .interface
            .get_initial_show_state(arg_window)
            .into()
    }
    extern "C" fn is_frameless<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_window) = (self_, window);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_window = &mut Window(unsafe { RefGuard::from_raw_add_ref(arg_window) });
        arg_self_.interface.is_frameless(arg_window).into()
    }
    extern "C" fn with_standard_window_buttons<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_window) = (self_, window);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_window = &mut Window(unsafe { RefGuard::from_raw_add_ref(arg_window) });
        arg_self_
            .interface
            .with_standard_window_buttons(arg_window)
            .into()
    }
    extern "C" fn get_titlebar_height<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
        titlebar_height: *mut f32,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_window, arg_titlebar_height) = (self_, window, titlebar_height);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_window = &mut Window(unsafe { RefGuard::from_raw_add_ref(arg_window) });
        let mut arg_titlebar_height = WrapParamRef::<f32>::from(arg_titlebar_height);
        let arg_titlebar_height = arg_titlebar_height.as_mut();
        arg_self_
            .interface
            .get_titlebar_height(arg_window, arg_titlebar_height)
            .into()
    }
    extern "C" fn accepts_first_mouse<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
    ) -> cef_state_t {
        let (arg_self_, arg_window) = (self_, window);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_window = &mut Window(unsafe { RefGuard::from_raw_add_ref(arg_window) });
        arg_self_.interface.accepts_first_mouse(arg_window).into()
    }
    extern "C" fn can_resize<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_window) = (self_, window);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_window = &mut Window(unsafe { RefGuard::from_raw_add_ref(arg_window) });
        arg_self_.interface.can_resize(arg_window).into()
    }
    extern "C" fn can_maximize<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_window) = (self_, window);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_window = &mut Window(unsafe { RefGuard::from_raw_add_ref(arg_window) });
        arg_self_.interface.can_maximize(arg_window).into()
    }
    extern "C" fn can_minimize<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_window) = (self_, window);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_window = &mut Window(unsafe { RefGuard::from_raw_add_ref(arg_window) });
        arg_self_.interface.can_minimize(arg_window).into()
    }
    extern "C" fn can_close<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_window) = (self_, window);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_window = &mut Window(unsafe { RefGuard::from_raw_add_ref(arg_window) });
        arg_self_.interface.can_close(arg_window).into()
    }
    extern "C" fn on_accelerator<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_window, arg_command_id) = (self_, window, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_window = &mut Window(unsafe { RefGuard::from_raw_add_ref(arg_window) });
        let arg_command_id = arg_command_id.as_raw();
        arg_self_
            .interface
            .on_accelerator(arg_window, arg_command_id)
            .into()
    }
    extern "C" fn on_key_event<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
        event: *const _cef_key_event_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_window, arg_event) = (self_, window, event);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_window = &mut Window(unsafe { RefGuard::from_raw_add_ref(arg_window) });
        let arg_event = WrapParamRef::<KeyEvent>::from(arg_event);
        let arg_event = arg_event.as_ref();
        arg_self_
            .interface
            .on_key_event(arg_window, arg_event)
            .into()
    }
    extern "C" fn on_theme_colors_changed<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
        chrome_theme: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_window, arg_chrome_theme) = (self_, window, chrome_theme);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_window = &mut Window(unsafe { RefGuard::from_raw_add_ref(arg_window) });
        let arg_chrome_theme = arg_chrome_theme.as_raw();
        arg_self_
            .interface
            .on_theme_colors_changed(arg_window, arg_chrome_theme)
    }
    extern "C" fn get_window_runtime_style<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
    ) -> cef_runtime_style_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_window_runtime_style().into()
    }
    extern "C" fn get_linux_window_properties<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
        properties: *mut _cef_linux_window_properties_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_window, arg_properties) = (self_, window, properties);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_window = &mut Window(unsafe { RefGuard::from_raw_add_ref(arg_window) });
        let mut arg_properties = WrapParamRef::<LinuxWindowProperties>::from(arg_properties);
        let arg_properties = arg_properties.as_mut();
        arg_self_
            .interface
            .get_linux_window_properties(arg_window, arg_properties)
            .into()
    }
}
#[doc = "See [_cef_window_delegate_t] for more documentation."]
#[derive(Clone)]
pub struct WindowDelegate(RefGuard<_cef_window_delegate_t>);
impl ImplViewDelegate for WindowDelegate {
    fn get_preferred_size<'a>(&self, view: &'a mut View) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_preferred_size(view)
    }
    fn get_minimum_size<'a>(&self, view: &'a mut View) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_minimum_size(view)
    }
    fn get_maximum_size<'a>(&self, view: &'a mut View) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_maximum_size(view)
    }
    fn get_height_for_width<'a>(
        &self,
        view: &'a mut View,
        width: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_height_for_width(view, width)
    }
    fn on_parent_view_changed<'a>(
        &self,
        view: &'a mut View,
        added: ::std::os::raw::c_int,
        parent: &'a mut View,
    ) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_parent_view_changed(view, added, parent)
    }
    fn on_child_view_changed<'a>(
        &self,
        view: &'a mut View,
        added: ::std::os::raw::c_int,
        child: &'a mut View,
    ) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_child_view_changed(view, added, child)
    }
    fn on_window_changed<'a>(&self, view: &'a mut View, added: ::std::os::raw::c_int) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_window_changed(view, added)
    }
    fn on_layout_changed<'a>(&self, view: &'a mut View, new_bounds: &'a Rect) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_layout_changed(view, new_bounds)
    }
    fn on_focus<'a>(&self, view: &'a mut View) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_focus(view)
    }
    fn on_blur<'a>(&self, view: &'a mut View) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_blur(view)
    }
    fn on_theme_changed<'a>(&self, view: &'a mut View) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .on_theme_changed(view)
    }
}
impl ImplPanelDelegate for WindowDelegate {}
impl ImplWindowDelegate for WindowDelegate {
    fn on_window_created<'a>(&self, window: &'a mut Window) {
        unsafe {
            self.0
                .on_window_created
                .map(|f| {
                    let arg_window = window;
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window.as_raw();
                    let result = f(arg_self_, arg_window);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_window_closing<'a>(&self, window: &'a mut Window) {
        unsafe {
            self.0
                .on_window_closing
                .map(|f| {
                    let arg_window = window;
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window.as_raw();
                    let result = f(arg_self_, arg_window);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_window_destroyed<'a>(&self, window: &'a mut Window) {
        unsafe {
            self.0
                .on_window_destroyed
                .map(|f| {
                    let arg_window = window;
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window.as_raw();
                    let result = f(arg_self_, arg_window);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_window_activation_changed<'a>(
        &self,
        window: &'a mut Window,
        active: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .on_window_activation_changed
                .map(|f| {
                    let (arg_window, arg_active) = (window, active);
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window.as_raw();
                    let arg_active = arg_active;
                    let result = f(arg_self_, arg_window, arg_active);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_window_bounds_changed<'a>(&self, window: &'a mut Window, new_bounds: &'a Rect) {
        unsafe {
            self.0
                .on_window_bounds_changed
                .map(|f| {
                    let (arg_window, arg_new_bounds) = (window, new_bounds);
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window.as_raw();
                    let mut arg_new_bounds: _cef_rect_t = arg_new_bounds.clone().into();
                    let arg_new_bounds = &mut arg_new_bounds;
                    let result = f(arg_self_, arg_window, arg_new_bounds);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_window_fullscreen_transition<'a>(
        &self,
        window: &'a mut Window,
        is_completed: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .on_window_fullscreen_transition
                .map(|f| {
                    let (arg_window, arg_is_completed) = (window, is_completed);
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window.as_raw();
                    let arg_is_completed = arg_is_completed;
                    let result = f(arg_self_, arg_window, arg_is_completed);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_parent_window<'a>(
        &self,
        window: &'a mut Window,
        is_menu: *mut ::std::os::raw::c_int,
        can_activate_menu: *mut ::std::os::raw::c_int,
    ) -> Window {
        unsafe {
            self.0
                .get_parent_window
                .map(|f| {
                    let (arg_window, arg_is_menu, arg_can_activate_menu) =
                        (window, is_menu, can_activate_menu);
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window.as_raw();
                    let arg_is_menu = arg_is_menu as *mut _;
                    let arg_can_activate_menu = arg_can_activate_menu as *mut _;
                    let result = f(arg_self_, arg_window, arg_is_menu, arg_can_activate_menu);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_window_modal_dialog<'a>(&self, window: &'a mut Window) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_window_modal_dialog
                .map(|f| {
                    let arg_window = window;
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window.as_raw();
                    let result = f(arg_self_, arg_window);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_initial_bounds<'a>(&self, window: &'a mut Window) -> Rect {
        unsafe {
            self.0
                .get_initial_bounds
                .map(|f| {
                    let arg_window = window;
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window.as_raw();
                    let result = f(arg_self_, arg_window);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_initial_show_state<'a>(&self, window: &'a mut Window) -> ShowState {
        unsafe {
            self.0
                .get_initial_show_state
                .map(|f| {
                    let arg_window = window;
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window.as_raw();
                    let result = f(arg_self_, arg_window);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_frameless<'a>(&self, window: &'a mut Window) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_frameless
                .map(|f| {
                    let arg_window = window;
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window.as_raw();
                    let result = f(arg_self_, arg_window);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn with_standard_window_buttons<'a>(&self, window: &'a mut Window) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .with_standard_window_buttons
                .map(|f| {
                    let arg_window = window;
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window.as_raw();
                    let result = f(arg_self_, arg_window);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_titlebar_height<'a>(
        &self,
        window: &'a mut Window,
        titlebar_height: *mut f32,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_titlebar_height
                .map(|f| {
                    let (arg_window, arg_titlebar_height) = (window, titlebar_height);
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window.as_raw();
                    let arg_titlebar_height = arg_titlebar_height as *mut _;
                    let result = f(arg_self_, arg_window, arg_titlebar_height);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn accepts_first_mouse<'a>(&self, window: &'a mut Window) -> State {
        unsafe {
            self.0
                .accepts_first_mouse
                .map(|f| {
                    let arg_window = window;
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window.as_raw();
                    let result = f(arg_self_, arg_window);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn can_resize<'a>(&self, window: &'a mut Window) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .can_resize
                .map(|f| {
                    let arg_window = window;
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window.as_raw();
                    let result = f(arg_self_, arg_window);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn can_maximize<'a>(&self, window: &'a mut Window) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .can_maximize
                .map(|f| {
                    let arg_window = window;
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window.as_raw();
                    let result = f(arg_self_, arg_window);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn can_minimize<'a>(&self, window: &'a mut Window) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .can_minimize
                .map(|f| {
                    let arg_window = window;
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window.as_raw();
                    let result = f(arg_self_, arg_window);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn can_close<'a>(&self, window: &'a mut Window) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .can_close
                .map(|f| {
                    let arg_window = window;
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window.as_raw();
                    let result = f(arg_self_, arg_window);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_accelerator<'a>(
        &self,
        window: &'a mut Window,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_accelerator
                .map(|f| {
                    let (arg_window, arg_command_id) = (window, command_id);
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window.as_raw();
                    let arg_command_id = arg_command_id;
                    let result = f(arg_self_, arg_window, arg_command_id);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_key_event<'a>(
        &self,
        window: &'a mut Window,
        event: &'a KeyEvent,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_key_event
                .map(|f| {
                    let (arg_window, arg_event) = (window, event);
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window.as_raw();
                    let mut arg_event: _cef_key_event_t = arg_event.clone().into();
                    let arg_event = &mut arg_event;
                    let result = f(arg_self_, arg_window, arg_event);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn on_theme_colors_changed<'a>(
        &self,
        window: &'a mut Window,
        chrome_theme: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .on_theme_colors_changed
                .map(|f| {
                    let (arg_window, arg_chrome_theme) = (window, chrome_theme);
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window.as_raw();
                    let arg_chrome_theme = arg_chrome_theme;
                    let result = f(arg_self_, arg_window, arg_chrome_theme);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_window_runtime_style<'a>(&self) -> RuntimeStyle {
        unsafe {
            self.0
                .get_window_runtime_style
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_linux_window_properties<'a>(
        &self,
        window: &'a mut Window,
        properties: &'a mut LinuxWindowProperties,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_linux_window_properties
                .map(|f| {
                    let (arg_window, arg_properties) = (window, properties);
                    let arg_self_ = self.as_raw();
                    let arg_window = arg_window.as_raw();
                    let mut arg_properties: _cef_linux_window_properties_t =
                        arg_properties.clone().into();
                    let arg_properties = &mut arg_properties;
                    let result = f(arg_self_, arg_window, arg_properties);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_window_delegate_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for WindowDelegate {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_window_delegate_t> for &WindowDelegate {
    fn as_raw(self) -> *mut _cef_window_delegate_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_window_delegate_t> for &mut WindowDelegate {
    fn as_raw(self) -> *mut _cef_window_delegate_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<WindowDelegate> for *mut _cef_window_delegate_t {
    fn as_wrapper(self) -> WindowDelegate {
        WindowDelegate(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_window_delegate_t> for WindowDelegate {
    fn into(self) -> *mut _cef_window_delegate_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for WindowDelegate {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
pub trait ImplWindow: ImplPanel {
    fn show<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn show_as_browser_modal_dialog<'a>(&self, browser_view: &'a mut BrowserView) {
        unsafe { std::mem::zeroed() }
    }
    fn hide<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn center_window<'a>(&self, size: &'a Size) {
        unsafe { std::mem::zeroed() }
    }
    fn close<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn is_closed<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn activate<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn deactivate<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn is_active<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn bring_to_top<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn set_always_on_top<'a>(&self, on_top: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn is_always_on_top<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn maximize<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn minimize<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn restore<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn set_fullscreen<'a>(&self, fullscreen: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn is_maximized<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_minimized<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn is_fullscreen<'a>(&self) -> ::std::os::raw::c_int {
        unsafe { std::mem::zeroed() }
    }
    fn get_focused_view<'a>(&self) -> View {
        unsafe { std::mem::zeroed() }
    }
    fn set_title<'a>(&self, title: &'a CefStringUtf16) {
        unsafe { std::mem::zeroed() }
    }
    fn get_title<'a>(&self) -> CefStringUtf16 {
        unsafe { std::mem::zeroed() }
    }
    fn set_window_icon<'a>(&self, image: &'a mut Image) {
        unsafe { std::mem::zeroed() }
    }
    fn get_window_icon<'a>(&self) -> Image {
        unsafe { std::mem::zeroed() }
    }
    fn set_window_app_icon<'a>(&self, image: &'a mut Image) {
        unsafe { std::mem::zeroed() }
    }
    fn get_window_app_icon<'a>(&self) -> Image {
        unsafe { std::mem::zeroed() }
    }
    fn add_overlay_view<'a>(
        &self,
        view: &'a mut View,
        docking_mode: DockingMode,
        can_activate: ::std::os::raw::c_int,
    ) -> OverlayController {
        unsafe { std::mem::zeroed() }
    }
    fn show_menu<'a>(
        &self,
        menu_model: &'a mut MenuModel,
        screen_point: &'a Point,
        anchor_position: MenuAnchorPosition,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn cancel_menu<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn get_display<'a>(&self) -> Display {
        unsafe { std::mem::zeroed() }
    }
    fn get_client_area_bounds_in_screen<'a>(&self) -> Rect {
        unsafe { std::mem::zeroed() }
    }
    fn set_draggable_regions<'a>(&self, regions_count: usize, regions: &'a DraggableRegion) {
        unsafe { std::mem::zeroed() }
    }
    fn get_window_handle<'a>(&self) -> ::std::os::raw::c_ulong {
        unsafe { std::mem::zeroed() }
    }
    fn send_key_press<'a>(&self, key_code: ::std::os::raw::c_int, event_flags: u32) {
        unsafe { std::mem::zeroed() }
    }
    fn send_mouse_move<'a>(
        &self,
        screen_x: ::std::os::raw::c_int,
        screen_y: ::std::os::raw::c_int,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn send_mouse_events<'a>(
        &self,
        button: MouseButtonType,
        mouse_down: ::std::os::raw::c_int,
        mouse_up: ::std::os::raw::c_int,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn set_accelerator<'a>(
        &self,
        command_id: ::std::os::raw::c_int,
        key_code: ::std::os::raw::c_int,
        shift_pressed: ::std::os::raw::c_int,
        ctrl_pressed: ::std::os::raw::c_int,
        alt_pressed: ::std::os::raw::c_int,
        high_priority: ::std::os::raw::c_int,
    ) {
        unsafe { std::mem::zeroed() }
    }
    fn remove_accelerator<'a>(&self, command_id: ::std::os::raw::c_int) {
        unsafe { std::mem::zeroed() }
    }
    fn remove_all_accelerators<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn set_theme_color<'a>(&self, color_id: ::std::os::raw::c_int, color: u32) {
        unsafe { std::mem::zeroed() }
    }
    fn theme_changed<'a>(&self) {
        unsafe { std::mem::zeroed() }
    }
    fn get_runtime_style<'a>(&self) -> RuntimeStyle {
        unsafe { std::mem::zeroed() }
    }
    fn into_raw(self) -> *mut _cef_window_t {
        let mut object: _cef_window_t = unsafe { std::mem::zeroed() };
        impl_cef_view_t::init_methods::<Self>(&mut object.base.base);
        impl_cef_panel_t::init_methods::<Self>(&mut object.base);
        impl_cef_window_t::init_methods::<Self>(&mut object);
        RcImpl::new(object, self) as *mut _
    }
}
mod impl_cef_window_t {
    use super::*;
    pub fn init_methods<I: ImplWindow>(object: &mut _cef_window_t) {
        object.show = Some(show::<I>);
        object.show_as_browser_modal_dialog = Some(show_as_browser_modal_dialog::<I>);
        object.hide = Some(hide::<I>);
        object.center_window = Some(center_window::<I>);
        object.close = Some(close::<I>);
        object.is_closed = Some(is_closed::<I>);
        object.activate = Some(activate::<I>);
        object.deactivate = Some(deactivate::<I>);
        object.is_active = Some(is_active::<I>);
        object.bring_to_top = Some(bring_to_top::<I>);
        object.set_always_on_top = Some(set_always_on_top::<I>);
        object.is_always_on_top = Some(is_always_on_top::<I>);
        object.maximize = Some(maximize::<I>);
        object.minimize = Some(minimize::<I>);
        object.restore = Some(restore::<I>);
        object.set_fullscreen = Some(set_fullscreen::<I>);
        object.is_maximized = Some(is_maximized::<I>);
        object.is_minimized = Some(is_minimized::<I>);
        object.is_fullscreen = Some(is_fullscreen::<I>);
        object.get_focused_view = Some(get_focused_view::<I>);
        object.set_title = Some(set_title::<I>);
        object.get_title = Some(get_title::<I>);
        object.set_window_icon = Some(set_window_icon::<I>);
        object.get_window_icon = Some(get_window_icon::<I>);
        object.set_window_app_icon = Some(set_window_app_icon::<I>);
        object.get_window_app_icon = Some(get_window_app_icon::<I>);
        object.add_overlay_view = Some(add_overlay_view::<I>);
        object.show_menu = Some(show_menu::<I>);
        object.cancel_menu = Some(cancel_menu::<I>);
        object.get_display = Some(get_display::<I>);
        object.get_client_area_bounds_in_screen = Some(get_client_area_bounds_in_screen::<I>);
        object.set_draggable_regions = Some(set_draggable_regions::<I>);
        object.get_window_handle = Some(get_window_handle::<I>);
        object.send_key_press = Some(send_key_press::<I>);
        object.send_mouse_move = Some(send_mouse_move::<I>);
        object.send_mouse_events = Some(send_mouse_events::<I>);
        object.set_accelerator = Some(set_accelerator::<I>);
        object.remove_accelerator = Some(remove_accelerator::<I>);
        object.remove_all_accelerators = Some(remove_all_accelerators::<I>);
        object.set_theme_color = Some(set_theme_color::<I>);
        object.theme_changed = Some(theme_changed::<I>);
        object.get_runtime_style = Some(get_runtime_style::<I>);
    }
    extern "C" fn show<I: ImplWindow>(self_: *mut _cef_window_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.show()
    }
    extern "C" fn show_as_browser_modal_dialog<I: ImplWindow>(
        self_: *mut _cef_window_t,
        browser_view: *mut _cef_browser_view_t,
    ) {
        let (arg_self_, arg_browser_view) = (self_, browser_view);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_browser_view =
            &mut BrowserView(unsafe { RefGuard::from_raw_add_ref(arg_browser_view) });
        arg_self_
            .interface
            .show_as_browser_modal_dialog(arg_browser_view)
    }
    extern "C" fn hide<I: ImplWindow>(self_: *mut _cef_window_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.hide()
    }
    extern "C" fn center_window<I: ImplWindow>(
        self_: *mut _cef_window_t,
        size: *const _cef_size_t,
    ) {
        let (arg_self_, arg_size) = (self_, size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_size = WrapParamRef::<Size>::from(arg_size);
        let arg_size = arg_size.as_ref();
        arg_self_.interface.center_window(arg_size)
    }
    extern "C" fn close<I: ImplWindow>(self_: *mut _cef_window_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.close()
    }
    extern "C" fn is_closed<I: ImplWindow>(self_: *mut _cef_window_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_closed().into()
    }
    extern "C" fn activate<I: ImplWindow>(self_: *mut _cef_window_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.activate()
    }
    extern "C" fn deactivate<I: ImplWindow>(self_: *mut _cef_window_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.deactivate()
    }
    extern "C" fn is_active<I: ImplWindow>(self_: *mut _cef_window_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_active().into()
    }
    extern "C" fn bring_to_top<I: ImplWindow>(self_: *mut _cef_window_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.bring_to_top()
    }
    extern "C" fn set_always_on_top<I: ImplWindow>(
        self_: *mut _cef_window_t,
        on_top: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_on_top) = (self_, on_top);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_on_top = arg_on_top.as_raw();
        arg_self_.interface.set_always_on_top(arg_on_top)
    }
    extern "C" fn is_always_on_top<I: ImplWindow>(
        self_: *mut _cef_window_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_always_on_top().into()
    }
    extern "C" fn maximize<I: ImplWindow>(self_: *mut _cef_window_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.maximize()
    }
    extern "C" fn minimize<I: ImplWindow>(self_: *mut _cef_window_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.minimize()
    }
    extern "C" fn restore<I: ImplWindow>(self_: *mut _cef_window_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.restore()
    }
    extern "C" fn set_fullscreen<I: ImplWindow>(
        self_: *mut _cef_window_t,
        fullscreen: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_fullscreen) = (self_, fullscreen);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_fullscreen = arg_fullscreen.as_raw();
        arg_self_.interface.set_fullscreen(arg_fullscreen)
    }
    extern "C" fn is_maximized<I: ImplWindow>(self_: *mut _cef_window_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_maximized().into()
    }
    extern "C" fn is_minimized<I: ImplWindow>(self_: *mut _cef_window_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_minimized().into()
    }
    extern "C" fn is_fullscreen<I: ImplWindow>(self_: *mut _cef_window_t) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.is_fullscreen().into()
    }
    extern "C" fn get_focused_view<I: ImplWindow>(self_: *mut _cef_window_t) -> *mut _cef_view_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_focused_view().into()
    }
    extern "C" fn set_title<I: ImplWindow>(
        self_: *mut _cef_window_t,
        title: *const _cef_string_utf16_t,
    ) {
        let (arg_self_, arg_title) = (self_, title);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_title = WrapParamRef::<CefStringUtf16>::from(arg_title);
        let arg_title = arg_title.as_ref();
        arg_self_.interface.set_title(arg_title)
    }
    extern "C" fn get_title<I: ImplWindow>(self_: *mut _cef_window_t) -> *mut _cef_string_utf16_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_title().into()
    }
    extern "C" fn set_window_icon<I: ImplWindow>(
        self_: *mut _cef_window_t,
        image: *mut _cef_image_t,
    ) {
        let (arg_self_, arg_image) = (self_, image);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_image = &mut Image(unsafe { RefGuard::from_raw_add_ref(arg_image) });
        arg_self_.interface.set_window_icon(arg_image)
    }
    extern "C" fn get_window_icon<I: ImplWindow>(self_: *mut _cef_window_t) -> *mut _cef_image_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_window_icon().into()
    }
    extern "C" fn set_window_app_icon<I: ImplWindow>(
        self_: *mut _cef_window_t,
        image: *mut _cef_image_t,
    ) {
        let (arg_self_, arg_image) = (self_, image);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_image = &mut Image(unsafe { RefGuard::from_raw_add_ref(arg_image) });
        arg_self_.interface.set_window_app_icon(arg_image)
    }
    extern "C" fn get_window_app_icon<I: ImplWindow>(
        self_: *mut _cef_window_t,
    ) -> *mut _cef_image_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_window_app_icon().into()
    }
    extern "C" fn add_overlay_view<I: ImplWindow>(
        self_: *mut _cef_window_t,
        view: *mut _cef_view_t,
        docking_mode: cef_docking_mode_t,
        can_activate: ::std::os::raw::c_int,
    ) -> *mut _cef_overlay_controller_t {
        let (arg_self_, arg_view, arg_docking_mode, arg_can_activate) =
            (self_, view, docking_mode, can_activate);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_view = &mut View(unsafe { RefGuard::from_raw_add_ref(arg_view) });
        let arg_docking_mode = arg_docking_mode.as_raw();
        let arg_can_activate = arg_can_activate.as_raw();
        arg_self_
            .interface
            .add_overlay_view(arg_view, arg_docking_mode, arg_can_activate)
            .into()
    }
    extern "C" fn show_menu<I: ImplWindow>(
        self_: *mut _cef_window_t,
        menu_model: *mut _cef_menu_model_t,
        screen_point: *const _cef_point_t,
        anchor_position: cef_menu_anchor_position_t,
    ) {
        let (arg_self_, arg_menu_model, arg_screen_point, arg_anchor_position) =
            (self_, menu_model, screen_point, anchor_position);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_menu_model = &mut MenuModel(unsafe { RefGuard::from_raw_add_ref(arg_menu_model) });
        let arg_screen_point = WrapParamRef::<Point>::from(arg_screen_point);
        let arg_screen_point = arg_screen_point.as_ref();
        let arg_anchor_position = arg_anchor_position.as_raw();
        arg_self_
            .interface
            .show_menu(arg_menu_model, arg_screen_point, arg_anchor_position)
    }
    extern "C" fn cancel_menu<I: ImplWindow>(self_: *mut _cef_window_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.cancel_menu()
    }
    extern "C" fn get_display<I: ImplWindow>(self_: *mut _cef_window_t) -> *mut _cef_display_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_display().into()
    }
    extern "C" fn get_client_area_bounds_in_screen<I: ImplWindow>(
        self_: *mut _cef_window_t,
    ) -> _cef_rect_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_
            .interface
            .get_client_area_bounds_in_screen()
            .into()
    }
    extern "C" fn set_draggable_regions<I: ImplWindow>(
        self_: *mut _cef_window_t,
        regions_count: usize,
        regions: *const _cef_draggable_region_t,
    ) {
        let (arg_self_, arg_regions_count, arg_regions) = (self_, regions_count, regions);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_regions_count = arg_regions_count.as_raw();
        let arg_regions = WrapParamRef::<DraggableRegion>::from(arg_regions);
        let arg_regions = arg_regions.as_ref();
        arg_self_
            .interface
            .set_draggable_regions(arg_regions_count, arg_regions)
    }
    extern "C" fn get_window_handle<I: ImplWindow>(
        self_: *mut _cef_window_t,
    ) -> ::std::os::raw::c_ulong {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_window_handle().into()
    }
    extern "C" fn send_key_press<I: ImplWindow>(
        self_: *mut _cef_window_t,
        key_code: ::std::os::raw::c_int,
        event_flags: u32,
    ) {
        let (arg_self_, arg_key_code, arg_event_flags) = (self_, key_code, event_flags);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_key_code = arg_key_code.as_raw();
        let arg_event_flags = arg_event_flags.as_raw();
        arg_self_
            .interface
            .send_key_press(arg_key_code, arg_event_flags)
    }
    extern "C" fn send_mouse_move<I: ImplWindow>(
        self_: *mut _cef_window_t,
        screen_x: ::std::os::raw::c_int,
        screen_y: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_screen_x, arg_screen_y) = (self_, screen_x, screen_y);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_screen_x = arg_screen_x.as_raw();
        let arg_screen_y = arg_screen_y.as_raw();
        arg_self_
            .interface
            .send_mouse_move(arg_screen_x, arg_screen_y)
    }
    extern "C" fn send_mouse_events<I: ImplWindow>(
        self_: *mut _cef_window_t,
        button: cef_mouse_button_type_t,
        mouse_down: ::std::os::raw::c_int,
        mouse_up: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_button, arg_mouse_down, arg_mouse_up) =
            (self_, button, mouse_down, mouse_up);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_button = arg_button.as_raw();
        let arg_mouse_down = arg_mouse_down.as_raw();
        let arg_mouse_up = arg_mouse_up.as_raw();
        arg_self_
            .interface
            .send_mouse_events(arg_button, arg_mouse_down, arg_mouse_up)
    }
    extern "C" fn set_accelerator<I: ImplWindow>(
        self_: *mut _cef_window_t,
        command_id: ::std::os::raw::c_int,
        key_code: ::std::os::raw::c_int,
        shift_pressed: ::std::os::raw::c_int,
        ctrl_pressed: ::std::os::raw::c_int,
        alt_pressed: ::std::os::raw::c_int,
        high_priority: ::std::os::raw::c_int,
    ) {
        let (
            arg_self_,
            arg_command_id,
            arg_key_code,
            arg_shift_pressed,
            arg_ctrl_pressed,
            arg_alt_pressed,
            arg_high_priority,
        ) = (
            self_,
            command_id,
            key_code,
            shift_pressed,
            ctrl_pressed,
            alt_pressed,
            high_priority,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        let arg_key_code = arg_key_code.as_raw();
        let arg_shift_pressed = arg_shift_pressed.as_raw();
        let arg_ctrl_pressed = arg_ctrl_pressed.as_raw();
        let arg_alt_pressed = arg_alt_pressed.as_raw();
        let arg_high_priority = arg_high_priority.as_raw();
        arg_self_.interface.set_accelerator(
            arg_command_id,
            arg_key_code,
            arg_shift_pressed,
            arg_ctrl_pressed,
            arg_alt_pressed,
            arg_high_priority,
        )
    }
    extern "C" fn remove_accelerator<I: ImplWindow>(
        self_: *mut _cef_window_t,
        command_id: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_command_id) = (self_, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_command_id = arg_command_id.as_raw();
        arg_self_.interface.remove_accelerator(arg_command_id)
    }
    extern "C" fn remove_all_accelerators<I: ImplWindow>(self_: *mut _cef_window_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.remove_all_accelerators()
    }
    extern "C" fn set_theme_color<I: ImplWindow>(
        self_: *mut _cef_window_t,
        color_id: ::std::os::raw::c_int,
        color: u32,
    ) {
        let (arg_self_, arg_color_id, arg_color) = (self_, color_id, color);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_color_id = arg_color_id.as_raw();
        let arg_color = arg_color.as_raw();
        arg_self_.interface.set_theme_color(arg_color_id, arg_color)
    }
    extern "C" fn theme_changed<I: ImplWindow>(self_: *mut _cef_window_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.theme_changed()
    }
    extern "C" fn get_runtime_style<I: ImplWindow>(
        self_: *mut _cef_window_t,
    ) -> cef_runtime_style_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        arg_self_.interface.get_runtime_style().into()
    }
}
#[doc = "See [_cef_window_t] for more documentation."]
#[derive(Clone)]
pub struct Window(RefGuard<_cef_window_t>);
impl ImplView for Window {
    fn as_browser_view<'a>(&self) -> BrowserView {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_browser_view()
    }
    fn as_button<'a>(&self) -> Button {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).as_button()
    }
    fn as_panel<'a>(&self) -> Panel {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).as_panel()
    }
    fn as_scroll_view<'a>(&self) -> ScrollView {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_scroll_view()
    }
    fn as_textfield<'a>(&self) -> Textfield {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_textfield()
    }
    fn get_type_string<'a>(&self) -> CefStringUtf16 {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_type_string()
    }
    fn to_string<'a>(&self, include_children: ::std::os::raw::c_int) -> CefStringUtf16 {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .to_string(include_children)
    }
    fn is_valid<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).is_valid()
    }
    fn is_attached<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_attached()
    }
    fn is_same<'a>(&self, that: &'a mut View) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_same(that)
    }
    fn get_delegate<'a>(&self) -> ViewDelegate {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_delegate()
    }
    fn get_window<'a>(&self) -> Window {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_window()
    }
    fn get_id<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).get_id()
    }
    fn set_id<'a>(&self, id: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).set_id(id)
    }
    fn get_group_id<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_group_id()
    }
    fn set_group_id<'a>(&self, group_id: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_group_id(group_id)
    }
    fn get_parent_view<'a>(&self) -> View {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_parent_view()
    }
    fn get_view_for_id<'a>(&self, id: ::std::os::raw::c_int) -> View {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_view_for_id(id)
    }
    fn set_bounds<'a>(&self, bounds: &'a Rect) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_bounds(bounds)
    }
    fn get_bounds<'a>(&self) -> Rect {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_bounds()
    }
    fn get_bounds_in_screen<'a>(&self) -> Rect {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_bounds_in_screen()
    }
    fn set_size<'a>(&self, size: &'a Size) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_size(size)
    }
    fn get_size<'a>(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).get_size()
    }
    fn set_position<'a>(&self, position: &'a Point) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_position(position)
    }
    fn get_position<'a>(&self) -> Point {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_position()
    }
    fn set_insets<'a>(&self, insets: &'a Insets) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_insets(insets)
    }
    fn get_insets<'a>(&self) -> Insets {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_insets()
    }
    fn get_preferred_size<'a>(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_preferred_size()
    }
    fn size_to_preferred_size<'a>(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .size_to_preferred_size()
    }
    fn get_minimum_size<'a>(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_minimum_size()
    }
    fn get_maximum_size<'a>(&self) -> Size {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_maximum_size()
    }
    fn get_height_for_width<'a>(&self, width: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_height_for_width(width)
    }
    fn invalidate_layout<'a>(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .invalidate_layout()
    }
    fn set_visible<'a>(&self, visible: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_visible(visible)
    }
    fn is_visible<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_visible()
    }
    fn is_drawn<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).is_drawn()
    }
    fn set_enabled<'a>(&self, enabled: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_enabled(enabled)
    }
    fn is_enabled<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_enabled()
    }
    fn set_focusable<'a>(&self, focusable: ::std::os::raw::c_int) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_focusable(focusable)
    }
    fn is_focusable<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_focusable()
    }
    fn is_accessibility_focusable<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .is_accessibility_focusable()
    }
    fn has_focus<'a>(&self) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).has_focus()
    }
    fn request_focus<'a>(&self) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .request_focus()
    }
    fn set_background_color<'a>(&self, color: u32) {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_background_color(color)
    }
    fn get_background_color<'a>(&self) -> cef_color_t {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_background_color()
    }
    fn get_theme_color<'a>(&self, color_id: ::std::os::raw::c_int) -> cef_color_t {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_theme_color(color_id)
    }
    fn convert_point_to_screen<'a>(&self, point: &'a mut Point) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_screen(point)
    }
    fn convert_point_from_screen<'a>(&self, point: &'a mut Point) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_screen(point)
    }
    fn convert_point_to_window<'a>(&self, point: &'a mut Point) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_window(point)
    }
    fn convert_point_from_window<'a>(&self, point: &'a mut Point) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_window(point)
    }
    fn convert_point_to_view<'a>(
        &self,
        view: &'a mut View,
        point: &'a mut Point,
    ) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_to_view(view, point)
    }
    fn convert_point_from_view<'a>(
        &self,
        view: &'a mut View,
        point: &'a mut Point,
    ) -> ::std::os::raw::c_int {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .convert_point_from_view(view, point)
    }
}
impl ImplPanel for Window {
    fn as_window<'a>(&self) -> Window {
        Panel(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .as_window()
    }
    fn set_to_fill_layout<'a>(&self) -> FillLayout {
        Panel(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_to_fill_layout()
    }
    fn set_to_box_layout<'a>(&self, settings: &'a BoxLayoutSettings) -> BoxLayout {
        Panel(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .set_to_box_layout(settings)
    }
    fn get_layout<'a>(&self) -> Layout {
        Panel(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_layout()
    }
    fn layout<'a>(&self) {
        Panel(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) }).layout()
    }
    fn add_child_view<'a>(&self, view: &'a mut View) {
        Panel(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .add_child_view(view)
    }
    fn add_child_view_at<'a>(&self, view: &'a mut View, index: ::std::os::raw::c_int) {
        Panel(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .add_child_view_at(view, index)
    }
    fn reorder_child_view<'a>(&self, view: &'a mut View, index: ::std::os::raw::c_int) {
        Panel(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .reorder_child_view(view, index)
    }
    fn remove_child_view<'a>(&self, view: &'a mut View) {
        Panel(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .remove_child_view(view)
    }
    fn remove_all_child_views<'a>(&self) {
        Panel(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .remove_all_child_views()
    }
    fn get_child_view_count<'a>(&self) -> usize {
        Panel(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_child_view_count()
    }
    fn get_child_view_at<'a>(&self, index: ::std::os::raw::c_int) -> View {
        Panel(unsafe { RefGuard::from_raw_add_ref(RefGuard::as_raw(&self.0) as *mut _) })
            .get_child_view_at(index)
    }
}
impl ImplWindow for Window {
    fn show<'a>(&self) {
        unsafe {
            self.0
                .show
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn show_as_browser_modal_dialog<'a>(&self, browser_view: &'a mut BrowserView) {
        unsafe {
            self.0
                .show_as_browser_modal_dialog
                .map(|f| {
                    let arg_browser_view = browser_view;
                    let arg_self_ = self.as_raw();
                    let arg_browser_view = arg_browser_view.as_raw();
                    let result = f(arg_self_, arg_browser_view);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn hide<'a>(&self) {
        unsafe {
            self.0
                .hide
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn center_window<'a>(&self, size: &'a Size) {
        unsafe {
            self.0
                .center_window
                .map(|f| {
                    let arg_size = size;
                    let arg_self_ = self.as_raw();
                    let mut arg_size: _cef_size_t = arg_size.clone().into();
                    let arg_size = &mut arg_size;
                    let result = f(arg_self_, arg_size);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn close<'a>(&self) {
        unsafe {
            self.0
                .close
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_closed<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_closed
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn activate<'a>(&self) {
        unsafe {
            self.0
                .activate
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn deactivate<'a>(&self) {
        unsafe {
            self.0
                .deactivate
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_active<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_active
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn bring_to_top<'a>(&self) {
        unsafe {
            self.0
                .bring_to_top
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_always_on_top<'a>(&self, on_top: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_always_on_top
                .map(|f| {
                    let arg_on_top = on_top;
                    let arg_self_ = self.as_raw();
                    let arg_on_top = arg_on_top;
                    let result = f(arg_self_, arg_on_top);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_always_on_top<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_always_on_top
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn maximize<'a>(&self) {
        unsafe {
            self.0
                .maximize
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn minimize<'a>(&self) {
        unsafe {
            self.0
                .minimize
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn restore<'a>(&self) {
        unsafe {
            self.0
                .restore
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_fullscreen<'a>(&self, fullscreen: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .set_fullscreen
                .map(|f| {
                    let arg_fullscreen = fullscreen;
                    let arg_self_ = self.as_raw();
                    let arg_fullscreen = arg_fullscreen;
                    let result = f(arg_self_, arg_fullscreen);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_maximized<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_maximized
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_minimized<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_minimized
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn is_fullscreen<'a>(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_fullscreen
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_focused_view<'a>(&self) -> View {
        unsafe {
            self.0
                .get_focused_view
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_title<'a>(&self, title: &'a CefStringUtf16) {
        unsafe {
            self.0
                .set_title
                .map(|f| {
                    let arg_title = title;
                    let arg_self_ = self.as_raw();
                    let arg_title = arg_title.as_raw();
                    let result = f(arg_self_, arg_title);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_title<'a>(&self) -> CefStringUtf16 {
        unsafe {
            self.0
                .get_title
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_window_icon<'a>(&self, image: &'a mut Image) {
        unsafe {
            self.0
                .set_window_icon
                .map(|f| {
                    let arg_image = image;
                    let arg_self_ = self.as_raw();
                    let arg_image = arg_image.as_raw();
                    let result = f(arg_self_, arg_image);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_window_icon<'a>(&self) -> Image {
        unsafe {
            self.0
                .get_window_icon
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_window_app_icon<'a>(&self, image: &'a mut Image) {
        unsafe {
            self.0
                .set_window_app_icon
                .map(|f| {
                    let arg_image = image;
                    let arg_self_ = self.as_raw();
                    let arg_image = arg_image.as_raw();
                    let result = f(arg_self_, arg_image);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_window_app_icon<'a>(&self) -> Image {
        unsafe {
            self.0
                .get_window_app_icon
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn add_overlay_view<'a>(
        &self,
        view: &'a mut View,
        docking_mode: DockingMode,
        can_activate: ::std::os::raw::c_int,
    ) -> OverlayController {
        unsafe {
            self.0
                .add_overlay_view
                .map(|f| {
                    let (arg_view, arg_docking_mode, arg_can_activate) =
                        (view, docking_mode, can_activate);
                    let arg_self_ = self.as_raw();
                    let arg_view = arg_view.as_raw();
                    let arg_docking_mode = arg_docking_mode.as_raw();
                    let arg_can_activate = arg_can_activate;
                    let result = f(arg_self_, arg_view, arg_docking_mode, arg_can_activate);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn show_menu<'a>(
        &self,
        menu_model: &'a mut MenuModel,
        screen_point: &'a Point,
        anchor_position: MenuAnchorPosition,
    ) {
        unsafe {
            self.0
                .show_menu
                .map(|f| {
                    let (arg_menu_model, arg_screen_point, arg_anchor_position) =
                        (menu_model, screen_point, anchor_position);
                    let arg_self_ = self.as_raw();
                    let arg_menu_model = arg_menu_model.as_raw();
                    let mut arg_screen_point: _cef_point_t = arg_screen_point.clone().into();
                    let arg_screen_point = &mut arg_screen_point;
                    let arg_anchor_position = arg_anchor_position.as_raw();
                    let result = f(
                        arg_self_,
                        arg_menu_model,
                        arg_screen_point,
                        arg_anchor_position,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn cancel_menu<'a>(&self) {
        unsafe {
            self.0
                .cancel_menu
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_display<'a>(&self) -> Display {
        unsafe {
            self.0
                .get_display
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_client_area_bounds_in_screen<'a>(&self) -> Rect {
        unsafe {
            self.0
                .get_client_area_bounds_in_screen
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_draggable_regions<'a>(&self, regions_count: usize, regions: &'a DraggableRegion) {
        unsafe {
            self.0
                .set_draggable_regions
                .map(|f| {
                    let (arg_regions_count, arg_regions) = (regions_count, regions);
                    let arg_self_ = self.as_raw();
                    let arg_regions_count = arg_regions_count;
                    let mut arg_regions: _cef_draggable_region_t = arg_regions.clone().into();
                    let arg_regions = &mut arg_regions;
                    let result = f(arg_self_, arg_regions_count, arg_regions);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_window_handle<'a>(&self) -> ::std::os::raw::c_ulong {
        unsafe {
            self.0
                .get_window_handle
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn send_key_press<'a>(&self, key_code: ::std::os::raw::c_int, event_flags: u32) {
        unsafe {
            self.0
                .send_key_press
                .map(|f| {
                    let (arg_key_code, arg_event_flags) = (key_code, event_flags);
                    let arg_self_ = self.as_raw();
                    let arg_key_code = arg_key_code;
                    let arg_event_flags = arg_event_flags;
                    let result = f(arg_self_, arg_key_code, arg_event_flags);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn send_mouse_move<'a>(
        &self,
        screen_x: ::std::os::raw::c_int,
        screen_y: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .send_mouse_move
                .map(|f| {
                    let (arg_screen_x, arg_screen_y) = (screen_x, screen_y);
                    let arg_self_ = self.as_raw();
                    let arg_screen_x = arg_screen_x;
                    let arg_screen_y = arg_screen_y;
                    let result = f(arg_self_, arg_screen_x, arg_screen_y);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn send_mouse_events<'a>(
        &self,
        button: MouseButtonType,
        mouse_down: ::std::os::raw::c_int,
        mouse_up: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .send_mouse_events
                .map(|f| {
                    let (arg_button, arg_mouse_down, arg_mouse_up) = (button, mouse_down, mouse_up);
                    let arg_self_ = self.as_raw();
                    let arg_button = arg_button.as_raw();
                    let arg_mouse_down = arg_mouse_down;
                    let arg_mouse_up = arg_mouse_up;
                    let result = f(arg_self_, arg_button, arg_mouse_down, arg_mouse_up);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_accelerator<'a>(
        &self,
        command_id: ::std::os::raw::c_int,
        key_code: ::std::os::raw::c_int,
        shift_pressed: ::std::os::raw::c_int,
        ctrl_pressed: ::std::os::raw::c_int,
        alt_pressed: ::std::os::raw::c_int,
        high_priority: ::std::os::raw::c_int,
    ) {
        unsafe {
            self.0
                .set_accelerator
                .map(|f| {
                    let (
                        arg_command_id,
                        arg_key_code,
                        arg_shift_pressed,
                        arg_ctrl_pressed,
                        arg_alt_pressed,
                        arg_high_priority,
                    ) = (
                        command_id,
                        key_code,
                        shift_pressed,
                        ctrl_pressed,
                        alt_pressed,
                        high_priority,
                    );
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let arg_key_code = arg_key_code;
                    let arg_shift_pressed = arg_shift_pressed;
                    let arg_ctrl_pressed = arg_ctrl_pressed;
                    let arg_alt_pressed = arg_alt_pressed;
                    let arg_high_priority = arg_high_priority;
                    let result = f(
                        arg_self_,
                        arg_command_id,
                        arg_key_code,
                        arg_shift_pressed,
                        arg_ctrl_pressed,
                        arg_alt_pressed,
                        arg_high_priority,
                    );
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn remove_accelerator<'a>(&self, command_id: ::std::os::raw::c_int) {
        unsafe {
            self.0
                .remove_accelerator
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.as_raw();
                    let arg_command_id = arg_command_id;
                    let result = f(arg_self_, arg_command_id);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn remove_all_accelerators<'a>(&self) {
        unsafe {
            self.0
                .remove_all_accelerators
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn set_theme_color<'a>(&self, color_id: ::std::os::raw::c_int, color: u32) {
        unsafe {
            self.0
                .set_theme_color
                .map(|f| {
                    let (arg_color_id, arg_color) = (color_id, color);
                    let arg_self_ = self.as_raw();
                    let arg_color_id = arg_color_id;
                    let arg_color = arg_color;
                    let result = f(arg_self_, arg_color_id, arg_color);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn theme_changed<'a>(&self) {
        unsafe {
            self.0
                .theme_changed
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_runtime_style<'a>(&self) -> RuntimeStyle {
        unsafe {
            self.0
                .get_runtime_style
                .map(|f| {
                    let arg_self_ = self.as_raw();
                    let result = f(arg_self_);
                    result.as_wrapper()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
}
impl Rc for _cef_window_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Window {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_window_t> for &Window {
    fn as_raw(self) -> *mut _cef_window_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertParam<*mut _cef_window_t> for &mut Window {
    fn as_raw(self) -> *mut _cef_window_t {
        unsafe { (&self.0).as_raw() }
    }
}
impl ConvertReturnValue<Window> for *mut _cef_window_t {
    fn as_wrapper(self) -> Window {
        Window(unsafe { RefGuard::from_raw(self) })
    }
}
impl Into<*mut _cef_window_t> for Window {
    fn into(self) -> *mut _cef_window_t {
        unsafe { self.0.into_raw() }
    }
}
impl Default for Window {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

// Enum aliases
#[doc = "See [cef_content_setting_types_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ContentSettingTypes(cef_content_setting_types_t);
impl AsRef<cef_content_setting_types_t> for ContentSettingTypes {
    fn as_ref(&self) -> &cef_content_setting_types_t {
        &self.0
    }
}
impl AsMut<cef_content_setting_types_t> for ContentSettingTypes {
    fn as_mut(&mut self) -> &mut cef_content_setting_types_t {
        &mut self.0
    }
}
impl From<cef_content_setting_types_t> for ContentSettingTypes {
    fn from(value: cef_content_setting_types_t) -> Self {
        Self(value)
    }
}
impl Into<cef_content_setting_types_t> for ContentSettingTypes {
    fn into(self) -> cef_content_setting_types_t {
        self.0
    }
}
impl Default for ContentSettingTypes {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_content_setting_values_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ContentSettingValues(cef_content_setting_values_t);
impl AsRef<cef_content_setting_values_t> for ContentSettingValues {
    fn as_ref(&self) -> &cef_content_setting_values_t {
        &self.0
    }
}
impl AsMut<cef_content_setting_values_t> for ContentSettingValues {
    fn as_mut(&mut self) -> &mut cef_content_setting_values_t {
        &mut self.0
    }
}
impl From<cef_content_setting_values_t> for ContentSettingValues {
    fn from(value: cef_content_setting_values_t) -> Self {
        Self(value)
    }
}
impl Into<cef_content_setting_values_t> for ContentSettingValues {
    fn into(self) -> cef_content_setting_values_t {
        self.0
    }
}
impl Default for ContentSettingValues {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_color_type_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ColorType(cef_color_type_t);
impl AsRef<cef_color_type_t> for ColorType {
    fn as_ref(&self) -> &cef_color_type_t {
        &self.0
    }
}
impl AsMut<cef_color_type_t> for ColorType {
    fn as_mut(&mut self) -> &mut cef_color_type_t {
        &mut self.0
    }
}
impl From<cef_color_type_t> for ColorType {
    fn from(value: cef_color_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_color_type_t> for ColorType {
    fn into(self) -> cef_color_type_t {
        self.0
    }
}
impl Default for ColorType {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_runtime_style_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct RuntimeStyle(cef_runtime_style_t);
impl AsRef<cef_runtime_style_t> for RuntimeStyle {
    fn as_ref(&self) -> &cef_runtime_style_t {
        &self.0
    }
}
impl AsMut<cef_runtime_style_t> for RuntimeStyle {
    fn as_mut(&mut self) -> &mut cef_runtime_style_t {
        &mut self.0
    }
}
impl From<cef_runtime_style_t> for RuntimeStyle {
    fn from(value: cef_runtime_style_t) -> Self {
        Self(value)
    }
}
impl Into<cef_runtime_style_t> for RuntimeStyle {
    fn into(self) -> cef_runtime_style_t {
        self.0
    }
}
impl Default for RuntimeStyle {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_log_severity_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct LogSeverity(cef_log_severity_t);
impl AsRef<cef_log_severity_t> for LogSeverity {
    fn as_ref(&self) -> &cef_log_severity_t {
        &self.0
    }
}
impl AsMut<cef_log_severity_t> for LogSeverity {
    fn as_mut(&mut self) -> &mut cef_log_severity_t {
        &mut self.0
    }
}
impl From<cef_log_severity_t> for LogSeverity {
    fn from(value: cef_log_severity_t) -> Self {
        Self(value)
    }
}
impl Into<cef_log_severity_t> for LogSeverity {
    fn into(self) -> cef_log_severity_t {
        self.0
    }
}
impl Default for LogSeverity {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_log_items_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct LogItems(cef_log_items_t);
impl AsRef<cef_log_items_t> for LogItems {
    fn as_ref(&self) -> &cef_log_items_t {
        &self.0
    }
}
impl AsMut<cef_log_items_t> for LogItems {
    fn as_mut(&mut self) -> &mut cef_log_items_t {
        &mut self.0
    }
}
impl From<cef_log_items_t> for LogItems {
    fn from(value: cef_log_items_t) -> Self {
        Self(value)
    }
}
impl Into<cef_log_items_t> for LogItems {
    fn into(self) -> cef_log_items_t {
        self.0
    }
}
impl Default for LogItems {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_state_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct State(cef_state_t);
impl AsRef<cef_state_t> for State {
    fn as_ref(&self) -> &cef_state_t {
        &self.0
    }
}
impl AsMut<cef_state_t> for State {
    fn as_mut(&mut self) -> &mut cef_state_t {
        &mut self.0
    }
}
impl From<cef_state_t> for State {
    fn from(value: cef_state_t) -> Self {
        Self(value)
    }
}
impl Into<cef_state_t> for State {
    fn into(self) -> cef_state_t {
        self.0
    }
}
impl Default for State {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_return_value_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ReturnValue(cef_return_value_t);
impl AsRef<cef_return_value_t> for ReturnValue {
    fn as_ref(&self) -> &cef_return_value_t {
        &self.0
    }
}
impl AsMut<cef_return_value_t> for ReturnValue {
    fn as_mut(&mut self) -> &mut cef_return_value_t {
        &mut self.0
    }
}
impl From<cef_return_value_t> for ReturnValue {
    fn from(value: cef_return_value_t) -> Self {
        Self(value)
    }
}
impl Into<cef_return_value_t> for ReturnValue {
    fn into(self) -> cef_return_value_t {
        self.0
    }
}
impl Default for ReturnValue {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_cookie_priority_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CookiePriority(cef_cookie_priority_t);
impl AsRef<cef_cookie_priority_t> for CookiePriority {
    fn as_ref(&self) -> &cef_cookie_priority_t {
        &self.0
    }
}
impl AsMut<cef_cookie_priority_t> for CookiePriority {
    fn as_mut(&mut self) -> &mut cef_cookie_priority_t {
        &mut self.0
    }
}
impl From<cef_cookie_priority_t> for CookiePriority {
    fn from(value: cef_cookie_priority_t) -> Self {
        Self(value)
    }
}
impl Into<cef_cookie_priority_t> for CookiePriority {
    fn into(self) -> cef_cookie_priority_t {
        self.0
    }
}
impl Default for CookiePriority {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_cookie_same_site_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CookieSameSite(cef_cookie_same_site_t);
impl AsRef<cef_cookie_same_site_t> for CookieSameSite {
    fn as_ref(&self) -> &cef_cookie_same_site_t {
        &self.0
    }
}
impl AsMut<cef_cookie_same_site_t> for CookieSameSite {
    fn as_mut(&mut self) -> &mut cef_cookie_same_site_t {
        &mut self.0
    }
}
impl From<cef_cookie_same_site_t> for CookieSameSite {
    fn from(value: cef_cookie_same_site_t) -> Self {
        Self(value)
    }
}
impl Into<cef_cookie_same_site_t> for CookieSameSite {
    fn into(self) -> cef_cookie_same_site_t {
        self.0
    }
}
impl Default for CookieSameSite {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_termination_status_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct TerminationStatus(cef_termination_status_t);
impl AsRef<cef_termination_status_t> for TerminationStatus {
    fn as_ref(&self) -> &cef_termination_status_t {
        &self.0
    }
}
impl AsMut<cef_termination_status_t> for TerminationStatus {
    fn as_mut(&mut self) -> &mut cef_termination_status_t {
        &mut self.0
    }
}
impl From<cef_termination_status_t> for TerminationStatus {
    fn from(value: cef_termination_status_t) -> Self {
        Self(value)
    }
}
impl Into<cef_termination_status_t> for TerminationStatus {
    fn into(self) -> cef_termination_status_t {
        self.0
    }
}
impl Default for TerminationStatus {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_path_key_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct PathKey(cef_path_key_t);
impl AsRef<cef_path_key_t> for PathKey {
    fn as_ref(&self) -> &cef_path_key_t {
        &self.0
    }
}
impl AsMut<cef_path_key_t> for PathKey {
    fn as_mut(&mut self) -> &mut cef_path_key_t {
        &mut self.0
    }
}
impl From<cef_path_key_t> for PathKey {
    fn from(value: cef_path_key_t) -> Self {
        Self(value)
    }
}
impl Into<cef_path_key_t> for PathKey {
    fn into(self) -> cef_path_key_t {
        self.0
    }
}
impl Default for PathKey {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_storage_type_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct StorageType(cef_storage_type_t);
impl AsRef<cef_storage_type_t> for StorageType {
    fn as_ref(&self) -> &cef_storage_type_t {
        &self.0
    }
}
impl AsMut<cef_storage_type_t> for StorageType {
    fn as_mut(&mut self) -> &mut cef_storage_type_t {
        &mut self.0
    }
}
impl From<cef_storage_type_t> for StorageType {
    fn from(value: cef_storage_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_storage_type_t> for StorageType {
    fn into(self) -> cef_storage_type_t {
        self.0
    }
}
impl Default for StorageType {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_errorcode_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Errorcode(cef_errorcode_t);
impl AsRef<cef_errorcode_t> for Errorcode {
    fn as_ref(&self) -> &cef_errorcode_t {
        &self.0
    }
}
impl AsMut<cef_errorcode_t> for Errorcode {
    fn as_mut(&mut self) -> &mut cef_errorcode_t {
        &mut self.0
    }
}
impl From<cef_errorcode_t> for Errorcode {
    fn from(value: cef_errorcode_t) -> Self {
        Self(value)
    }
}
impl Into<cef_errorcode_t> for Errorcode {
    fn into(self) -> cef_errorcode_t {
        self.0
    }
}
impl Default for Errorcode {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_cert_status_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CertStatus(cef_cert_status_t);
impl AsRef<cef_cert_status_t> for CertStatus {
    fn as_ref(&self) -> &cef_cert_status_t {
        &self.0
    }
}
impl AsMut<cef_cert_status_t> for CertStatus {
    fn as_mut(&mut self) -> &mut cef_cert_status_t {
        &mut self.0
    }
}
impl From<cef_cert_status_t> for CertStatus {
    fn from(value: cef_cert_status_t) -> Self {
        Self(value)
    }
}
impl Into<cef_cert_status_t> for CertStatus {
    fn into(self) -> cef_cert_status_t {
        self.0
    }
}
impl Default for CertStatus {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_resultcode_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Resultcode(cef_resultcode_t);
impl AsRef<cef_resultcode_t> for Resultcode {
    fn as_ref(&self) -> &cef_resultcode_t {
        &self.0
    }
}
impl AsMut<cef_resultcode_t> for Resultcode {
    fn as_mut(&mut self) -> &mut cef_resultcode_t {
        &mut self.0
    }
}
impl From<cef_resultcode_t> for Resultcode {
    fn from(value: cef_resultcode_t) -> Self {
        Self(value)
    }
}
impl Into<cef_resultcode_t> for Resultcode {
    fn into(self) -> cef_resultcode_t {
        self.0
    }
}
impl Default for Resultcode {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_window_open_disposition_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct WindowOpenDisposition(cef_window_open_disposition_t);
impl AsRef<cef_window_open_disposition_t> for WindowOpenDisposition {
    fn as_ref(&self) -> &cef_window_open_disposition_t {
        &self.0
    }
}
impl AsMut<cef_window_open_disposition_t> for WindowOpenDisposition {
    fn as_mut(&mut self) -> &mut cef_window_open_disposition_t {
        &mut self.0
    }
}
impl From<cef_window_open_disposition_t> for WindowOpenDisposition {
    fn from(value: cef_window_open_disposition_t) -> Self {
        Self(value)
    }
}
impl Into<cef_window_open_disposition_t> for WindowOpenDisposition {
    fn into(self) -> cef_window_open_disposition_t {
        self.0
    }
}
impl Default for WindowOpenDisposition {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_drag_operations_mask_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct DragOperationsMask(cef_drag_operations_mask_t);
impl AsRef<cef_drag_operations_mask_t> for DragOperationsMask {
    fn as_ref(&self) -> &cef_drag_operations_mask_t {
        &self.0
    }
}
impl AsMut<cef_drag_operations_mask_t> for DragOperationsMask {
    fn as_mut(&mut self) -> &mut cef_drag_operations_mask_t {
        &mut self.0
    }
}
impl From<cef_drag_operations_mask_t> for DragOperationsMask {
    fn from(value: cef_drag_operations_mask_t) -> Self {
        Self(value)
    }
}
impl Into<cef_drag_operations_mask_t> for DragOperationsMask {
    fn into(self) -> cef_drag_operations_mask_t {
        self.0
    }
}
impl Default for DragOperationsMask {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_text_input_mode_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct TextInputMode(cef_text_input_mode_t);
impl AsRef<cef_text_input_mode_t> for TextInputMode {
    fn as_ref(&self) -> &cef_text_input_mode_t {
        &self.0
    }
}
impl AsMut<cef_text_input_mode_t> for TextInputMode {
    fn as_mut(&mut self) -> &mut cef_text_input_mode_t {
        &mut self.0
    }
}
impl From<cef_text_input_mode_t> for TextInputMode {
    fn from(value: cef_text_input_mode_t) -> Self {
        Self(value)
    }
}
impl Into<cef_text_input_mode_t> for TextInputMode {
    fn into(self) -> cef_text_input_mode_t {
        self.0
    }
}
impl Default for TextInputMode {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_v8_propertyattribute_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct V8Propertyattribute(cef_v8_propertyattribute_t);
impl AsRef<cef_v8_propertyattribute_t> for V8Propertyattribute {
    fn as_ref(&self) -> &cef_v8_propertyattribute_t {
        &self.0
    }
}
impl AsMut<cef_v8_propertyattribute_t> for V8Propertyattribute {
    fn as_mut(&mut self) -> &mut cef_v8_propertyattribute_t {
        &mut self.0
    }
}
impl From<cef_v8_propertyattribute_t> for V8Propertyattribute {
    fn from(value: cef_v8_propertyattribute_t) -> Self {
        Self(value)
    }
}
impl Into<cef_v8_propertyattribute_t> for V8Propertyattribute {
    fn into(self) -> cef_v8_propertyattribute_t {
        self.0
    }
}
impl Default for V8Propertyattribute {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_postdataelement_type_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct PostdataelementType(cef_postdataelement_type_t);
impl AsRef<cef_postdataelement_type_t> for PostdataelementType {
    fn as_ref(&self) -> &cef_postdataelement_type_t {
        &self.0
    }
}
impl AsMut<cef_postdataelement_type_t> for PostdataelementType {
    fn as_mut(&mut self) -> &mut cef_postdataelement_type_t {
        &mut self.0
    }
}
impl From<cef_postdataelement_type_t> for PostdataelementType {
    fn from(value: cef_postdataelement_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_postdataelement_type_t> for PostdataelementType {
    fn into(self) -> cef_postdataelement_type_t {
        self.0
    }
}
impl Default for PostdataelementType {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_resource_type_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ResourceType(cef_resource_type_t);
impl AsRef<cef_resource_type_t> for ResourceType {
    fn as_ref(&self) -> &cef_resource_type_t {
        &self.0
    }
}
impl AsMut<cef_resource_type_t> for ResourceType {
    fn as_mut(&mut self) -> &mut cef_resource_type_t {
        &mut self.0
    }
}
impl From<cef_resource_type_t> for ResourceType {
    fn from(value: cef_resource_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_resource_type_t> for ResourceType {
    fn into(self) -> cef_resource_type_t {
        self.0
    }
}
impl Default for ResourceType {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_transition_type_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct TransitionType(cef_transition_type_t);
impl AsRef<cef_transition_type_t> for TransitionType {
    fn as_ref(&self) -> &cef_transition_type_t {
        &self.0
    }
}
impl AsMut<cef_transition_type_t> for TransitionType {
    fn as_mut(&mut self) -> &mut cef_transition_type_t {
        &mut self.0
    }
}
impl From<cef_transition_type_t> for TransitionType {
    fn from(value: cef_transition_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_transition_type_t> for TransitionType {
    fn into(self) -> cef_transition_type_t {
        self.0
    }
}
impl Default for TransitionType {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_urlrequest_flags_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct UrlrequestFlags(cef_urlrequest_flags_t);
impl AsRef<cef_urlrequest_flags_t> for UrlrequestFlags {
    fn as_ref(&self) -> &cef_urlrequest_flags_t {
        &self.0
    }
}
impl AsMut<cef_urlrequest_flags_t> for UrlrequestFlags {
    fn as_mut(&mut self) -> &mut cef_urlrequest_flags_t {
        &mut self.0
    }
}
impl From<cef_urlrequest_flags_t> for UrlrequestFlags {
    fn from(value: cef_urlrequest_flags_t) -> Self {
        Self(value)
    }
}
impl Into<cef_urlrequest_flags_t> for UrlrequestFlags {
    fn into(self) -> cef_urlrequest_flags_t {
        self.0
    }
}
impl Default for UrlrequestFlags {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_urlrequest_status_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct UrlrequestStatus(cef_urlrequest_status_t);
impl AsRef<cef_urlrequest_status_t> for UrlrequestStatus {
    fn as_ref(&self) -> &cef_urlrequest_status_t {
        &self.0
    }
}
impl AsMut<cef_urlrequest_status_t> for UrlrequestStatus {
    fn as_mut(&mut self) -> &mut cef_urlrequest_status_t {
        &mut self.0
    }
}
impl From<cef_urlrequest_status_t> for UrlrequestStatus {
    fn from(value: cef_urlrequest_status_t) -> Self {
        Self(value)
    }
}
impl Into<cef_urlrequest_status_t> for UrlrequestStatus {
    fn into(self) -> cef_urlrequest_status_t {
        self.0
    }
}
impl Default for UrlrequestStatus {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_process_id_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ProcessId(cef_process_id_t);
impl AsRef<cef_process_id_t> for ProcessId {
    fn as_ref(&self) -> &cef_process_id_t {
        &self.0
    }
}
impl AsMut<cef_process_id_t> for ProcessId {
    fn as_mut(&mut self) -> &mut cef_process_id_t {
        &mut self.0
    }
}
impl From<cef_process_id_t> for ProcessId {
    fn from(value: cef_process_id_t) -> Self {
        Self(value)
    }
}
impl Into<cef_process_id_t> for ProcessId {
    fn into(self) -> cef_process_id_t {
        self.0
    }
}
impl Default for ProcessId {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_thread_id_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ThreadId(cef_thread_id_t);
impl AsRef<cef_thread_id_t> for ThreadId {
    fn as_ref(&self) -> &cef_thread_id_t {
        &self.0
    }
}
impl AsMut<cef_thread_id_t> for ThreadId {
    fn as_mut(&mut self) -> &mut cef_thread_id_t {
        &mut self.0
    }
}
impl From<cef_thread_id_t> for ThreadId {
    fn from(value: cef_thread_id_t) -> Self {
        Self(value)
    }
}
impl Into<cef_thread_id_t> for ThreadId {
    fn into(self) -> cef_thread_id_t {
        self.0
    }
}
impl Default for ThreadId {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_thread_priority_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ThreadPriority(cef_thread_priority_t);
impl AsRef<cef_thread_priority_t> for ThreadPriority {
    fn as_ref(&self) -> &cef_thread_priority_t {
        &self.0
    }
}
impl AsMut<cef_thread_priority_t> for ThreadPriority {
    fn as_mut(&mut self) -> &mut cef_thread_priority_t {
        &mut self.0
    }
}
impl From<cef_thread_priority_t> for ThreadPriority {
    fn from(value: cef_thread_priority_t) -> Self {
        Self(value)
    }
}
impl Into<cef_thread_priority_t> for ThreadPriority {
    fn into(self) -> cef_thread_priority_t {
        self.0
    }
}
impl Default for ThreadPriority {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_message_loop_type_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MessageLoopType(cef_message_loop_type_t);
impl AsRef<cef_message_loop_type_t> for MessageLoopType {
    fn as_ref(&self) -> &cef_message_loop_type_t {
        &self.0
    }
}
impl AsMut<cef_message_loop_type_t> for MessageLoopType {
    fn as_mut(&mut self) -> &mut cef_message_loop_type_t {
        &mut self.0
    }
}
impl From<cef_message_loop_type_t> for MessageLoopType {
    fn from(value: cef_message_loop_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_message_loop_type_t> for MessageLoopType {
    fn into(self) -> cef_message_loop_type_t {
        self.0
    }
}
impl Default for MessageLoopType {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_com_init_mode_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ComInitMode(cef_com_init_mode_t);
impl AsRef<cef_com_init_mode_t> for ComInitMode {
    fn as_ref(&self) -> &cef_com_init_mode_t {
        &self.0
    }
}
impl AsMut<cef_com_init_mode_t> for ComInitMode {
    fn as_mut(&mut self) -> &mut cef_com_init_mode_t {
        &mut self.0
    }
}
impl From<cef_com_init_mode_t> for ComInitMode {
    fn from(value: cef_com_init_mode_t) -> Self {
        Self(value)
    }
}
impl Into<cef_com_init_mode_t> for ComInitMode {
    fn into(self) -> cef_com_init_mode_t {
        self.0
    }
}
impl Default for ComInitMode {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_value_type_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ValueType(cef_value_type_t);
impl AsRef<cef_value_type_t> for ValueType {
    fn as_ref(&self) -> &cef_value_type_t {
        &self.0
    }
}
impl AsMut<cef_value_type_t> for ValueType {
    fn as_mut(&mut self) -> &mut cef_value_type_t {
        &mut self.0
    }
}
impl From<cef_value_type_t> for ValueType {
    fn from(value: cef_value_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_value_type_t> for ValueType {
    fn into(self) -> cef_value_type_t {
        self.0
    }
}
impl Default for ValueType {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_jsdialog_type_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct JsdialogType(cef_jsdialog_type_t);
impl AsRef<cef_jsdialog_type_t> for JsdialogType {
    fn as_ref(&self) -> &cef_jsdialog_type_t {
        &self.0
    }
}
impl AsMut<cef_jsdialog_type_t> for JsdialogType {
    fn as_mut(&mut self) -> &mut cef_jsdialog_type_t {
        &mut self.0
    }
}
impl From<cef_jsdialog_type_t> for JsdialogType {
    fn from(value: cef_jsdialog_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_jsdialog_type_t> for JsdialogType {
    fn into(self) -> cef_jsdialog_type_t {
        self.0
    }
}
impl Default for JsdialogType {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_menu_id_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MenuId(cef_menu_id_t);
impl AsRef<cef_menu_id_t> for MenuId {
    fn as_ref(&self) -> &cef_menu_id_t {
        &self.0
    }
}
impl AsMut<cef_menu_id_t> for MenuId {
    fn as_mut(&mut self) -> &mut cef_menu_id_t {
        &mut self.0
    }
}
impl From<cef_menu_id_t> for MenuId {
    fn from(value: cef_menu_id_t) -> Self {
        Self(value)
    }
}
impl Into<cef_menu_id_t> for MenuId {
    fn into(self) -> cef_menu_id_t {
        self.0
    }
}
impl Default for MenuId {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_mouse_button_type_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MouseButtonType(cef_mouse_button_type_t);
impl AsRef<cef_mouse_button_type_t> for MouseButtonType {
    fn as_ref(&self) -> &cef_mouse_button_type_t {
        &self.0
    }
}
impl AsMut<cef_mouse_button_type_t> for MouseButtonType {
    fn as_mut(&mut self) -> &mut cef_mouse_button_type_t {
        &mut self.0
    }
}
impl From<cef_mouse_button_type_t> for MouseButtonType {
    fn from(value: cef_mouse_button_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_mouse_button_type_t> for MouseButtonType {
    fn into(self) -> cef_mouse_button_type_t {
        self.0
    }
}
impl Default for MouseButtonType {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_touch_event_type_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct TouchEventType(cef_touch_event_type_t);
impl AsRef<cef_touch_event_type_t> for TouchEventType {
    fn as_ref(&self) -> &cef_touch_event_type_t {
        &self.0
    }
}
impl AsMut<cef_touch_event_type_t> for TouchEventType {
    fn as_mut(&mut self) -> &mut cef_touch_event_type_t {
        &mut self.0
    }
}
impl From<cef_touch_event_type_t> for TouchEventType {
    fn from(value: cef_touch_event_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_touch_event_type_t> for TouchEventType {
    fn into(self) -> cef_touch_event_type_t {
        self.0
    }
}
impl Default for TouchEventType {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_pointer_type_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct PointerType(cef_pointer_type_t);
impl AsRef<cef_pointer_type_t> for PointerType {
    fn as_ref(&self) -> &cef_pointer_type_t {
        &self.0
    }
}
impl AsMut<cef_pointer_type_t> for PointerType {
    fn as_mut(&mut self) -> &mut cef_pointer_type_t {
        &mut self.0
    }
}
impl From<cef_pointer_type_t> for PointerType {
    fn from(value: cef_pointer_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_pointer_type_t> for PointerType {
    fn into(self) -> cef_pointer_type_t {
        self.0
    }
}
impl Default for PointerType {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_paint_element_type_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct PaintElementType(cef_paint_element_type_t);
impl AsRef<cef_paint_element_type_t> for PaintElementType {
    fn as_ref(&self) -> &cef_paint_element_type_t {
        &self.0
    }
}
impl AsMut<cef_paint_element_type_t> for PaintElementType {
    fn as_mut(&mut self) -> &mut cef_paint_element_type_t {
        &mut self.0
    }
}
impl From<cef_paint_element_type_t> for PaintElementType {
    fn from(value: cef_paint_element_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_paint_element_type_t> for PaintElementType {
    fn into(self) -> cef_paint_element_type_t {
        self.0
    }
}
impl Default for PaintElementType {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_event_flags_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct EventFlags(cef_event_flags_t);
impl AsRef<cef_event_flags_t> for EventFlags {
    fn as_ref(&self) -> &cef_event_flags_t {
        &self.0
    }
}
impl AsMut<cef_event_flags_t> for EventFlags {
    fn as_mut(&mut self) -> &mut cef_event_flags_t {
        &mut self.0
    }
}
impl From<cef_event_flags_t> for EventFlags {
    fn from(value: cef_event_flags_t) -> Self {
        Self(value)
    }
}
impl Into<cef_event_flags_t> for EventFlags {
    fn into(self) -> cef_event_flags_t {
        self.0
    }
}
impl Default for EventFlags {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_menu_item_type_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MenuItemType(cef_menu_item_type_t);
impl AsRef<cef_menu_item_type_t> for MenuItemType {
    fn as_ref(&self) -> &cef_menu_item_type_t {
        &self.0
    }
}
impl AsMut<cef_menu_item_type_t> for MenuItemType {
    fn as_mut(&mut self) -> &mut cef_menu_item_type_t {
        &mut self.0
    }
}
impl From<cef_menu_item_type_t> for MenuItemType {
    fn from(value: cef_menu_item_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_menu_item_type_t> for MenuItemType {
    fn into(self) -> cef_menu_item_type_t {
        self.0
    }
}
impl Default for MenuItemType {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_context_menu_type_flags_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ContextMenuTypeFlags(cef_context_menu_type_flags_t);
impl AsRef<cef_context_menu_type_flags_t> for ContextMenuTypeFlags {
    fn as_ref(&self) -> &cef_context_menu_type_flags_t {
        &self.0
    }
}
impl AsMut<cef_context_menu_type_flags_t> for ContextMenuTypeFlags {
    fn as_mut(&mut self) -> &mut cef_context_menu_type_flags_t {
        &mut self.0
    }
}
impl From<cef_context_menu_type_flags_t> for ContextMenuTypeFlags {
    fn from(value: cef_context_menu_type_flags_t) -> Self {
        Self(value)
    }
}
impl Into<cef_context_menu_type_flags_t> for ContextMenuTypeFlags {
    fn into(self) -> cef_context_menu_type_flags_t {
        self.0
    }
}
impl Default for ContextMenuTypeFlags {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_context_menu_media_type_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ContextMenuMediaType(cef_context_menu_media_type_t);
impl AsRef<cef_context_menu_media_type_t> for ContextMenuMediaType {
    fn as_ref(&self) -> &cef_context_menu_media_type_t {
        &self.0
    }
}
impl AsMut<cef_context_menu_media_type_t> for ContextMenuMediaType {
    fn as_mut(&mut self) -> &mut cef_context_menu_media_type_t {
        &mut self.0
    }
}
impl From<cef_context_menu_media_type_t> for ContextMenuMediaType {
    fn from(value: cef_context_menu_media_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_context_menu_media_type_t> for ContextMenuMediaType {
    fn into(self) -> cef_context_menu_media_type_t {
        self.0
    }
}
impl Default for ContextMenuMediaType {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_context_menu_media_state_flags_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ContextMenuMediaStateFlags(cef_context_menu_media_state_flags_t);
impl AsRef<cef_context_menu_media_state_flags_t> for ContextMenuMediaStateFlags {
    fn as_ref(&self) -> &cef_context_menu_media_state_flags_t {
        &self.0
    }
}
impl AsMut<cef_context_menu_media_state_flags_t> for ContextMenuMediaStateFlags {
    fn as_mut(&mut self) -> &mut cef_context_menu_media_state_flags_t {
        &mut self.0
    }
}
impl From<cef_context_menu_media_state_flags_t> for ContextMenuMediaStateFlags {
    fn from(value: cef_context_menu_media_state_flags_t) -> Self {
        Self(value)
    }
}
impl Into<cef_context_menu_media_state_flags_t> for ContextMenuMediaStateFlags {
    fn into(self) -> cef_context_menu_media_state_flags_t {
        self.0
    }
}
impl Default for ContextMenuMediaStateFlags {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_context_menu_edit_state_flags_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ContextMenuEditStateFlags(cef_context_menu_edit_state_flags_t);
impl AsRef<cef_context_menu_edit_state_flags_t> for ContextMenuEditStateFlags {
    fn as_ref(&self) -> &cef_context_menu_edit_state_flags_t {
        &self.0
    }
}
impl AsMut<cef_context_menu_edit_state_flags_t> for ContextMenuEditStateFlags {
    fn as_mut(&mut self) -> &mut cef_context_menu_edit_state_flags_t {
        &mut self.0
    }
}
impl From<cef_context_menu_edit_state_flags_t> for ContextMenuEditStateFlags {
    fn from(value: cef_context_menu_edit_state_flags_t) -> Self {
        Self(value)
    }
}
impl Into<cef_context_menu_edit_state_flags_t> for ContextMenuEditStateFlags {
    fn into(self) -> cef_context_menu_edit_state_flags_t {
        self.0
    }
}
impl Default for ContextMenuEditStateFlags {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_quick_menu_edit_state_flags_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct QuickMenuEditStateFlags(cef_quick_menu_edit_state_flags_t);
impl AsRef<cef_quick_menu_edit_state_flags_t> for QuickMenuEditStateFlags {
    fn as_ref(&self) -> &cef_quick_menu_edit_state_flags_t {
        &self.0
    }
}
impl AsMut<cef_quick_menu_edit_state_flags_t> for QuickMenuEditStateFlags {
    fn as_mut(&mut self) -> &mut cef_quick_menu_edit_state_flags_t {
        &mut self.0
    }
}
impl From<cef_quick_menu_edit_state_flags_t> for QuickMenuEditStateFlags {
    fn from(value: cef_quick_menu_edit_state_flags_t) -> Self {
        Self(value)
    }
}
impl Into<cef_quick_menu_edit_state_flags_t> for QuickMenuEditStateFlags {
    fn into(self) -> cef_quick_menu_edit_state_flags_t {
        self.0
    }
}
impl Default for QuickMenuEditStateFlags {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_key_event_type_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct KeyEventType(cef_key_event_type_t);
impl AsRef<cef_key_event_type_t> for KeyEventType {
    fn as_ref(&self) -> &cef_key_event_type_t {
        &self.0
    }
}
impl AsMut<cef_key_event_type_t> for KeyEventType {
    fn as_mut(&mut self) -> &mut cef_key_event_type_t {
        &mut self.0
    }
}
impl From<cef_key_event_type_t> for KeyEventType {
    fn from(value: cef_key_event_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_key_event_type_t> for KeyEventType {
    fn into(self) -> cef_key_event_type_t {
        self.0
    }
}
impl Default for KeyEventType {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_focus_source_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FocusSource(cef_focus_source_t);
impl AsRef<cef_focus_source_t> for FocusSource {
    fn as_ref(&self) -> &cef_focus_source_t {
        &self.0
    }
}
impl AsMut<cef_focus_source_t> for FocusSource {
    fn as_mut(&mut self) -> &mut cef_focus_source_t {
        &mut self.0
    }
}
impl From<cef_focus_source_t> for FocusSource {
    fn from(value: cef_focus_source_t) -> Self {
        Self(value)
    }
}
impl Into<cef_focus_source_t> for FocusSource {
    fn into(self) -> cef_focus_source_t {
        self.0
    }
}
impl Default for FocusSource {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_navigation_type_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct NavigationType(cef_navigation_type_t);
impl AsRef<cef_navigation_type_t> for NavigationType {
    fn as_ref(&self) -> &cef_navigation_type_t {
        &self.0
    }
}
impl AsMut<cef_navigation_type_t> for NavigationType {
    fn as_mut(&mut self) -> &mut cef_navigation_type_t {
        &mut self.0
    }
}
impl From<cef_navigation_type_t> for NavigationType {
    fn from(value: cef_navigation_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_navigation_type_t> for NavigationType {
    fn into(self) -> cef_navigation_type_t {
        self.0
    }
}
impl Default for NavigationType {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_xml_encoding_type_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct XmlEncodingType(cef_xml_encoding_type_t);
impl AsRef<cef_xml_encoding_type_t> for XmlEncodingType {
    fn as_ref(&self) -> &cef_xml_encoding_type_t {
        &self.0
    }
}
impl AsMut<cef_xml_encoding_type_t> for XmlEncodingType {
    fn as_mut(&mut self) -> &mut cef_xml_encoding_type_t {
        &mut self.0
    }
}
impl From<cef_xml_encoding_type_t> for XmlEncodingType {
    fn from(value: cef_xml_encoding_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_xml_encoding_type_t> for XmlEncodingType {
    fn into(self) -> cef_xml_encoding_type_t {
        self.0
    }
}
impl Default for XmlEncodingType {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_xml_node_type_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct XmlNodeType(cef_xml_node_type_t);
impl AsRef<cef_xml_node_type_t> for XmlNodeType {
    fn as_ref(&self) -> &cef_xml_node_type_t {
        &self.0
    }
}
impl AsMut<cef_xml_node_type_t> for XmlNodeType {
    fn as_mut(&mut self) -> &mut cef_xml_node_type_t {
        &mut self.0
    }
}
impl From<cef_xml_node_type_t> for XmlNodeType {
    fn from(value: cef_xml_node_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_xml_node_type_t> for XmlNodeType {
    fn into(self) -> cef_xml_node_type_t {
        self.0
    }
}
impl Default for XmlNodeType {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_dom_document_type_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct DomDocumentType(cef_dom_document_type_t);
impl AsRef<cef_dom_document_type_t> for DomDocumentType {
    fn as_ref(&self) -> &cef_dom_document_type_t {
        &self.0
    }
}
impl AsMut<cef_dom_document_type_t> for DomDocumentType {
    fn as_mut(&mut self) -> &mut cef_dom_document_type_t {
        &mut self.0
    }
}
impl From<cef_dom_document_type_t> for DomDocumentType {
    fn from(value: cef_dom_document_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_dom_document_type_t> for DomDocumentType {
    fn into(self) -> cef_dom_document_type_t {
        self.0
    }
}
impl Default for DomDocumentType {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_dom_event_category_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct DomEventCategory(cef_dom_event_category_t);
impl AsRef<cef_dom_event_category_t> for DomEventCategory {
    fn as_ref(&self) -> &cef_dom_event_category_t {
        &self.0
    }
}
impl AsMut<cef_dom_event_category_t> for DomEventCategory {
    fn as_mut(&mut self) -> &mut cef_dom_event_category_t {
        &mut self.0
    }
}
impl From<cef_dom_event_category_t> for DomEventCategory {
    fn from(value: cef_dom_event_category_t) -> Self {
        Self(value)
    }
}
impl Into<cef_dom_event_category_t> for DomEventCategory {
    fn into(self) -> cef_dom_event_category_t {
        self.0
    }
}
impl Default for DomEventCategory {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_dom_event_phase_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct DomEventPhase(cef_dom_event_phase_t);
impl AsRef<cef_dom_event_phase_t> for DomEventPhase {
    fn as_ref(&self) -> &cef_dom_event_phase_t {
        &self.0
    }
}
impl AsMut<cef_dom_event_phase_t> for DomEventPhase {
    fn as_mut(&mut self) -> &mut cef_dom_event_phase_t {
        &mut self.0
    }
}
impl From<cef_dom_event_phase_t> for DomEventPhase {
    fn from(value: cef_dom_event_phase_t) -> Self {
        Self(value)
    }
}
impl Into<cef_dom_event_phase_t> for DomEventPhase {
    fn into(self) -> cef_dom_event_phase_t {
        self.0
    }
}
impl Default for DomEventPhase {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_dom_node_type_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct DomNodeType(cef_dom_node_type_t);
impl AsRef<cef_dom_node_type_t> for DomNodeType {
    fn as_ref(&self) -> &cef_dom_node_type_t {
        &self.0
    }
}
impl AsMut<cef_dom_node_type_t> for DomNodeType {
    fn as_mut(&mut self) -> &mut cef_dom_node_type_t {
        &mut self.0
    }
}
impl From<cef_dom_node_type_t> for DomNodeType {
    fn from(value: cef_dom_node_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_dom_node_type_t> for DomNodeType {
    fn into(self) -> cef_dom_node_type_t {
        self.0
    }
}
impl Default for DomNodeType {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_dom_form_control_type_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct DomFormControlType(cef_dom_form_control_type_t);
impl AsRef<cef_dom_form_control_type_t> for DomFormControlType {
    fn as_ref(&self) -> &cef_dom_form_control_type_t {
        &self.0
    }
}
impl AsMut<cef_dom_form_control_type_t> for DomFormControlType {
    fn as_mut(&mut self) -> &mut cef_dom_form_control_type_t {
        &mut self.0
    }
}
impl From<cef_dom_form_control_type_t> for DomFormControlType {
    fn from(value: cef_dom_form_control_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_dom_form_control_type_t> for DomFormControlType {
    fn into(self) -> cef_dom_form_control_type_t {
        self.0
    }
}
impl Default for DomFormControlType {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_file_dialog_mode_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FileDialogMode(cef_file_dialog_mode_t);
impl AsRef<cef_file_dialog_mode_t> for FileDialogMode {
    fn as_ref(&self) -> &cef_file_dialog_mode_t {
        &self.0
    }
}
impl AsMut<cef_file_dialog_mode_t> for FileDialogMode {
    fn as_mut(&mut self) -> &mut cef_file_dialog_mode_t {
        &mut self.0
    }
}
impl From<cef_file_dialog_mode_t> for FileDialogMode {
    fn from(value: cef_file_dialog_mode_t) -> Self {
        Self(value)
    }
}
impl Into<cef_file_dialog_mode_t> for FileDialogMode {
    fn into(self) -> cef_file_dialog_mode_t {
        self.0
    }
}
impl Default for FileDialogMode {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_color_model_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ColorModel(cef_color_model_t);
impl AsRef<cef_color_model_t> for ColorModel {
    fn as_ref(&self) -> &cef_color_model_t {
        &self.0
    }
}
impl AsMut<cef_color_model_t> for ColorModel {
    fn as_mut(&mut self) -> &mut cef_color_model_t {
        &mut self.0
    }
}
impl From<cef_color_model_t> for ColorModel {
    fn from(value: cef_color_model_t) -> Self {
        Self(value)
    }
}
impl Into<cef_color_model_t> for ColorModel {
    fn into(self) -> cef_color_model_t {
        self.0
    }
}
impl Default for ColorModel {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_duplex_mode_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct DuplexMode(cef_duplex_mode_t);
impl AsRef<cef_duplex_mode_t> for DuplexMode {
    fn as_ref(&self) -> &cef_duplex_mode_t {
        &self.0
    }
}
impl AsMut<cef_duplex_mode_t> for DuplexMode {
    fn as_mut(&mut self) -> &mut cef_duplex_mode_t {
        &mut self.0
    }
}
impl From<cef_duplex_mode_t> for DuplexMode {
    fn from(value: cef_duplex_mode_t) -> Self {
        Self(value)
    }
}
impl Into<cef_duplex_mode_t> for DuplexMode {
    fn into(self) -> cef_duplex_mode_t {
        self.0
    }
}
impl Default for DuplexMode {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_cursor_type_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CursorType(cef_cursor_type_t);
impl AsRef<cef_cursor_type_t> for CursorType {
    fn as_ref(&self) -> &cef_cursor_type_t {
        &self.0
    }
}
impl AsMut<cef_cursor_type_t> for CursorType {
    fn as_mut(&mut self) -> &mut cef_cursor_type_t {
        &mut self.0
    }
}
impl From<cef_cursor_type_t> for CursorType {
    fn from(value: cef_cursor_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_cursor_type_t> for CursorType {
    fn into(self) -> cef_cursor_type_t {
        self.0
    }
}
impl Default for CursorType {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_uri_unescape_rule_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct UriUnescapeRule(cef_uri_unescape_rule_t);
impl AsRef<cef_uri_unescape_rule_t> for UriUnescapeRule {
    fn as_ref(&self) -> &cef_uri_unescape_rule_t {
        &self.0
    }
}
impl AsMut<cef_uri_unescape_rule_t> for UriUnescapeRule {
    fn as_mut(&mut self) -> &mut cef_uri_unescape_rule_t {
        &mut self.0
    }
}
impl From<cef_uri_unescape_rule_t> for UriUnescapeRule {
    fn from(value: cef_uri_unescape_rule_t) -> Self {
        Self(value)
    }
}
impl Into<cef_uri_unescape_rule_t> for UriUnescapeRule {
    fn into(self) -> cef_uri_unescape_rule_t {
        self.0
    }
}
impl Default for UriUnescapeRule {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_json_parser_options_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct JsonParserOptions(cef_json_parser_options_t);
impl AsRef<cef_json_parser_options_t> for JsonParserOptions {
    fn as_ref(&self) -> &cef_json_parser_options_t {
        &self.0
    }
}
impl AsMut<cef_json_parser_options_t> for JsonParserOptions {
    fn as_mut(&mut self) -> &mut cef_json_parser_options_t {
        &mut self.0
    }
}
impl From<cef_json_parser_options_t> for JsonParserOptions {
    fn from(value: cef_json_parser_options_t) -> Self {
        Self(value)
    }
}
impl Into<cef_json_parser_options_t> for JsonParserOptions {
    fn into(self) -> cef_json_parser_options_t {
        self.0
    }
}
impl Default for JsonParserOptions {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_json_writer_options_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct JsonWriterOptions(cef_json_writer_options_t);
impl AsRef<cef_json_writer_options_t> for JsonWriterOptions {
    fn as_ref(&self) -> &cef_json_writer_options_t {
        &self.0
    }
}
impl AsMut<cef_json_writer_options_t> for JsonWriterOptions {
    fn as_mut(&mut self) -> &mut cef_json_writer_options_t {
        &mut self.0
    }
}
impl From<cef_json_writer_options_t> for JsonWriterOptions {
    fn from(value: cef_json_writer_options_t) -> Self {
        Self(value)
    }
}
impl Into<cef_json_writer_options_t> for JsonWriterOptions {
    fn into(self) -> cef_json_writer_options_t {
        self.0
    }
}
impl Default for JsonWriterOptions {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_pdf_print_margin_type_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct PdfPrintMarginType(cef_pdf_print_margin_type_t);
impl AsRef<cef_pdf_print_margin_type_t> for PdfPrintMarginType {
    fn as_ref(&self) -> &cef_pdf_print_margin_type_t {
        &self.0
    }
}
impl AsMut<cef_pdf_print_margin_type_t> for PdfPrintMarginType {
    fn as_mut(&mut self) -> &mut cef_pdf_print_margin_type_t {
        &mut self.0
    }
}
impl From<cef_pdf_print_margin_type_t> for PdfPrintMarginType {
    fn from(value: cef_pdf_print_margin_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_pdf_print_margin_type_t> for PdfPrintMarginType {
    fn into(self) -> cef_pdf_print_margin_type_t {
        self.0
    }
}
impl Default for PdfPrintMarginType {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_scale_factor_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ScaleFactor(cef_scale_factor_t);
impl AsRef<cef_scale_factor_t> for ScaleFactor {
    fn as_ref(&self) -> &cef_scale_factor_t {
        &self.0
    }
}
impl AsMut<cef_scale_factor_t> for ScaleFactor {
    fn as_mut(&mut self) -> &mut cef_scale_factor_t {
        &mut self.0
    }
}
impl From<cef_scale_factor_t> for ScaleFactor {
    fn from(value: cef_scale_factor_t) -> Self {
        Self(value)
    }
}
impl Into<cef_scale_factor_t> for ScaleFactor {
    fn into(self) -> cef_scale_factor_t {
        self.0
    }
}
impl Default for ScaleFactor {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_referrer_policy_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ReferrerPolicy(cef_referrer_policy_t);
impl AsRef<cef_referrer_policy_t> for ReferrerPolicy {
    fn as_ref(&self) -> &cef_referrer_policy_t {
        &self.0
    }
}
impl AsMut<cef_referrer_policy_t> for ReferrerPolicy {
    fn as_mut(&mut self) -> &mut cef_referrer_policy_t {
        &mut self.0
    }
}
impl From<cef_referrer_policy_t> for ReferrerPolicy {
    fn from(value: cef_referrer_policy_t) -> Self {
        Self(value)
    }
}
impl Into<cef_referrer_policy_t> for ReferrerPolicy {
    fn into(self) -> cef_referrer_policy_t {
        self.0
    }
}
impl Default for ReferrerPolicy {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_response_filter_status_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ResponseFilterStatus(cef_response_filter_status_t);
impl AsRef<cef_response_filter_status_t> for ResponseFilterStatus {
    fn as_ref(&self) -> &cef_response_filter_status_t {
        &self.0
    }
}
impl AsMut<cef_response_filter_status_t> for ResponseFilterStatus {
    fn as_mut(&mut self) -> &mut cef_response_filter_status_t {
        &mut self.0
    }
}
impl From<cef_response_filter_status_t> for ResponseFilterStatus {
    fn from(value: cef_response_filter_status_t) -> Self {
        Self(value)
    }
}
impl Into<cef_response_filter_status_t> for ResponseFilterStatus {
    fn into(self) -> cef_response_filter_status_t {
        self.0
    }
}
impl Default for ResponseFilterStatus {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_alpha_type_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct AlphaType(cef_alpha_type_t);
impl AsRef<cef_alpha_type_t> for AlphaType {
    fn as_ref(&self) -> &cef_alpha_type_t {
        &self.0
    }
}
impl AsMut<cef_alpha_type_t> for AlphaType {
    fn as_mut(&mut self) -> &mut cef_alpha_type_t {
        &mut self.0
    }
}
impl From<cef_alpha_type_t> for AlphaType {
    fn from(value: cef_alpha_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_alpha_type_t> for AlphaType {
    fn into(self) -> cef_alpha_type_t {
        self.0
    }
}
impl Default for AlphaType {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_text_style_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct TextStyle(cef_text_style_t);
impl AsRef<cef_text_style_t> for TextStyle {
    fn as_ref(&self) -> &cef_text_style_t {
        &self.0
    }
}
impl AsMut<cef_text_style_t> for TextStyle {
    fn as_mut(&mut self) -> &mut cef_text_style_t {
        &mut self.0
    }
}
impl From<cef_text_style_t> for TextStyle {
    fn from(value: cef_text_style_t) -> Self {
        Self(value)
    }
}
impl Into<cef_text_style_t> for TextStyle {
    fn into(self) -> cef_text_style_t {
        self.0
    }
}
impl Default for TextStyle {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_axis_alignment_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct AxisAlignment(cef_axis_alignment_t);
impl AsRef<cef_axis_alignment_t> for AxisAlignment {
    fn as_ref(&self) -> &cef_axis_alignment_t {
        &self.0
    }
}
impl AsMut<cef_axis_alignment_t> for AxisAlignment {
    fn as_mut(&mut self) -> &mut cef_axis_alignment_t {
        &mut self.0
    }
}
impl From<cef_axis_alignment_t> for AxisAlignment {
    fn from(value: cef_axis_alignment_t) -> Self {
        Self(value)
    }
}
impl Into<cef_axis_alignment_t> for AxisAlignment {
    fn into(self) -> cef_axis_alignment_t {
        self.0
    }
}
impl Default for AxisAlignment {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_button_state_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ButtonState(cef_button_state_t);
impl AsRef<cef_button_state_t> for ButtonState {
    fn as_ref(&self) -> &cef_button_state_t {
        &self.0
    }
}
impl AsMut<cef_button_state_t> for ButtonState {
    fn as_mut(&mut self) -> &mut cef_button_state_t {
        &mut self.0
    }
}
impl From<cef_button_state_t> for ButtonState {
    fn from(value: cef_button_state_t) -> Self {
        Self(value)
    }
}
impl Into<cef_button_state_t> for ButtonState {
    fn into(self) -> cef_button_state_t {
        self.0
    }
}
impl Default for ButtonState {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_horizontal_alignment_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct HorizontalAlignment(cef_horizontal_alignment_t);
impl AsRef<cef_horizontal_alignment_t> for HorizontalAlignment {
    fn as_ref(&self) -> &cef_horizontal_alignment_t {
        &self.0
    }
}
impl AsMut<cef_horizontal_alignment_t> for HorizontalAlignment {
    fn as_mut(&mut self) -> &mut cef_horizontal_alignment_t {
        &mut self.0
    }
}
impl From<cef_horizontal_alignment_t> for HorizontalAlignment {
    fn from(value: cef_horizontal_alignment_t) -> Self {
        Self(value)
    }
}
impl Into<cef_horizontal_alignment_t> for HorizontalAlignment {
    fn into(self) -> cef_horizontal_alignment_t {
        self.0
    }
}
impl Default for HorizontalAlignment {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_menu_anchor_position_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MenuAnchorPosition(cef_menu_anchor_position_t);
impl AsRef<cef_menu_anchor_position_t> for MenuAnchorPosition {
    fn as_ref(&self) -> &cef_menu_anchor_position_t {
        &self.0
    }
}
impl AsMut<cef_menu_anchor_position_t> for MenuAnchorPosition {
    fn as_mut(&mut self) -> &mut cef_menu_anchor_position_t {
        &mut self.0
    }
}
impl From<cef_menu_anchor_position_t> for MenuAnchorPosition {
    fn from(value: cef_menu_anchor_position_t) -> Self {
        Self(value)
    }
}
impl Into<cef_menu_anchor_position_t> for MenuAnchorPosition {
    fn into(self) -> cef_menu_anchor_position_t {
        self.0
    }
}
impl Default for MenuAnchorPosition {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_menu_color_type_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MenuColorType(cef_menu_color_type_t);
impl AsRef<cef_menu_color_type_t> for MenuColorType {
    fn as_ref(&self) -> &cef_menu_color_type_t {
        &self.0
    }
}
impl AsMut<cef_menu_color_type_t> for MenuColorType {
    fn as_mut(&mut self) -> &mut cef_menu_color_type_t {
        &mut self.0
    }
}
impl From<cef_menu_color_type_t> for MenuColorType {
    fn from(value: cef_menu_color_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_menu_color_type_t> for MenuColorType {
    fn into(self) -> cef_menu_color_type_t {
        self.0
    }
}
impl Default for MenuColorType {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_ssl_version_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct SslVersion(cef_ssl_version_t);
impl AsRef<cef_ssl_version_t> for SslVersion {
    fn as_ref(&self) -> &cef_ssl_version_t {
        &self.0
    }
}
impl AsMut<cef_ssl_version_t> for SslVersion {
    fn as_mut(&mut self) -> &mut cef_ssl_version_t {
        &mut self.0
    }
}
impl From<cef_ssl_version_t> for SslVersion {
    fn from(value: cef_ssl_version_t) -> Self {
        Self(value)
    }
}
impl Into<cef_ssl_version_t> for SslVersion {
    fn into(self) -> cef_ssl_version_t {
        self.0
    }
}
impl Default for SslVersion {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_ssl_content_status_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct SslContentStatus(cef_ssl_content_status_t);
impl AsRef<cef_ssl_content_status_t> for SslContentStatus {
    fn as_ref(&self) -> &cef_ssl_content_status_t {
        &self.0
    }
}
impl AsMut<cef_ssl_content_status_t> for SslContentStatus {
    fn as_mut(&mut self) -> &mut cef_ssl_content_status_t {
        &mut self.0
    }
}
impl From<cef_ssl_content_status_t> for SslContentStatus {
    fn from(value: cef_ssl_content_status_t) -> Self {
        Self(value)
    }
}
impl Into<cef_ssl_content_status_t> for SslContentStatus {
    fn into(self) -> cef_ssl_content_status_t {
        self.0
    }
}
impl Default for SslContentStatus {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_scheme_options_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct SchemeOptions(cef_scheme_options_t);
impl AsRef<cef_scheme_options_t> for SchemeOptions {
    fn as_ref(&self) -> &cef_scheme_options_t {
        &self.0
    }
}
impl AsMut<cef_scheme_options_t> for SchemeOptions {
    fn as_mut(&mut self) -> &mut cef_scheme_options_t {
        &mut self.0
    }
}
impl From<cef_scheme_options_t> for SchemeOptions {
    fn from(value: cef_scheme_options_t) -> Self {
        Self(value)
    }
}
impl Into<cef_scheme_options_t> for SchemeOptions {
    fn into(self) -> cef_scheme_options_t {
        self.0
    }
}
impl Default for SchemeOptions {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_composition_underline_style_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CompositionUnderlineStyle(cef_composition_underline_style_t);
impl AsRef<cef_composition_underline_style_t> for CompositionUnderlineStyle {
    fn as_ref(&self) -> &cef_composition_underline_style_t {
        &self.0
    }
}
impl AsMut<cef_composition_underline_style_t> for CompositionUnderlineStyle {
    fn as_mut(&mut self) -> &mut cef_composition_underline_style_t {
        &mut self.0
    }
}
impl From<cef_composition_underline_style_t> for CompositionUnderlineStyle {
    fn from(value: cef_composition_underline_style_t) -> Self {
        Self(value)
    }
}
impl Into<cef_composition_underline_style_t> for CompositionUnderlineStyle {
    fn into(self) -> cef_composition_underline_style_t {
        self.0
    }
}
impl Default for CompositionUnderlineStyle {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_channel_layout_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ChannelLayout(cef_channel_layout_t);
impl AsRef<cef_channel_layout_t> for ChannelLayout {
    fn as_ref(&self) -> &cef_channel_layout_t {
        &self.0
    }
}
impl AsMut<cef_channel_layout_t> for ChannelLayout {
    fn as_mut(&mut self) -> &mut cef_channel_layout_t {
        &mut self.0
    }
}
impl From<cef_channel_layout_t> for ChannelLayout {
    fn from(value: cef_channel_layout_t) -> Self {
        Self(value)
    }
}
impl Into<cef_channel_layout_t> for ChannelLayout {
    fn into(self) -> cef_channel_layout_t {
        self.0
    }
}
impl Default for ChannelLayout {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_media_route_create_result_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MediaRouteCreateResult(cef_media_route_create_result_t);
impl AsRef<cef_media_route_create_result_t> for MediaRouteCreateResult {
    fn as_ref(&self) -> &cef_media_route_create_result_t {
        &self.0
    }
}
impl AsMut<cef_media_route_create_result_t> for MediaRouteCreateResult {
    fn as_mut(&mut self) -> &mut cef_media_route_create_result_t {
        &mut self.0
    }
}
impl From<cef_media_route_create_result_t> for MediaRouteCreateResult {
    fn from(value: cef_media_route_create_result_t) -> Self {
        Self(value)
    }
}
impl Into<cef_media_route_create_result_t> for MediaRouteCreateResult {
    fn into(self) -> cef_media_route_create_result_t {
        self.0
    }
}
impl Default for MediaRouteCreateResult {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_media_route_connection_state_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MediaRouteConnectionState(cef_media_route_connection_state_t);
impl AsRef<cef_media_route_connection_state_t> for MediaRouteConnectionState {
    fn as_ref(&self) -> &cef_media_route_connection_state_t {
        &self.0
    }
}
impl AsMut<cef_media_route_connection_state_t> for MediaRouteConnectionState {
    fn as_mut(&mut self) -> &mut cef_media_route_connection_state_t {
        &mut self.0
    }
}
impl From<cef_media_route_connection_state_t> for MediaRouteConnectionState {
    fn from(value: cef_media_route_connection_state_t) -> Self {
        Self(value)
    }
}
impl Into<cef_media_route_connection_state_t> for MediaRouteConnectionState {
    fn into(self) -> cef_media_route_connection_state_t {
        self.0
    }
}
impl Default for MediaRouteConnectionState {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_media_sink_icon_type_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MediaSinkIconType(cef_media_sink_icon_type_t);
impl AsRef<cef_media_sink_icon_type_t> for MediaSinkIconType {
    fn as_ref(&self) -> &cef_media_sink_icon_type_t {
        &self.0
    }
}
impl AsMut<cef_media_sink_icon_type_t> for MediaSinkIconType {
    fn as_mut(&mut self) -> &mut cef_media_sink_icon_type_t {
        &mut self.0
    }
}
impl From<cef_media_sink_icon_type_t> for MediaSinkIconType {
    fn from(value: cef_media_sink_icon_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_media_sink_icon_type_t> for MediaSinkIconType {
    fn into(self) -> cef_media_sink_icon_type_t {
        self.0
    }
}
impl Default for MediaSinkIconType {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_text_field_commands_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct TextFieldCommands(cef_text_field_commands_t);
impl AsRef<cef_text_field_commands_t> for TextFieldCommands {
    fn as_ref(&self) -> &cef_text_field_commands_t {
        &self.0
    }
}
impl AsMut<cef_text_field_commands_t> for TextFieldCommands {
    fn as_mut(&mut self) -> &mut cef_text_field_commands_t {
        &mut self.0
    }
}
impl From<cef_text_field_commands_t> for TextFieldCommands {
    fn from(value: cef_text_field_commands_t) -> Self {
        Self(value)
    }
}
impl Into<cef_text_field_commands_t> for TextFieldCommands {
    fn into(self) -> cef_text_field_commands_t {
        self.0
    }
}
impl Default for TextFieldCommands {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_chrome_toolbar_type_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ChromeToolbarType(cef_chrome_toolbar_type_t);
impl AsRef<cef_chrome_toolbar_type_t> for ChromeToolbarType {
    fn as_ref(&self) -> &cef_chrome_toolbar_type_t {
        &self.0
    }
}
impl AsMut<cef_chrome_toolbar_type_t> for ChromeToolbarType {
    fn as_mut(&mut self) -> &mut cef_chrome_toolbar_type_t {
        &mut self.0
    }
}
impl From<cef_chrome_toolbar_type_t> for ChromeToolbarType {
    fn from(value: cef_chrome_toolbar_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_chrome_toolbar_type_t> for ChromeToolbarType {
    fn into(self) -> cef_chrome_toolbar_type_t {
        self.0
    }
}
impl Default for ChromeToolbarType {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_chrome_page_action_icon_type_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ChromePageActionIconType(cef_chrome_page_action_icon_type_t);
impl AsRef<cef_chrome_page_action_icon_type_t> for ChromePageActionIconType {
    fn as_ref(&self) -> &cef_chrome_page_action_icon_type_t {
        &self.0
    }
}
impl AsMut<cef_chrome_page_action_icon_type_t> for ChromePageActionIconType {
    fn as_mut(&mut self) -> &mut cef_chrome_page_action_icon_type_t {
        &mut self.0
    }
}
impl From<cef_chrome_page_action_icon_type_t> for ChromePageActionIconType {
    fn from(value: cef_chrome_page_action_icon_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_chrome_page_action_icon_type_t> for ChromePageActionIconType {
    fn into(self) -> cef_chrome_page_action_icon_type_t {
        self.0
    }
}
impl Default for ChromePageActionIconType {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_chrome_toolbar_button_type_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ChromeToolbarButtonType(cef_chrome_toolbar_button_type_t);
impl AsRef<cef_chrome_toolbar_button_type_t> for ChromeToolbarButtonType {
    fn as_ref(&self) -> &cef_chrome_toolbar_button_type_t {
        &self.0
    }
}
impl AsMut<cef_chrome_toolbar_button_type_t> for ChromeToolbarButtonType {
    fn as_mut(&mut self) -> &mut cef_chrome_toolbar_button_type_t {
        &mut self.0
    }
}
impl From<cef_chrome_toolbar_button_type_t> for ChromeToolbarButtonType {
    fn from(value: cef_chrome_toolbar_button_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_chrome_toolbar_button_type_t> for ChromeToolbarButtonType {
    fn into(self) -> cef_chrome_toolbar_button_type_t {
        self.0
    }
}
impl Default for ChromeToolbarButtonType {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_docking_mode_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct DockingMode(cef_docking_mode_t);
impl AsRef<cef_docking_mode_t> for DockingMode {
    fn as_ref(&self) -> &cef_docking_mode_t {
        &self.0
    }
}
impl AsMut<cef_docking_mode_t> for DockingMode {
    fn as_mut(&mut self) -> &mut cef_docking_mode_t {
        &mut self.0
    }
}
impl From<cef_docking_mode_t> for DockingMode {
    fn from(value: cef_docking_mode_t) -> Self {
        Self(value)
    }
}
impl Into<cef_docking_mode_t> for DockingMode {
    fn into(self) -> cef_docking_mode_t {
        self.0
    }
}
impl Default for DockingMode {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_show_state_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ShowState(cef_show_state_t);
impl AsRef<cef_show_state_t> for ShowState {
    fn as_ref(&self) -> &cef_show_state_t {
        &self.0
    }
}
impl AsMut<cef_show_state_t> for ShowState {
    fn as_mut(&mut self) -> &mut cef_show_state_t {
        &mut self.0
    }
}
impl From<cef_show_state_t> for ShowState {
    fn from(value: cef_show_state_t) -> Self {
        Self(value)
    }
}
impl Into<cef_show_state_t> for ShowState {
    fn into(self) -> cef_show_state_t {
        self.0
    }
}
impl Default for ShowState {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_touch_handle_state_flags_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct TouchHandleStateFlags(cef_touch_handle_state_flags_t);
impl AsRef<cef_touch_handle_state_flags_t> for TouchHandleStateFlags {
    fn as_ref(&self) -> &cef_touch_handle_state_flags_t {
        &self.0
    }
}
impl AsMut<cef_touch_handle_state_flags_t> for TouchHandleStateFlags {
    fn as_mut(&mut self) -> &mut cef_touch_handle_state_flags_t {
        &mut self.0
    }
}
impl From<cef_touch_handle_state_flags_t> for TouchHandleStateFlags {
    fn from(value: cef_touch_handle_state_flags_t) -> Self {
        Self(value)
    }
}
impl Into<cef_touch_handle_state_flags_t> for TouchHandleStateFlags {
    fn into(self) -> cef_touch_handle_state_flags_t {
        self.0
    }
}
impl Default for TouchHandleStateFlags {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_media_access_permission_types_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MediaAccessPermissionTypes(cef_media_access_permission_types_t);
impl AsRef<cef_media_access_permission_types_t> for MediaAccessPermissionTypes {
    fn as_ref(&self) -> &cef_media_access_permission_types_t {
        &self.0
    }
}
impl AsMut<cef_media_access_permission_types_t> for MediaAccessPermissionTypes {
    fn as_mut(&mut self) -> &mut cef_media_access_permission_types_t {
        &mut self.0
    }
}
impl From<cef_media_access_permission_types_t> for MediaAccessPermissionTypes {
    fn from(value: cef_media_access_permission_types_t) -> Self {
        Self(value)
    }
}
impl Into<cef_media_access_permission_types_t> for MediaAccessPermissionTypes {
    fn into(self) -> cef_media_access_permission_types_t {
        self.0
    }
}
impl Default for MediaAccessPermissionTypes {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_permission_request_types_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct PermissionRequestTypes(cef_permission_request_types_t);
impl AsRef<cef_permission_request_types_t> for PermissionRequestTypes {
    fn as_ref(&self) -> &cef_permission_request_types_t {
        &self.0
    }
}
impl AsMut<cef_permission_request_types_t> for PermissionRequestTypes {
    fn as_mut(&mut self) -> &mut cef_permission_request_types_t {
        &mut self.0
    }
}
impl From<cef_permission_request_types_t> for PermissionRequestTypes {
    fn from(value: cef_permission_request_types_t) -> Self {
        Self(value)
    }
}
impl Into<cef_permission_request_types_t> for PermissionRequestTypes {
    fn into(self) -> cef_permission_request_types_t {
        self.0
    }
}
impl Default for PermissionRequestTypes {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_permission_request_result_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct PermissionRequestResult(cef_permission_request_result_t);
impl AsRef<cef_permission_request_result_t> for PermissionRequestResult {
    fn as_ref(&self) -> &cef_permission_request_result_t {
        &self.0
    }
}
impl AsMut<cef_permission_request_result_t> for PermissionRequestResult {
    fn as_mut(&mut self) -> &mut cef_permission_request_result_t {
        &mut self.0
    }
}
impl From<cef_permission_request_result_t> for PermissionRequestResult {
    fn from(value: cef_permission_request_result_t) -> Self {
        Self(value)
    }
}
impl Into<cef_permission_request_result_t> for PermissionRequestResult {
    fn into(self) -> cef_permission_request_result_t {
        self.0
    }
}
impl Default for PermissionRequestResult {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_test_cert_type_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct TestCertType(cef_test_cert_type_t);
impl AsRef<cef_test_cert_type_t> for TestCertType {
    fn as_ref(&self) -> &cef_test_cert_type_t {
        &self.0
    }
}
impl AsMut<cef_test_cert_type_t> for TestCertType {
    fn as_mut(&mut self) -> &mut cef_test_cert_type_t {
        &mut self.0
    }
}
impl From<cef_test_cert_type_t> for TestCertType {
    fn from(value: cef_test_cert_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_test_cert_type_t> for TestCertType {
    fn into(self) -> cef_test_cert_type_t {
        self.0
    }
}
impl Default for TestCertType {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_preferences_type_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct PreferencesType(cef_preferences_type_t);
impl AsRef<cef_preferences_type_t> for PreferencesType {
    fn as_ref(&self) -> &cef_preferences_type_t {
        &self.0
    }
}
impl AsMut<cef_preferences_type_t> for PreferencesType {
    fn as_mut(&mut self) -> &mut cef_preferences_type_t {
        &mut self.0
    }
}
impl From<cef_preferences_type_t> for PreferencesType {
    fn from(value: cef_preferences_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_preferences_type_t> for PreferencesType {
    fn into(self) -> cef_preferences_type_t {
        self.0
    }
}
impl Default for PreferencesType {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_download_interrupt_reason_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct DownloadInterruptReason(cef_download_interrupt_reason_t);
impl AsRef<cef_download_interrupt_reason_t> for DownloadInterruptReason {
    fn as_ref(&self) -> &cef_download_interrupt_reason_t {
        &self.0
    }
}
impl AsMut<cef_download_interrupt_reason_t> for DownloadInterruptReason {
    fn as_mut(&mut self) -> &mut cef_download_interrupt_reason_t {
        &mut self.0
    }
}
impl From<cef_download_interrupt_reason_t> for DownloadInterruptReason {
    fn from(value: cef_download_interrupt_reason_t) -> Self {
        Self(value)
    }
}
impl Into<cef_download_interrupt_reason_t> for DownloadInterruptReason {
    fn into(self) -> cef_download_interrupt_reason_t {
        self.0
    }
}
impl Default for DownloadInterruptReason {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_gesture_command_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct GestureCommand(cef_gesture_command_t);
impl AsRef<cef_gesture_command_t> for GestureCommand {
    fn as_ref(&self) -> &cef_gesture_command_t {
        &self.0
    }
}
impl AsMut<cef_gesture_command_t> for GestureCommand {
    fn as_mut(&mut self) -> &mut cef_gesture_command_t {
        &mut self.0
    }
}
impl From<cef_gesture_command_t> for GestureCommand {
    fn from(value: cef_gesture_command_t) -> Self {
        Self(value)
    }
}
impl Into<cef_gesture_command_t> for GestureCommand {
    fn into(self) -> cef_gesture_command_t {
        self.0
    }
}
impl Default for GestureCommand {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_zoom_command_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ZoomCommand(cef_zoom_command_t);
impl AsRef<cef_zoom_command_t> for ZoomCommand {
    fn as_ref(&self) -> &cef_zoom_command_t {
        &self.0
    }
}
impl AsMut<cef_zoom_command_t> for ZoomCommand {
    fn as_mut(&mut self) -> &mut cef_zoom_command_t {
        &mut self.0
    }
}
impl From<cef_zoom_command_t> for ZoomCommand {
    fn from(value: cef_zoom_command_t) -> Self {
        Self(value)
    }
}
impl Into<cef_zoom_command_t> for ZoomCommand {
    fn into(self) -> cef_zoom_command_t {
        self.0
    }
}
impl Default for ZoomCommand {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_color_variant_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ColorVariant(cef_color_variant_t);
impl AsRef<cef_color_variant_t> for ColorVariant {
    fn as_ref(&self) -> &cef_color_variant_t {
        &self.0
    }
}
impl AsMut<cef_color_variant_t> for ColorVariant {
    fn as_mut(&mut self) -> &mut cef_color_variant_t {
        &mut self.0
    }
}
impl From<cef_color_variant_t> for ColorVariant {
    fn from(value: cef_color_variant_t) -> Self {
        Self(value)
    }
}
impl Into<cef_color_variant_t> for ColorVariant {
    fn into(self) -> cef_color_variant_t {
        self.0
    }
}
impl Default for ColorVariant {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}
#[doc = "See [cef_task_type_t] for more documentation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct TaskType(cef_task_type_t);
impl AsRef<cef_task_type_t> for TaskType {
    fn as_ref(&self) -> &cef_task_type_t {
        &self.0
    }
}
impl AsMut<cef_task_type_t> for TaskType {
    fn as_mut(&mut self) -> &mut cef_task_type_t {
        &mut self.0
    }
}
impl From<cef_task_type_t> for TaskType {
    fn from(value: cef_task_type_t) -> Self {
        Self(value)
    }
}
impl Into<cef_task_type_t> for TaskType {
    fn into(self) -> cef_task_type_t {
        self.0
    }
}
impl Default for TaskType {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

// Global function wrappers
pub fn string_wide_set<'a>(
    src: wchar_t,
    output: &'a mut CefStringWide,
    copy: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_src, arg_output, arg_copy) = (src, output, copy);
        let arg_src_len = arg_src.map(|slice| slice.len()).unwrap_or_default();
        let out_src = arg_src;
        let arg_src = arg_src
            .and_then(|slice| {
                if slice.is_empty() {
                    None
                } else {
                    Some(slice.as_ptr() as *const _)
                }
            })
            .unwrap_or(std::ptr::null());
        let arg_output = arg_output.as_raw();
        let arg_copy = arg_copy;
        let result = cef_string_wide_set(arg_src, arg_src_len, arg_output, arg_copy);
        result.as_wrapper()
    }
}
pub fn string_utf8_set<'a>(
    src: ::std::os::raw::c_char,
    output: &'a mut CefStringUtf8,
    copy: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_src, arg_output, arg_copy) = (src, output, copy);
        let arg_src_len = arg_src.map(|slice| slice.len()).unwrap_or_default();
        let out_src = arg_src;
        let arg_src = arg_src
            .and_then(|slice| {
                if slice.is_empty() {
                    None
                } else {
                    Some(slice.as_ptr() as *const _)
                }
            })
            .unwrap_or(std::ptr::null());
        let arg_output = arg_output.as_raw();
        let arg_copy = arg_copy;
        let result = cef_string_utf8_set(arg_src, arg_src_len, arg_output, arg_copy);
        result.as_wrapper()
    }
}
pub fn string_utf16_set<'a>(
    src: char16_t,
    output: &'a mut CefStringUtf16,
    copy: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_src, arg_output, arg_copy) = (src, output, copy);
        let arg_src_len = arg_src.map(|slice| slice.len()).unwrap_or_default();
        let out_src = arg_src;
        let arg_src = arg_src
            .and_then(|slice| {
                if slice.is_empty() {
                    None
                } else {
                    Some(slice.as_ptr() as *const _)
                }
            })
            .unwrap_or(std::ptr::null());
        let arg_output = arg_output.as_raw();
        let arg_copy = arg_copy;
        let result = cef_string_utf16_set(arg_src, arg_src_len, arg_output, arg_copy);
        result.as_wrapper()
    }
}
pub fn string_wide_clear<'a>(str_: &'a mut CefStringWide) {
    unsafe {
        let arg_str_ = str_;
        let arg_str_ = arg_str_.as_raw();
        let result = cef_string_wide_clear(arg_str_);
        result
    }
}
pub fn string_utf8_clear<'a>(str_: &'a mut CefStringUtf8) {
    unsafe {
        let arg_str_ = str_;
        let arg_str_ = arg_str_.as_raw();
        let result = cef_string_utf8_clear(arg_str_);
        result
    }
}
pub fn string_utf16_clear<'a>(str_: &'a mut CefStringUtf16) {
    unsafe {
        let arg_str_ = str_;
        let arg_str_ = arg_str_.as_raw();
        let result = cef_string_utf16_clear(arg_str_);
        result
    }
}
pub fn string_wide_cmp<'a>(
    str_1: &'a CefStringWide,
    str_2: &'a CefStringWide,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_str_1, arg_str_2) = (str_1, str_2);
        let arg_str_1 = arg_str_1.as_raw();
        let arg_str_2 = arg_str_2.as_raw();
        let result = cef_string_wide_cmp(arg_str_1, arg_str_2);
        result.as_wrapper()
    }
}
pub fn string_utf8_cmp<'a>(
    str_1: &'a CefStringUtf8,
    str_2: &'a CefStringUtf8,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_str_1, arg_str_2) = (str_1, str_2);
        let arg_str_1 = arg_str_1.as_raw();
        let arg_str_2 = arg_str_2.as_raw();
        let result = cef_string_utf8_cmp(arg_str_1, arg_str_2);
        result.as_wrapper()
    }
}
pub fn string_utf16_cmp<'a>(
    str_1: &'a CefStringUtf16,
    str_2: &'a CefStringUtf16,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_str_1, arg_str_2) = (str_1, str_2);
        let arg_str_1 = arg_str_1.as_raw();
        let arg_str_2 = arg_str_2.as_raw();
        let result = cef_string_utf16_cmp(arg_str_1, arg_str_2);
        result.as_wrapper()
    }
}
pub fn string_wide_to_utf8<'a>(
    src: wchar_t,
    output: &'a mut CefStringUtf8,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_src, arg_output) = (src, output);
        let arg_src_len = arg_src.map(|slice| slice.len()).unwrap_or_default();
        let out_src = arg_src;
        let arg_src = arg_src
            .and_then(|slice| {
                if slice.is_empty() {
                    None
                } else {
                    Some(slice.as_ptr() as *const _)
                }
            })
            .unwrap_or(std::ptr::null());
        let arg_output = arg_output.as_raw();
        let result = cef_string_wide_to_utf8(arg_src, arg_src_len, arg_output);
        result.as_wrapper()
    }
}
pub fn string_utf8_to_wide<'a>(
    src: ::std::os::raw::c_char,
    output: &'a mut CefStringWide,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_src, arg_output) = (src, output);
        let arg_src_len = arg_src.map(|slice| slice.len()).unwrap_or_default();
        let out_src = arg_src;
        let arg_src = arg_src
            .and_then(|slice| {
                if slice.is_empty() {
                    None
                } else {
                    Some(slice.as_ptr() as *const _)
                }
            })
            .unwrap_or(std::ptr::null());
        let arg_output = arg_output.as_raw();
        let result = cef_string_utf8_to_wide(arg_src, arg_src_len, arg_output);
        result.as_wrapper()
    }
}
pub fn string_wide_to_utf16<'a>(
    src: wchar_t,
    output: &'a mut CefStringUtf16,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_src, arg_output) = (src, output);
        let arg_src_len = arg_src.map(|slice| slice.len()).unwrap_or_default();
        let out_src = arg_src;
        let arg_src = arg_src
            .and_then(|slice| {
                if slice.is_empty() {
                    None
                } else {
                    Some(slice.as_ptr() as *const _)
                }
            })
            .unwrap_or(std::ptr::null());
        let arg_output = arg_output.as_raw();
        let result = cef_string_wide_to_utf16(arg_src, arg_src_len, arg_output);
        result.as_wrapper()
    }
}
pub fn string_utf16_to_wide<'a>(
    src: char16_t,
    output: &'a mut CefStringWide,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_src, arg_output) = (src, output);
        let arg_src_len = arg_src.map(|slice| slice.len()).unwrap_or_default();
        let out_src = arg_src;
        let arg_src = arg_src
            .and_then(|slice| {
                if slice.is_empty() {
                    None
                } else {
                    Some(slice.as_ptr() as *const _)
                }
            })
            .unwrap_or(std::ptr::null());
        let arg_output = arg_output.as_raw();
        let result = cef_string_utf16_to_wide(arg_src, arg_src_len, arg_output);
        result.as_wrapper()
    }
}
pub fn string_utf8_to_utf16<'a>(
    src: ::std::os::raw::c_char,
    output: &'a mut CefStringUtf16,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_src, arg_output) = (src, output);
        let arg_src_len = arg_src.map(|slice| slice.len()).unwrap_or_default();
        let out_src = arg_src;
        let arg_src = arg_src
            .and_then(|slice| {
                if slice.is_empty() {
                    None
                } else {
                    Some(slice.as_ptr() as *const _)
                }
            })
            .unwrap_or(std::ptr::null());
        let arg_output = arg_output.as_raw();
        let result = cef_string_utf8_to_utf16(arg_src, arg_src_len, arg_output);
        result.as_wrapper()
    }
}
pub fn string_utf16_to_utf8<'a>(
    src: char16_t,
    output: &'a mut CefStringUtf8,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_src, arg_output) = (src, output);
        let arg_src_len = arg_src.map(|slice| slice.len()).unwrap_or_default();
        let out_src = arg_src;
        let arg_src = arg_src
            .and_then(|slice| {
                if slice.is_empty() {
                    None
                } else {
                    Some(slice.as_ptr() as *const _)
                }
            })
            .unwrap_or(std::ptr::null());
        let arg_output = arg_output.as_raw();
        let result = cef_string_utf16_to_utf8(arg_src, arg_src_len, arg_output);
        result.as_wrapper()
    }
}
pub fn string_ascii_to_wide<'a>(
    src: ::std::os::raw::c_char,
    output: &'a mut CefStringWide,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_src, arg_output) = (src, output);
        let arg_src_len = arg_src.map(|slice| slice.len()).unwrap_or_default();
        let out_src = arg_src;
        let arg_src = arg_src
            .and_then(|slice| {
                if slice.is_empty() {
                    None
                } else {
                    Some(slice.as_ptr() as *const _)
                }
            })
            .unwrap_or(std::ptr::null());
        let arg_output = arg_output.as_raw();
        let result = cef_string_ascii_to_wide(arg_src, arg_src_len, arg_output);
        result.as_wrapper()
    }
}
pub fn string_ascii_to_utf16<'a>(
    src: ::std::os::raw::c_char,
    output: &'a mut CefStringUtf16,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_src, arg_output) = (src, output);
        let arg_src_len = arg_src.map(|slice| slice.len()).unwrap_or_default();
        let out_src = arg_src;
        let arg_src = arg_src
            .and_then(|slice| {
                if slice.is_empty() {
                    None
                } else {
                    Some(slice.as_ptr() as *const _)
                }
            })
            .unwrap_or(std::ptr::null());
        let arg_output = arg_output.as_raw();
        let result = cef_string_ascii_to_utf16(arg_src, arg_src_len, arg_output);
        result.as_wrapper()
    }
}
pub fn string_userfree_wide_alloc<'a>() -> CefStringWide {
    unsafe {
        let result = cef_string_userfree_wide_alloc();
        result.as_wrapper()
    }
}
pub fn string_userfree_utf8_alloc<'a>() -> CefStringUtf8 {
    unsafe {
        let result = cef_string_userfree_utf8_alloc();
        result.as_wrapper()
    }
}
pub fn string_userfree_utf16_alloc<'a>() -> CefStringUtf16 {
    unsafe {
        let result = cef_string_userfree_utf16_alloc();
        result.as_wrapper()
    }
}
pub fn string_userfree_wide_free<'a>(str_: &'a mut CefStringWide) {
    unsafe {
        let arg_str_ = str_;
        let arg_str_ = arg_str_.as_raw();
        let result = cef_string_userfree_wide_free(arg_str_);
        result
    }
}
pub fn string_userfree_utf8_free<'a>(str_: &'a mut CefStringUtf8) {
    unsafe {
        let arg_str_ = str_;
        let arg_str_ = arg_str_.as_raw();
        let result = cef_string_userfree_utf8_free(arg_str_);
        result
    }
}
pub fn string_userfree_utf16_free<'a>(str_: &'a mut CefStringUtf16) {
    unsafe {
        let arg_str_ = str_;
        let arg_str_ = arg_str_.as_raw();
        let result = cef_string_userfree_utf16_free(arg_str_);
        result
    }
}
pub fn string_utf16_to_lower<'a>(
    src: char16_t,
    output: &'a mut CefStringUtf16,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_src, arg_output) = (src, output);
        let arg_src_len = arg_src.map(|slice| slice.len()).unwrap_or_default();
        let out_src = arg_src;
        let arg_src = arg_src
            .and_then(|slice| {
                if slice.is_empty() {
                    None
                } else {
                    Some(slice.as_ptr() as *const _)
                }
            })
            .unwrap_or(std::ptr::null());
        let arg_output = arg_output.as_raw();
        let result = cef_string_utf16_to_lower(arg_src, arg_src_len, arg_output);
        result.as_wrapper()
    }
}
pub fn string_utf16_to_upper<'a>(
    src: char16_t,
    output: &'a mut CefStringUtf16,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_src, arg_output) = (src, output);
        let arg_src_len = arg_src.map(|slice| slice.len()).unwrap_or_default();
        let out_src = arg_src;
        let arg_src = arg_src
            .and_then(|slice| {
                if slice.is_empty() {
                    None
                } else {
                    Some(slice.as_ptr() as *const _)
                }
            })
            .unwrap_or(std::ptr::null());
        let arg_output = arg_output.as_raw();
        let result = cef_string_utf16_to_upper(arg_src, arg_src_len, arg_output);
        result.as_wrapper()
    }
}
pub fn string_list_alloc<'a>() -> CefStringList {
    unsafe {
        let result = cef_string_list_alloc();
        result.as_wrapper()
    }
}
pub fn string_list_size<'a>(list: &'a mut CefStringList) -> usize {
    unsafe {
        let arg_list = list;
        let arg_list = arg_list.as_raw();
        let result = cef_string_list_size(arg_list);
        result.as_wrapper()
    }
}
pub fn string_list_value<'a>(
    list: &'a mut CefStringList,
    index: usize,
    value: &'a mut CefStringUtf16,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_list, arg_index, arg_value) = (list, index, value);
        let arg_list = arg_list.as_raw();
        let arg_index = arg_index;
        let arg_value = arg_value.as_raw();
        let result = cef_string_list_value(arg_list, arg_index, arg_value);
        result.as_wrapper()
    }
}
pub fn string_list_append<'a>(list: &'a mut CefStringList, value: &'a CefStringUtf16) {
    unsafe {
        let (arg_list, arg_value) = (list, value);
        let arg_list = arg_list.as_raw();
        let arg_value = arg_value.as_raw();
        let result = cef_string_list_append(arg_list, arg_value);
        result
    }
}
pub fn string_list_clear<'a>(list: &'a mut CefStringList) {
    unsafe {
        let arg_list = list;
        let arg_list = arg_list.as_raw();
        let result = cef_string_list_clear(arg_list);
        result
    }
}
pub fn string_list_free<'a>(list: &'a mut CefStringList) {
    unsafe {
        let arg_list = list;
        let arg_list = arg_list.as_raw();
        let result = cef_string_list_free(arg_list);
        result
    }
}
pub fn string_list_copy<'a>(list: &'a mut CefStringList) -> CefStringList {
    unsafe {
        let arg_list = list;
        let arg_list = arg_list.as_raw();
        let result = cef_string_list_copy(arg_list);
        result.as_wrapper()
    }
}
pub fn string_map_alloc<'a>() -> CefStringMap {
    unsafe {
        let result = cef_string_map_alloc();
        result.as_wrapper()
    }
}
pub fn string_map_size<'a>(map: &'a mut CefStringMap) -> usize {
    unsafe {
        let arg_map = map;
        let arg_map = arg_map.as_raw();
        let result = cef_string_map_size(arg_map);
        result.as_wrapper()
    }
}
pub fn string_map_find<'a>(
    map: &'a mut CefStringMap,
    key: &'a CefStringUtf16,
    value: &'a mut CefStringUtf16,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_map, arg_key, arg_value) = (map, key, value);
        let arg_map = arg_map.as_raw();
        let arg_key = arg_key.as_raw();
        let arg_value = arg_value.as_raw();
        let result = cef_string_map_find(arg_map, arg_key, arg_value);
        result.as_wrapper()
    }
}
pub fn string_map_key<'a>(
    map: &'a mut CefStringMap,
    index: usize,
    key: &'a mut CefStringUtf16,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_map, arg_index, arg_key) = (map, index, key);
        let arg_map = arg_map.as_raw();
        let arg_index = arg_index;
        let arg_key = arg_key.as_raw();
        let result = cef_string_map_key(arg_map, arg_index, arg_key);
        result.as_wrapper()
    }
}
pub fn string_map_value<'a>(
    map: &'a mut CefStringMap,
    index: usize,
    value: &'a mut CefStringUtf16,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_map, arg_index, arg_value) = (map, index, value);
        let arg_map = arg_map.as_raw();
        let arg_index = arg_index;
        let arg_value = arg_value.as_raw();
        let result = cef_string_map_value(arg_map, arg_index, arg_value);
        result.as_wrapper()
    }
}
pub fn string_map_append<'a>(
    map: &'a mut CefStringMap,
    key: &'a CefStringUtf16,
    value: &'a CefStringUtf16,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_map, arg_key, arg_value) = (map, key, value);
        let arg_map = arg_map.as_raw();
        let arg_key = arg_key.as_raw();
        let arg_value = arg_value.as_raw();
        let result = cef_string_map_append(arg_map, arg_key, arg_value);
        result.as_wrapper()
    }
}
pub fn string_map_clear<'a>(map: &'a mut CefStringMap) {
    unsafe {
        let arg_map = map;
        let arg_map = arg_map.as_raw();
        let result = cef_string_map_clear(arg_map);
        result
    }
}
pub fn string_map_free<'a>(map: &'a mut CefStringMap) {
    unsafe {
        let arg_map = map;
        let arg_map = arg_map.as_raw();
        let result = cef_string_map_free(arg_map);
        result
    }
}
pub fn string_multimap_alloc<'a>() -> CefStringMultimap {
    unsafe {
        let result = cef_string_multimap_alloc();
        result.as_wrapper()
    }
}
pub fn string_multimap_size<'a>(map: &'a mut CefStringMultimap) -> usize {
    unsafe {
        let arg_map = map;
        let arg_map = arg_map.as_raw();
        let result = cef_string_multimap_size(arg_map);
        result.as_wrapper()
    }
}
pub fn string_multimap_find_count<'a>(
    map: &'a mut CefStringMultimap,
    key: &'a CefStringUtf16,
) -> usize {
    unsafe {
        let (arg_map, arg_key) = (map, key);
        let arg_map = arg_map.as_raw();
        let arg_key = arg_key.as_raw();
        let result = cef_string_multimap_find_count(arg_map, arg_key);
        result.as_wrapper()
    }
}
pub fn string_multimap_enumerate<'a>(
    map: &'a mut CefStringMultimap,
    key: &'a CefStringUtf16,
    value_index: usize,
    value: &'a mut CefStringUtf16,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_map, arg_key, arg_value_index, arg_value) = (map, key, value_index, value);
        let arg_map = arg_map.as_raw();
        let arg_key = arg_key.as_raw();
        let arg_value_index = arg_value_index;
        let arg_value = arg_value.as_raw();
        let result = cef_string_multimap_enumerate(arg_map, arg_key, arg_value_index, arg_value);
        result.as_wrapper()
    }
}
pub fn string_multimap_key<'a>(
    map: &'a mut CefStringMultimap,
    index: usize,
    key: &'a mut CefStringUtf16,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_map, arg_index, arg_key) = (map, index, key);
        let arg_map = arg_map.as_raw();
        let arg_index = arg_index;
        let arg_key = arg_key.as_raw();
        let result = cef_string_multimap_key(arg_map, arg_index, arg_key);
        result.as_wrapper()
    }
}
pub fn string_multimap_value<'a>(
    map: &'a mut CefStringMultimap,
    index: usize,
    value: &'a mut CefStringUtf16,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_map, arg_index, arg_value) = (map, index, value);
        let arg_map = arg_map.as_raw();
        let arg_index = arg_index;
        let arg_value = arg_value.as_raw();
        let result = cef_string_multimap_value(arg_map, arg_index, arg_value);
        result.as_wrapper()
    }
}
pub fn string_multimap_append<'a>(
    map: &'a mut CefStringMultimap,
    key: &'a CefStringUtf16,
    value: &'a CefStringUtf16,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_map, arg_key, arg_value) = (map, key, value);
        let arg_map = arg_map.as_raw();
        let arg_key = arg_key.as_raw();
        let arg_value = arg_value.as_raw();
        let result = cef_string_multimap_append(arg_map, arg_key, arg_value);
        result.as_wrapper()
    }
}
pub fn string_multimap_clear<'a>(map: &'a mut CefStringMultimap) {
    unsafe {
        let arg_map = map;
        let arg_map = arg_map.as_raw();
        let result = cef_string_multimap_clear(arg_map);
        result
    }
}
pub fn string_multimap_free<'a>(map: &'a mut CefStringMultimap) {
    unsafe {
        let arg_map = map;
        let arg_map = arg_map.as_raw();
        let result = cef_string_multimap_free(arg_map);
        result
    }
}
pub fn time_to_timet<'a>(cef_time: &'a Time, time: *mut time_t) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_cef_time, arg_time) = (cef_time, time);
        let mut arg_cef_time: _cef_time_t = arg_cef_time.clone().into();
        let arg_cef_time = &mut arg_cef_time;
        let arg_time = arg_time as *mut _;
        let result = cef_time_to_timet(arg_cef_time, arg_time);
        result.as_wrapper()
    }
}
pub fn time_from_timet<'a>(time: time_t, cef_time: &'a mut Time) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_time, arg_cef_time) = (time, cef_time);
        let arg_time = arg_time;
        let mut arg_cef_time: _cef_time_t = arg_cef_time.clone().into();
        let arg_cef_time = &mut arg_cef_time;
        let result = cef_time_from_timet(arg_time, arg_cef_time);
        result.as_wrapper()
    }
}
pub fn time_to_doublet<'a>(cef_time: &'a Time, time: *mut f64) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_cef_time, arg_time) = (cef_time, time);
        let mut arg_cef_time: _cef_time_t = arg_cef_time.clone().into();
        let arg_cef_time = &mut arg_cef_time;
        let arg_time = arg_time as *mut _;
        let result = cef_time_to_doublet(arg_cef_time, arg_time);
        result.as_wrapper()
    }
}
pub fn time_from_doublet<'a>(time: f64, cef_time: &'a mut Time) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_time, arg_cef_time) = (time, cef_time);
        let arg_time = arg_time;
        let mut arg_cef_time: _cef_time_t = arg_cef_time.clone().into();
        let arg_cef_time = &mut arg_cef_time;
        let result = cef_time_from_doublet(arg_time, arg_cef_time);
        result.as_wrapper()
    }
}
pub fn time_now<'a>(cef_time: &'a mut Time) -> ::std::os::raw::c_int {
    unsafe {
        let arg_cef_time = cef_time;
        let mut arg_cef_time: _cef_time_t = arg_cef_time.clone().into();
        let arg_cef_time = &mut arg_cef_time;
        let result = cef_time_now(arg_cef_time);
        result.as_wrapper()
    }
}
pub fn basetime_now<'a>() -> Basetime {
    unsafe {
        let result = cef_basetime_now();
        result.as_wrapper()
    }
}
pub fn time_delta<'a>(
    cef_time_1: &'a Time,
    cef_time_2: &'a Time,
    delta: *mut ::std::os::raw::c_longlong,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_cef_time_1, arg_cef_time_2, arg_delta) = (cef_time_1, cef_time_2, delta);
        let mut arg_cef_time_1: _cef_time_t = arg_cef_time_1.clone().into();
        let arg_cef_time_1 = &mut arg_cef_time_1;
        let mut arg_cef_time_2: _cef_time_t = arg_cef_time_2.clone().into();
        let arg_cef_time_2 = &mut arg_cef_time_2;
        let arg_delta = arg_delta as *mut _;
        let result = cef_time_delta(arg_cef_time_1, arg_cef_time_2, arg_delta);
        result.as_wrapper()
    }
}
pub fn time_to_basetime<'a>(from: &'a Time, to: &'a mut Basetime) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_from, arg_to) = (from, to);
        let mut arg_from: _cef_time_t = arg_from.clone().into();
        let arg_from = &mut arg_from;
        let mut arg_to: _cef_basetime_t = arg_to.clone().into();
        let arg_to = &mut arg_to;
        let result = cef_time_to_basetime(arg_from, arg_to);
        result.as_wrapper()
    }
}
pub fn time_from_basetime<'a>(from: _cef_basetime_t, to: &'a mut Time) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_from, arg_to) = (from, to);
        let mut arg_from: _cef_basetime_t = arg_from.clone().into();
        let arg_from = &mut arg_from;
        let mut arg_to: _cef_time_t = arg_to.clone().into();
        let arg_to = &mut arg_to;
        let result = cef_time_from_basetime(arg_from, arg_to);
        result.as_wrapper()
    }
}
pub fn get_xdisplay<'a>() -> *mut XDisplay {
    unsafe {
        let result = cef_get_xdisplay();
        result.as_wrapper()
    }
}
pub fn value_create<'a>() -> Value {
    unsafe {
        let result = cef_value_create();
        result.as_wrapper()
    }
}
pub fn binary_value_create<'a>(data: Option<&'a [u8]>) -> BinaryValue {
    unsafe {
        let arg_data = data;
        let arg_data_size = arg_data.map(|slice| slice.len()).unwrap_or_default();
        let out_data = arg_data;
        let arg_data = arg_data
            .and_then(|slice| {
                if slice.is_empty() {
                    None
                } else {
                    Some(slice.as_ptr() as *const _)
                }
            })
            .unwrap_or(std::ptr::null());
        let result = cef_binary_value_create(arg_data, arg_data_size);
        result.as_wrapper()
    }
}
pub fn dictionary_value_create<'a>() -> DictionaryValue {
    unsafe {
        let result = cef_dictionary_value_create();
        result.as_wrapper()
    }
}
pub fn list_value_create<'a>() -> ListValue {
    unsafe {
        let result = cef_list_value_create();
        result.as_wrapper()
    }
}
pub fn image_create<'a>() -> Image {
    unsafe {
        let result = cef_image_create();
        result.as_wrapper()
    }
}
pub fn stream_reader_create_for_file<'a>(file_name: &'a CefStringUtf16) -> StreamReader {
    unsafe {
        let arg_file_name = file_name;
        let arg_file_name = arg_file_name.as_raw();
        let result = cef_stream_reader_create_for_file(arg_file_name);
        result.as_wrapper()
    }
}
pub fn stream_reader_create_for_data<'a>(
    data: *mut ::std::os::raw::c_void,
    size: usize,
) -> StreamReader {
    unsafe {
        let (arg_data, arg_size) = (data, size);
        let arg_data = arg_data as *mut _;
        let arg_size = arg_size;
        let result = cef_stream_reader_create_for_data(arg_data, arg_size);
        result.as_wrapper()
    }
}
pub fn stream_reader_create_for_handler<'a>(handler: &'a mut ReadHandler) -> StreamReader {
    unsafe {
        let arg_handler = handler;
        let arg_handler = arg_handler.as_raw();
        let result = cef_stream_reader_create_for_handler(arg_handler);
        result.as_wrapper()
    }
}
pub fn stream_writer_create_for_file<'a>(file_name: &'a CefStringUtf16) -> StreamWriter {
    unsafe {
        let arg_file_name = file_name;
        let arg_file_name = arg_file_name.as_raw();
        let result = cef_stream_writer_create_for_file(arg_file_name);
        result.as_wrapper()
    }
}
pub fn stream_writer_create_for_handler<'a>(handler: &'a mut WriteHandler) -> StreamWriter {
    unsafe {
        let arg_handler = handler;
        let arg_handler = arg_handler.as_raw();
        let result = cef_stream_writer_create_for_handler(arg_handler);
        result.as_wrapper()
    }
}
pub fn drag_data_create<'a>() -> DragData {
    unsafe {
        let result = cef_drag_data_create();
        result.as_wrapper()
    }
}
pub fn process_message_create<'a>(name: &'a CefStringUtf16) -> ProcessMessage {
    unsafe {
        let arg_name = name;
        let arg_name = arg_name.as_raw();
        let result = cef_process_message_create(arg_name);
        result.as_wrapper()
    }
}
pub fn request_create<'a>() -> Request {
    unsafe {
        let result = cef_request_create();
        result.as_wrapper()
    }
}
pub fn post_data_create<'a>() -> PostData {
    unsafe {
        let result = cef_post_data_create();
        result.as_wrapper()
    }
}
pub fn post_data_element_create<'a>() -> PostDataElement {
    unsafe {
        let result = cef_post_data_element_create();
        result.as_wrapper()
    }
}
pub fn cookie_manager_get_global_manager<'a>(
    callback: &'a mut CompletionCallback,
) -> CookieManager {
    unsafe {
        let arg_callback = callback;
        let arg_callback = arg_callback.as_raw();
        let result = cef_cookie_manager_get_global_manager(arg_callback);
        result.as_wrapper()
    }
}
pub fn media_router_get_global<'a>(callback: &'a mut CompletionCallback) -> MediaRouter {
    unsafe {
        let arg_callback = callback;
        let arg_callback = arg_callback.as_raw();
        let result = cef_media_router_get_global(arg_callback);
        result.as_wrapper()
    }
}
pub fn preference_manager_get_global<'a>() -> PreferenceManager {
    unsafe {
        let result = cef_preference_manager_get_global();
        result.as_wrapper()
    }
}
pub fn request_context_get_global_context<'a>() -> RequestContext {
    unsafe {
        let result = cef_request_context_get_global_context();
        result.as_wrapper()
    }
}
pub fn request_context_create_context<'a>(
    settings: &'a RequestContextSettings,
    handler: &'a mut RequestContextHandler,
) -> RequestContext {
    unsafe {
        let (arg_settings, arg_handler) = (settings, handler);
        let mut arg_settings: _cef_request_context_settings_t = arg_settings.clone().into();
        let arg_settings = &mut arg_settings;
        let arg_handler = arg_handler.as_raw();
        let result = cef_request_context_create_context(arg_settings, arg_handler);
        result.as_wrapper()
    }
}
pub fn create_context_shared<'a>(
    other: &'a mut RequestContext,
    handler: &'a mut RequestContextHandler,
) -> RequestContext {
    unsafe {
        let (arg_other, arg_handler) = (other, handler);
        let arg_other = arg_other.as_raw();
        let arg_handler = arg_handler.as_raw();
        let result = cef_create_context_shared(arg_other, arg_handler);
        result.as_wrapper()
    }
}
pub fn browser_host_create_browser<'a>(
    window_info: &'a WindowInfo,
    client: &'a mut Client,
    url: &'a CefStringUtf16,
    settings: &'a BrowserSettings,
    extra_info: &'a mut DictionaryValue,
    request_context: &'a mut RequestContext,
) -> ::std::os::raw::c_int {
    unsafe {
        let (
            arg_window_info,
            arg_client,
            arg_url,
            arg_settings,
            arg_extra_info,
            arg_request_context,
        ) = (
            window_info,
            client,
            url,
            settings,
            extra_info,
            request_context,
        );
        let mut arg_window_info: _cef_window_info_t = arg_window_info.clone().into();
        let arg_window_info = &mut arg_window_info;
        let arg_client = arg_client.as_raw();
        let arg_url = arg_url.as_raw();
        let mut arg_settings: _cef_browser_settings_t = arg_settings.clone().into();
        let arg_settings = &mut arg_settings;
        let arg_extra_info = arg_extra_info.as_raw();
        let arg_request_context = arg_request_context.as_raw();
        let result = cef_browser_host_create_browser(
            arg_window_info,
            arg_client,
            arg_url,
            arg_settings,
            arg_extra_info,
            arg_request_context,
        );
        result.as_wrapper()
    }
}
pub fn browser_host_create_browser_sync<'a>(
    window_info: &'a WindowInfo,
    client: &'a mut Client,
    url: &'a CefStringUtf16,
    settings: &'a BrowserSettings,
    extra_info: &'a mut DictionaryValue,
    request_context: &'a mut RequestContext,
) -> Browser {
    unsafe {
        let (
            arg_window_info,
            arg_client,
            arg_url,
            arg_settings,
            arg_extra_info,
            arg_request_context,
        ) = (
            window_info,
            client,
            url,
            settings,
            extra_info,
            request_context,
        );
        let mut arg_window_info: _cef_window_info_t = arg_window_info.clone().into();
        let arg_window_info = &mut arg_window_info;
        let arg_client = arg_client.as_raw();
        let arg_url = arg_url.as_raw();
        let mut arg_settings: _cef_browser_settings_t = arg_settings.clone().into();
        let arg_settings = &mut arg_settings;
        let arg_extra_info = arg_extra_info.as_raw();
        let arg_request_context = arg_request_context.as_raw();
        let result = cef_browser_host_create_browser_sync(
            arg_window_info,
            arg_client,
            arg_url,
            arg_settings,
            arg_extra_info,
            arg_request_context,
        );
        result.as_wrapper()
    }
}
pub fn browser_host_get_browser_by_identifier<'a>(browser_id: ::std::os::raw::c_int) -> Browser {
    unsafe {
        let arg_browser_id = browser_id;
        let arg_browser_id = arg_browser_id;
        let result = cef_browser_host_get_browser_by_identifier(arg_browser_id);
        result.as_wrapper()
    }
}
pub fn menu_model_create<'a>(delegate: &'a mut MenuModelDelegate) -> MenuModel {
    unsafe {
        let arg_delegate = delegate;
        let arg_delegate = arg_delegate.as_raw();
        let result = cef_menu_model_create(arg_delegate);
        result.as_wrapper()
    }
}
pub fn print_settings_create<'a>() -> PrintSettings {
    unsafe {
        let result = cef_print_settings_create();
        result.as_wrapper()
    }
}
pub fn response_create<'a>() -> Response {
    unsafe {
        let result = cef_response_create();
        result.as_wrapper()
    }
}
pub fn is_cert_status_error<'a>(status: CertStatus) -> ::std::os::raw::c_int {
    unsafe {
        let arg_status = status;
        let arg_status = arg_status.as_raw();
        let result = cef_is_cert_status_error(arg_status);
        result.as_wrapper()
    }
}
pub fn command_line_create<'a>() -> CommandLine {
    unsafe {
        let result = cef_command_line_create();
        result.as_wrapper()
    }
}
pub fn command_line_get_global<'a>() -> CommandLine {
    unsafe {
        let result = cef_command_line_get_global();
        result.as_wrapper()
    }
}
pub fn task_runner_get_for_current_thread<'a>() -> TaskRunner {
    unsafe {
        let result = cef_task_runner_get_for_current_thread();
        result.as_wrapper()
    }
}
pub fn task_runner_get_for_thread<'a>(thread_id: ThreadId) -> TaskRunner {
    unsafe {
        let arg_thread_id = thread_id;
        let arg_thread_id = arg_thread_id.as_raw();
        let result = cef_task_runner_get_for_thread(arg_thread_id);
        result.as_wrapper()
    }
}
pub fn currently_on<'a>(thread_id: ThreadId) -> ::std::os::raw::c_int {
    unsafe {
        let arg_thread_id = thread_id;
        let arg_thread_id = arg_thread_id.as_raw();
        let result = cef_currently_on(arg_thread_id);
        result.as_wrapper()
    }
}
pub fn post_task<'a>(thread_id: ThreadId, task: &'a mut Task) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_thread_id, arg_task) = (thread_id, task);
        let arg_thread_id = arg_thread_id.as_raw();
        let arg_task = arg_task.as_raw();
        let result = cef_post_task(arg_thread_id, arg_task);
        result.as_wrapper()
    }
}
pub fn post_delayed_task<'a>(
    thread_id: ThreadId,
    task: &'a mut Task,
    delay_ms: i64,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_thread_id, arg_task, arg_delay_ms) = (thread_id, task, delay_ms);
        let arg_thread_id = arg_thread_id.as_raw();
        let arg_task = arg_task.as_raw();
        let arg_delay_ms = arg_delay_ms;
        let result = cef_post_delayed_task(arg_thread_id, arg_task, arg_delay_ms);
        result.as_wrapper()
    }
}
pub fn v8context_get_current_context<'a>() -> V8context {
    unsafe {
        let result = cef_v8context_get_current_context();
        result.as_wrapper()
    }
}
pub fn v8context_get_entered_context<'a>() -> V8context {
    unsafe {
        let result = cef_v8context_get_entered_context();
        result.as_wrapper()
    }
}
pub fn v8context_in_context<'a>() -> ::std::os::raw::c_int {
    unsafe {
        let result = cef_v8context_in_context();
        result.as_wrapper()
    }
}
pub fn v8value_create_undefined<'a>() -> V8value {
    unsafe {
        let result = cef_v8value_create_undefined();
        result.as_wrapper()
    }
}
pub fn v8value_create_null<'a>() -> V8value {
    unsafe {
        let result = cef_v8value_create_null();
        result.as_wrapper()
    }
}
pub fn v8value_create_bool<'a>(value: ::std::os::raw::c_int) -> V8value {
    unsafe {
        let arg_value = value;
        let arg_value = arg_value;
        let result = cef_v8value_create_bool(arg_value);
        result.as_wrapper()
    }
}
pub fn v8value_create_int<'a>(value: i32) -> V8value {
    unsafe {
        let arg_value = value;
        let arg_value = arg_value;
        let result = cef_v8value_create_int(arg_value);
        result.as_wrapper()
    }
}
pub fn v8value_create_uint<'a>(value: u32) -> V8value {
    unsafe {
        let arg_value = value;
        let arg_value = arg_value;
        let result = cef_v8value_create_uint(arg_value);
        result.as_wrapper()
    }
}
pub fn v8value_create_double<'a>(value: f64) -> V8value {
    unsafe {
        let arg_value = value;
        let arg_value = arg_value;
        let result = cef_v8value_create_double(arg_value);
        result.as_wrapper()
    }
}
pub fn v8value_create_date<'a>(date: _cef_basetime_t) -> V8value {
    unsafe {
        let arg_date = date;
        let mut arg_date: _cef_basetime_t = arg_date.clone().into();
        let arg_date = &mut arg_date;
        let result = cef_v8value_create_date(arg_date);
        result.as_wrapper()
    }
}
pub fn v8value_create_string<'a>(value: &'a CefStringUtf16) -> V8value {
    unsafe {
        let arg_value = value;
        let arg_value = arg_value.as_raw();
        let result = cef_v8value_create_string(arg_value);
        result.as_wrapper()
    }
}
pub fn v8value_create_object<'a>(
    accessor: &'a mut V8accessor,
    interceptor: &'a mut V8interceptor,
) -> V8value {
    unsafe {
        let (arg_accessor, arg_interceptor) = (accessor, interceptor);
        let arg_accessor = arg_accessor.as_raw();
        let arg_interceptor = arg_interceptor.as_raw();
        let result = cef_v8value_create_object(arg_accessor, arg_interceptor);
        result.as_wrapper()
    }
}
pub fn v8value_create_array<'a>(length: ::std::os::raw::c_int) -> V8value {
    unsafe {
        let arg_length = length;
        let arg_length = arg_length;
        let result = cef_v8value_create_array(arg_length);
        result.as_wrapper()
    }
}
pub fn v8value_create_array_buffer<'a>(
    buffer: *mut ::std::os::raw::c_void,
    length: usize,
    release_callback: &'a mut V8arrayBufferReleaseCallback,
) -> V8value {
    unsafe {
        let (arg_buffer, arg_length, arg_release_callback) = (buffer, length, release_callback);
        let arg_buffer = arg_buffer as *mut _;
        let arg_length = arg_length;
        let arg_release_callback = arg_release_callback.as_raw();
        let result = cef_v8value_create_array_buffer(arg_buffer, arg_length, arg_release_callback);
        result.as_wrapper()
    }
}
pub fn v8value_create_array_buffer_with_copy<'a>(
    buffer: *mut ::std::os::raw::c_void,
    length: usize,
) -> V8value {
    unsafe {
        let (arg_buffer, arg_length) = (buffer, length);
        let arg_buffer = arg_buffer as *mut _;
        let arg_length = arg_length;
        let result = cef_v8value_create_array_buffer_with_copy(arg_buffer, arg_length);
        result.as_wrapper()
    }
}
pub fn v8value_create_function<'a>(
    name: &'a CefStringUtf16,
    handler: &'a mut V8handler,
) -> V8value {
    unsafe {
        let (arg_name, arg_handler) = (name, handler);
        let arg_name = arg_name.as_raw();
        let arg_handler = arg_handler.as_raw();
        let result = cef_v8value_create_function(arg_name, arg_handler);
        result.as_wrapper()
    }
}
pub fn v8value_create_promise<'a>() -> V8value {
    unsafe {
        let result = cef_v8value_create_promise();
        result.as_wrapper()
    }
}
pub fn v8stack_trace_get_current<'a>(frame_limit: ::std::os::raw::c_int) -> V8stackTrace {
    unsafe {
        let arg_frame_limit = frame_limit;
        let arg_frame_limit = arg_frame_limit;
        let result = cef_v8stack_trace_get_current(arg_frame_limit);
        result.as_wrapper()
    }
}
pub fn register_extension<'a>(
    extension_name: &'a CefStringUtf16,
    javascript_code: &'a CefStringUtf16,
    handler: &'a mut V8handler,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_extension_name, arg_javascript_code, arg_handler) =
            (extension_name, javascript_code, handler);
        let arg_extension_name = arg_extension_name.as_raw();
        let arg_javascript_code = arg_javascript_code.as_raw();
        let arg_handler = arg_handler.as_raw();
        let result = cef_register_extension(arg_extension_name, arg_javascript_code, arg_handler);
        result.as_wrapper()
    }
}
pub fn register_scheme_handler_factory<'a>(
    scheme_name: &'a CefStringUtf16,
    domain_name: &'a CefStringUtf16,
    factory: &'a mut SchemeHandlerFactory,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_scheme_name, arg_domain_name, arg_factory) = (scheme_name, domain_name, factory);
        let arg_scheme_name = arg_scheme_name.as_raw();
        let arg_domain_name = arg_domain_name.as_raw();
        let arg_factory = arg_factory.as_raw();
        let result =
            cef_register_scheme_handler_factory(arg_scheme_name, arg_domain_name, arg_factory);
        result.as_wrapper()
    }
}
pub fn clear_scheme_handler_factories<'a>() -> ::std::os::raw::c_int {
    unsafe {
        let result = cef_clear_scheme_handler_factories();
        result.as_wrapper()
    }
}
pub fn execute_process<'a>(
    args: &'a MainArgs,
    application: &'a mut App,
    windows_sandbox_info: *mut ::std::os::raw::c_void,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_args, arg_application, arg_windows_sandbox_info) =
            (args, application, windows_sandbox_info);
        let mut arg_args: _cef_main_args_t = arg_args.clone().into();
        let arg_args = &mut arg_args;
        let arg_application = arg_application.as_raw();
        let arg_windows_sandbox_info = arg_windows_sandbox_info as *mut _;
        let result = cef_execute_process(arg_args, arg_application, arg_windows_sandbox_info);
        result.as_wrapper()
    }
}
pub fn initialize<'a>(
    args: &'a MainArgs,
    settings: &'a Settings,
    application: &'a mut App,
    windows_sandbox_info: *mut ::std::os::raw::c_void,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_args, arg_settings, arg_application, arg_windows_sandbox_info) =
            (args, settings, application, windows_sandbox_info);
        let mut arg_args: _cef_main_args_t = arg_args.clone().into();
        let arg_args = &mut arg_args;
        let mut arg_settings: _cef_settings_t = arg_settings.clone().into();
        let arg_settings = &mut arg_settings;
        let arg_application = arg_application.as_raw();
        let arg_windows_sandbox_info = arg_windows_sandbox_info as *mut _;
        let result = cef_initialize(
            arg_args,
            arg_settings,
            arg_application,
            arg_windows_sandbox_info,
        );
        result.as_wrapper()
    }
}
pub fn get_exit_code<'a>() -> ::std::os::raw::c_int {
    unsafe {
        let result = cef_get_exit_code();
        result.as_wrapper()
    }
}
pub fn shutdown<'a>() {
    unsafe {
        let result = cef_shutdown();
        result
    }
}
pub fn do_message_loop_work<'a>() {
    unsafe {
        let result = cef_do_message_loop_work();
        result
    }
}
pub fn run_message_loop<'a>() {
    unsafe {
        let result = cef_run_message_loop();
        result
    }
}
pub fn quit_message_loop<'a>() {
    unsafe {
        let result = cef_quit_message_loop();
        result
    }
}
pub fn urlrequest_create<'a>(
    request: &'a mut Request,
    client: &'a mut UrlrequestClient,
    request_context: &'a mut RequestContext,
) -> Urlrequest {
    unsafe {
        let (arg_request, arg_client, arg_request_context) = (request, client, request_context);
        let arg_request = arg_request.as_raw();
        let arg_client = arg_client.as_raw();
        let arg_request_context = arg_request_context.as_raw();
        let result = cef_urlrequest_create(arg_request, arg_client, arg_request_context);
        result.as_wrapper()
    }
}
pub fn label_button_create<'a>(
    delegate: &'a mut ButtonDelegate,
    text: &'a CefStringUtf16,
) -> LabelButton {
    unsafe {
        let (arg_delegate, arg_text) = (delegate, text);
        let arg_delegate = arg_delegate.as_raw();
        let arg_text = arg_text.as_raw();
        let result = cef_label_button_create(arg_delegate, arg_text);
        result.as_wrapper()
    }
}
pub fn menu_button_create<'a>(
    delegate: &'a mut MenuButtonDelegate,
    text: &'a CefStringUtf16,
) -> MenuButton {
    unsafe {
        let (arg_delegate, arg_text) = (delegate, text);
        let arg_delegate = arg_delegate.as_raw();
        let arg_text = arg_text.as_raw();
        let result = cef_menu_button_create(arg_delegate, arg_text);
        result.as_wrapper()
    }
}
pub fn textfield_create<'a>(delegate: &'a mut TextfieldDelegate) -> Textfield {
    unsafe {
        let arg_delegate = delegate;
        let arg_delegate = arg_delegate.as_raw();
        let result = cef_textfield_create(arg_delegate);
        result.as_wrapper()
    }
}
pub fn browser_view_create<'a>(
    client: &'a mut Client,
    url: &'a CefStringUtf16,
    settings: &'a BrowserSettings,
    extra_info: &'a mut DictionaryValue,
    request_context: &'a mut RequestContext,
    delegate: &'a mut BrowserViewDelegate,
) -> BrowserView {
    unsafe {
        let (arg_client, arg_url, arg_settings, arg_extra_info, arg_request_context, arg_delegate) =
            (client, url, settings, extra_info, request_context, delegate);
        let arg_client = arg_client.as_raw();
        let arg_url = arg_url.as_raw();
        let mut arg_settings: _cef_browser_settings_t = arg_settings.clone().into();
        let arg_settings = &mut arg_settings;
        let arg_extra_info = arg_extra_info.as_raw();
        let arg_request_context = arg_request_context.as_raw();
        let arg_delegate = arg_delegate.as_raw();
        let result = cef_browser_view_create(
            arg_client,
            arg_url,
            arg_settings,
            arg_extra_info,
            arg_request_context,
            arg_delegate,
        );
        result.as_wrapper()
    }
}
pub fn browser_view_get_for_browser<'a>(browser: &'a mut Browser) -> BrowserView {
    unsafe {
        let arg_browser = browser;
        let arg_browser = arg_browser.as_raw();
        let result = cef_browser_view_get_for_browser(arg_browser);
        result.as_wrapper()
    }
}
pub fn scroll_view_create<'a>(delegate: &'a mut ViewDelegate) -> ScrollView {
    unsafe {
        let arg_delegate = delegate;
        let arg_delegate = arg_delegate.as_raw();
        let result = cef_scroll_view_create(arg_delegate);
        result.as_wrapper()
    }
}
pub fn display_get_primary<'a>() -> Display {
    unsafe {
        let result = cef_display_get_primary();
        result.as_wrapper()
    }
}
pub fn display_get_nearest_point<'a>(
    point: &'a Point,
    input_pixel_coords: ::std::os::raw::c_int,
) -> Display {
    unsafe {
        let (arg_point, arg_input_pixel_coords) = (point, input_pixel_coords);
        let mut arg_point: _cef_point_t = arg_point.clone().into();
        let arg_point = &mut arg_point;
        let arg_input_pixel_coords = arg_input_pixel_coords;
        let result = cef_display_get_nearest_point(arg_point, arg_input_pixel_coords);
        result.as_wrapper()
    }
}
pub fn display_get_matching_bounds<'a>(
    bounds: &'a Rect,
    input_pixel_coords: ::std::os::raw::c_int,
) -> Display {
    unsafe {
        let (arg_bounds, arg_input_pixel_coords) = (bounds, input_pixel_coords);
        let mut arg_bounds: _cef_rect_t = arg_bounds.clone().into();
        let arg_bounds = &mut arg_bounds;
        let arg_input_pixel_coords = arg_input_pixel_coords;
        let result = cef_display_get_matching_bounds(arg_bounds, arg_input_pixel_coords);
        result.as_wrapper()
    }
}
pub fn display_get_count<'a>() -> usize {
    unsafe {
        let result = cef_display_get_count();
        result.as_wrapper()
    }
}
pub fn display_get_alls<'a>(displays: Option<&'a mut &'a mut [Option<Display>]>) {
    unsafe {
        let arg_displays = displays;
        let mut out_displays_count = arg_displays
            .as_ref()
            .map(|slice| slice.len())
            .unwrap_or_default();
        let arg_displays_count = &mut out_displays_count;
        let mut out_displays = arg_displays;
        let arg_displays = &mut out_displays;
        let mut vec_displays = arg_displays
            .as_mut()
            .map(|slice| {
                slice
                    .iter_mut()
                    .map(|elem| {
                        elem.as_mut()
                            .map(|elem| std::mem::take(elem).into_raw())
                            .unwrap_or(std::ptr::null_mut())
                    })
                    .collect::<Vec<_>>()
            })
            .unwrap_or_default();
        let arg_displays = if vec_displays.is_empty() {
            std::ptr::null_mut()
        } else {
            vec_displays.as_mut_ptr()
        };
        let result = cef_display_get_alls(arg_displays_count, arg_displays);
        if let Some(out_displays) = out_displays {
            for i in 0..out_displays_count {
                out_displays[i] = if vec_displays[i].is_null() {
                    None
                } else {
                    Some(vec_displays[i].as_wrapper())
                };
            }
            *out_displays = &mut (*out_displays)[..out_displays_count];
        }
        result
    }
}
pub fn display_convert_screen_point_to_pixels<'a>(point: &'a Point) -> Point {
    unsafe {
        let arg_point = point;
        let mut arg_point: _cef_point_t = arg_point.clone().into();
        let arg_point = &mut arg_point;
        let result = cef_display_convert_screen_point_to_pixels(arg_point);
        result.as_wrapper()
    }
}
pub fn display_convert_screen_point_from_pixels<'a>(point: &'a Point) -> Point {
    unsafe {
        let arg_point = point;
        let mut arg_point: _cef_point_t = arg_point.clone().into();
        let arg_point = &mut arg_point;
        let result = cef_display_convert_screen_point_from_pixels(arg_point);
        result.as_wrapper()
    }
}
pub fn display_convert_screen_rect_to_pixels<'a>(rect: &'a Rect) -> Rect {
    unsafe {
        let arg_rect = rect;
        let mut arg_rect: _cef_rect_t = arg_rect.clone().into();
        let arg_rect = &mut arg_rect;
        let result = cef_display_convert_screen_rect_to_pixels(arg_rect);
        result.as_wrapper()
    }
}
pub fn display_convert_screen_rect_from_pixels<'a>(rect: &'a Rect) -> Rect {
    unsafe {
        let arg_rect = rect;
        let mut arg_rect: _cef_rect_t = arg_rect.clone().into();
        let arg_rect = &mut arg_rect;
        let result = cef_display_convert_screen_rect_from_pixels(arg_rect);
        result.as_wrapper()
    }
}
pub fn panel_create<'a>(delegate: &'a mut PanelDelegate) -> Panel {
    unsafe {
        let arg_delegate = delegate;
        let mut arg_delegate: _cef_panel_delegate_t = arg_delegate.clone().into();
        let arg_delegate = &mut arg_delegate;
        let result = cef_panel_create(arg_delegate);
        result.as_wrapper()
    }
}
pub fn window_create_top_level<'a>(delegate: &'a mut WindowDelegate) -> Window {
    unsafe {
        let arg_delegate = delegate;
        let arg_delegate = arg_delegate.as_raw();
        let result = cef_window_create_top_level(arg_delegate);
        result.as_wrapper()
    }
}
